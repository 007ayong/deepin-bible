# 简单bash脚本 {#chap:simple-bash-scripts}

通过阅读本章，你将会了解到以下几项内容。

- 理解脚本的概念
- bash进行判断和简单数学计算
- bash 的流程结构
- 实现把UC视频缓存变为普通视频文件的脚本

## 何谓 shell 脚本

我认为就是最初的程序员一条条命令写得太累了，能不能把每行命令都放在一个文本文件里，让shell自己来读取呢，这样脚本就诞生了。囊括了命令、函数、变量等内容，实现一条命令完成众多工作的功能，可以复杂到启动系统，也可用简单到只有一条命令，类似 Windows 下的批处理文件。

### 执行和调试

由于 shell 脚本都是文本，可以用任意编辑器打开，可当做`bash`或`zsh`等 shell 的参数来逐行直接执行，比如我们新建一个文本文件，内写上，
`uname -a`，保存为`myscript`。可以通过如下方式执行，
\lstset{mathescape=true}
```bash
$\$$ echo 'uname -a' > myscript
$\$$ bash myscript 
Linux litianci-PC 4.15.0-29deepin-generic $\#$31 SMP Fri Jul 27 07:12:08 UTC 2018 x86\_64 GNU/Linux
```
\lstset{mathescape=false}

**解释**

1. 第1行，创建`myscript`文件。
1. 第2行，执行该脚本文件
1. 第3行，输出结果。

另外，也可用给脚本加上可执行权限，直接运行。通常在脚本第一行`#!/bin/bash`告诉 shell 使用 `/bin/bash` 执行该脚本。对于使用`Python`或者`R`语言等执行的脚本，相应的把`/bin/bash`换成相应的脚本解释器`Python`或者`RScript`等。

在 shell 脚本中，使用 `#` 表示单行注释，也就是从 `#` 到行尾的内容为注释内容。当然，有些`#`属于字符串的内容或者其他语法格式，不表示单行注释。如果你使用`vim`等编辑器打开脚本的时候，会发现注释的颜色是跟其他部分不一样的。通常在脚本第二行开始该脚本的功能注释，也可以添加作者、编辑信息等，然后另起一行注释该脚本的名称。空一行，开始脚本正文内容。如下面所示，

```bash
#!/bin/bash
# 本脚本实现 UC 浏览器视频缓存内容转换为一个完整的 MP4 文件
# ucvideo

if [! -e $2]
    echo "请按照如下格式调用该脚本"
fi
```

写完脚本，保存后，一般使用`chmod u+x ucvideo`的方式，给该脚本添加可执行权限。这样，可以像普通命令那样直接调用该脚本了。

```bash
$ ./ucvideo
```

当然，跟其他程序类似，脚本不可避免的要调试纠错，下面几种方法可能有用，

- 注释掉某些内容，方法就是在行首加`#`；
- 使用 `echo`输出相关参数信息或者其他需要显示的内容。
- 使用`bash -x myscript`，会输出每行命令及执行结果，对于循环或者分支判断语句，可以告诉你具体执行了那些内容。

当然，最主要的还是要做到代码整洁，及时给自己的代码注释，避免后面自己都忘记咋回事了。

### shell 变量

为了存储一些输出结果，或者一些参数等，需要用到变量存储，方便脚本书写。对于内容偏大的临时结果，也可用使用文件存储。通常采用如下方式，

```bash
NAME=value
```

变量名`NAME`类似C语言的变量名规则，只可数字字母下划线，数字不可开头，区分大小写，中文不能出现在变量名中。对于变量值`value`则没有太多要求。通常是字符串、数字等，可以包含中文。比如，

```bash
HOME="中国"
e=2.7
```

对于命令的输出结果，通常采用`$(command)`和`` `command` ``的方式实现。比如，

```bash
MACHINE=`uname -n`
TODAY=$(date)
```
如果想获取变量的数值，可以使用`$NAME`的方法。

```bash
echo $MACHINE
```

第\@ref(chap:shell)章，简要介绍了`$`,`` ` ``,`*`,`!`等特殊字符。在脚本中有时需要他们的特殊功能，有时候需要他们保持原样，该怎么做呢，通常使用双引号`""`，单引号`''`，以及反斜杠`\`，看下面例子。

```bash
$ echo $HOME
/home/litianci
$ echo "$HOME , today is `date`"
/home/litianci,today is 2018年 11月 16日 星期五 21:25:46 CST
$ echo '$HOME , today is `date`'
$HOME , today is `date`
$ echo \$HOME \`date\`
$HOME `date`
```

特殊字符可以使用`\`转义为本来样子，直接输出即可。如果作为字符串，使用单引号`'`则保持原样不变，使用双引号`"`则实现转义。这在其他语言中也有类似做法。

### 特殊变量

作为脚本，作为命令来用时，不可避免的要传入参数，在脚本中，通常使用`$0,$1,...,$n`的方式来获取这些参数值。其中 `$0`,表示本脚本；`$n`，表示第`n`个输入参数。不管是`bash myscript`还是`./myscript`方式执行脚本，上述`$n`($n!=0$)都是一样的。另外`$#`表示共有多少个参数，`$@`保存着正行的输入。`$?`显示上一个命令的返回状态，一般返回`0`表示正常，其他数值表示异常或错误。看下面例子，脚本`myscript`的内容为。

```bash
#!/bin/bash
# 测试这些特使变量
# myscript

echo "第一个参数为： $1, 第二个参数为 $2."
echo "共有 $# 个参数"
echo "这些参数是 $@"
echo "该脚本名称为： $0."
```

分别执行`bash myscript first second`和`./myscript first second`，结果如下，

```bash
$ bash myscript first second
第一个参数为： first, 第二个参数为 second.
共有 2 个参数
这些参数是 first second
该脚本名称为： myscript.
$ chmod u+x myscript # 设置文件执行属性
$ ./myscript first second
第一个参数为： first, 第二个参数为 second.
共有 2 个参数
这些参数是 first second
该脚本名称为： ./myscript.
$ echo $?
0
```

### 执行时输入参数

`$n`(`n>0`)一般都是执行前输入的参数，有时候还需要在执行中跟用户交互，那就用到`read`命令了。新建脚本`readscript`内容如下，

```bash
#!/bin/bash
# 测试交互信息
# readscript

read -p "你叫啥名字，几岁啦？（两个答案请用空格隔开）" name age
echo "我知道啦，你叫 $name, $age 岁了。"
```

执行该脚本，

```bash
$ bash readscript 
你叫啥名字，几岁啦？（两个答案请用空格隔开）深度易经 3
我知道啦，你叫 深度易经, 3 岁了。
```

关于`read`命令的更多内容，比如输入密码，或者其他信息，请`read --help`查看。

### 其他需求的参数

有些脚本，输入的参数可能有默认值，使用`var1=${var2:-defaultvalue}`的方式，意思是变量`var2`如果存在赋值给`var1`，否则，把`defaultvalue`赋值给`var1`。

```bash
$ Birthday="2018-11-11"
$ Birthday=${Birthday:-`date`}
$ echo $Birthday
2018-11-11
$ Birthday=${DefaultDate:-`date`}
$ echo $Birthday
echo $Birthday 
2018年 11月 19日 星期一 21:48:35 CST
$ Name=${Name:-'尚未设置'}
$ echo $Name
尚未设置
```

有时，我们需要对参数再处理，比如对于路径的不同取舍，对某些合并参数等的提取，可能使用其他正则表达式截取部分字符串更合适，不过 Shell 还是提供了一些简单的截取功能。

- `${var#pattern}`：从头删除满足匹配模式`pattern`的最短子字符串。
- `${var##pattern}`：从头删除满足匹配模式`pattern`的最长子字符串。
- `${var%pattern}`：从尾删除满足匹配模式`pattern`的最短子字符串。
- `${var%%pattern}`：从尾删除满足匹配模式`pattern`的最长子字符串。

```bash
$ readme=/home/litianci/deepin-bible/Readme.md
$ file=${readme##*/}
$ echo $file 
Readme.md
$ dir=${readme%/*}
$ echo $dir
/home/litianci/deepin-bible
$ stringchar="--folder=ucvideo"
$ option=${stringchar%=*}
$ echo $option
--folder
$ value=${stringchar#*=}
$ echo $value
ucvideo
```

