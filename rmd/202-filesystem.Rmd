# 文件系统 {#chap:filesystem}

通过阅读本章，你将会了解到以下几项内容。

- 了解文件系统
- 查看文件（夹）及属性
- 创建文件（夹）
- 查看设置文件（夹）权限和归属
- 文件（夹）的剪切复制粘贴删除和重命名

## 

参考网页：

- https://blog.csdn.net/mzl87/article/details/79673012
- https://www.cnblogs.com/CoderJYF/p/6092604.html
- https://blog.csdn.net/fan0220/article/details/53079618

![Linux系统目录结构图](linux-fs-tree.png)

常用文件夹说明。

- `/`  —— 根目录，一般根目录下只存放目录，不要存放文件。/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中。
- `/bin`  ——           存放系统中最常用的二进制可执行文件（二进制文件）。基础系统所需要的那些命令位于此目录，也是最小系统所需要的命令；例如ls、cp、mkdir等命令。功能和/usr/bin类似，这个目录中的文件都是可执行的，普通用户都可以使用命令 
- `/boot`  ——           存放Linux内核和系统启动文件，包括Grub、lilo启动程序 
- `/dev`  ——            存放所有设备文件，包括硬盘、分区、键盘、鼠标、USB等 
- `/etc`  ——            存放系统所有配置文件，例如passwd存放用户账户信息，hostname存放主机名等。/etc/fstab是开机自动挂载一些分区的，在里面写入一些分区信息，就能实现开机挂载分区 
- `/home`  ——           用户目录的默认位置 
- `/initrd`  ——         存放启动时挂载initrd.img映像文件的目录，以及载入所需设备模块的目录 
- `/lib`  ——            存放共享的库文件，包含许多被/bin和/sbin中程序使用的库文件 
- `/lost+found`  ——     在ext2或者ext3文件系统中，当系统意外崩溃或者计算机意外关机，而产生一些文件碎片存放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。有时系统发生问题，有很多的文件被移动到这个目录中，可能会用手工的方式来修复或移动到文件的原位置上 
- `/media`  ——          即插即用型设备的挂载点自动在这个目录下创建。例如USB自动挂载后会在这个目录下产生一个目录；CDROM/DVD自动挂载后，也会在这个目录中创建一个目录，存放临时读入的文件 
- `/mnt`  ——            此目录通常用于作为被挂载的文件系统的挂载点 
- `/proc`  ——           存放所有标志为文件的进程，它们是通过进程号或其他的系统动态信息进行标识。例如CPU、硬盘分区、内存信息等存放在这里 
- `/opt`  ——            作为可选文件和程序的存放目录。有些软件包也会被安装在这里，也就是自定义软件包；有些用户自己编译的软件包，就可以安装在这个目录中 
- `/root`  ——           根用户（超级用户）的主目录 
- `/sbin`  ——           大多是涉及系统管理的命令的存放地，也是超级权限用户root的可执行命令存放地。普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的。注意，凡是目录sbin中包含的都是root权限才能执行的 
- `/srv`  ——            存放系统所提供的服务数据 
- `/sys`  ——            该目录用于将系统设备组织或层次结构，并向用户提供详细的内核数据信息 
- `/tmp`  ——            临时文件目录，有时用户运行程序的时候，会产生临时文件。/var/tmp目录和这个目录相似 
- `/usr`  ——            用于存放与系统用户直接有关的文件和目录，如应用程序及支出系统的库文件 
    - `/usr/X11R6`  ——          X Window系统 
    - `/usr/bin`  ——            用户管理员的标准命令 
    - `/usr/include`  ——        C/C++等开发工具语言环境的标准include文件 
    - `/usr/lib`  ——            应用程序及程序报的链接库 
    - `/usr/local`  ——          系统管理员安装的应用程序 
    - `/usr/local/share`  ——    系统管理员安装的共享文件 
    - `/usr/sbin`  ——           用户和管理员的标准命令 
    - `/usr/share`  ——          存放使用手册等共享文件的地方 
    - `/usr/share/dict`  ——     存放词表的目录 
    - `/usr/share/man`  ——      系统使用手册 
    - `/usr/share/misc`  ——     一般数据 
    - `/usr/share/sgml`  ——     SGML数据 
    - `/usr/share/xml`  ——      XML数据 
- `/var`  ——            通常用于存放长度可变的文件，例如日志文件和打印机文件 
    - `/var/cache`  ——          应用程序缓存目录 
    - `/var/crash`  ——          系统错误信息 
    - `/var/games`  ——          游戏数据 
    - `/var/lib`  ——            各种状态数据 
    - `/var/lock`  ——           文件锁定记录 
    - `/var/log`  ——            日志记录 
    - `/var/mail`  ——           电子邮件 
    - `/var/opt`  ——            `/opt`目录的变量数据 
    - `/var/run`  ——            进程的标示数据 
    - `/var/spool`  ——          存放电子邮件，打印任务等的队列目录 
    - `/var/tmp`  ——            临时文件目录

## 文件系统常用命令

: 文件系统常用命令

-----------------------------------------------------------------------
**命令**    **解释**
-------     -----------------------------------------------------------
`cd`        改变目录

`pwd`       显示当前目录

`mkdir`     创建文件夹

`chmod`     修改文件（夹）权限

`ls`        列出文件夹内容
-----------------------------------------------------------------------

下面给出几个简单例子。

```bash
$\$$ cd
$\$$ cd ~
$\$$ cd /usr/local/bin
$\$$ cd -
$\$$ cd ..
$\$$ pwd
```

**解释**

1. `cd` 输入不带参数，默认是回到自己的主目录，也即`~`目录，第一行第二行效果是一样的。
1. `cd` 输入带一个目录，则跳转到该目录，如果你没有权限，则跳转失败。
1. `-`短横线表示上一个目录，也就是旧目录，方便你在两个目录之间切换。
1. `cd` 输入的目录支持相对路径和绝对路径。`..`表示上级目录或者叫父目录，`.`表示当前目录，对于`/`根目录，其父目录就是他本身。
1. `pwd`打印当前目录。

```bash
$\$$ cd
$\$$ mkdir dir1
$\$$ mkdir -p dir2/dir22
$\$$ ls -ld dir1
drwxr-xr-x 2 litianci litianci 4096 10月 31 22:24 dir1
$\$$ chmod o-rx dir1
$\$$ touch dir1
$\$$ ls -ld dir1
drwxr-x--- 2 litianci litianci 4096 10月 31 23:22 dir1
```

**解释**

1. `cd` 到主目录。使用`mkdir`新建一个文件夹。如果你想创建嵌套的文件夹，或者多层文件夹，可以使用`mkdir -p`选项，这样就可以建立多层文件夹。
1. `ls -ld dir1`，`-d`选项，表示只显示文件夹本身，`-l`是列出详细信息。`drwxr-xr-x`表示：`d`该文件是个文件夹，`rwxr-xr-x`是该文件夹的权限。见后面详述。`2`表示其内部有2个子文件（夹），从上面的命令可以知道其实`dir1`是一个空文件夹，怎么会有两个子文件（夹）呢，其实是隐藏的`..`和`.`文件夹。你可以使用 `ls -la dir1`看到这连个文件夹。后面依次为本文件（夹）的用户、用户组、文件大小，修改日期和时间。最后是本文件名称。
1. 使用`chmod`命令，去除其他用户的读和执行权限（`-rx`）
1. 使用`touch`命令，修改`dir1`的**修改日期**。
1. 再次使用`ls -ld dir1`命令，会发现相关的数值发生了变化。

## 元字符和操作符

古人云”物以类聚，人以群分“。我们操作文件（夹）的时候，可能就需要批量操作。这个时候我们就可以这些文件（夹）”归类“，其实就是使用元字符表示某一类文件（夹）。这样操作起来更方便。

如果说元字符是对文件夹”分类“，那么操作符就是对”操作“按照一定的规则拼接。

### 元字符{#filesystem:metachar}

常用的元字符有如下三种方式。

- `*` 匹配任意数目的字符，跟正则表达式的`*`有所区别。
- `?` 匹配一个字符，一个汉字也是作为一个字符。
- `[...]` 匹配`[]`内的任意一个字符，支持短横线`-`表示连续的字符。一个汉字也是作为一个字符。

看下面例子，

```bash
$\$$ mkdir test
$\$$ cd test
$\$$ touch huawei huashuo 华为 华硕 深度 深不可测
$\$$ ls h*
huashuo  huawei
$\$$ ls 华*
华硕  华为
$\$$ ls 深*测
深不可测
```

**解释**

1. 第1-3行，创建空的文件夹`test`，并转到该文件夹，创建了`huawei`等六个文件。
1. 第4、6、8行，使用元字符`*`表示任意数目的字符，分别显示了匹配相关”分类“的文件。

下面紧接着上面的shell环境，继续例子，

```bash
$\$$ ls h?????
huawei
$\$$ ls 华?
华硕  华为
$\$$ ls 深?
深度
```

**解释**

1. 第1行，可以看出每个`?`代表一个字符。
1. 第3、5行，可以看出一个汉字算作一个字符。

下面我们看看`[...]`相关的例子，

```bash
$\$$ touch auawei buawei cuawei duawei
$\$$ ls [ah]uawei
auawei  huawei
$\$$ ls [a-dh]uawei
auawei  buawei  cuawei  duawei  huawei
$\$$ ls [a-dh]u*
auawei  buawei  cuawei  duawei  huashuo  huawei
```

**解释**

1. 第1行，为了方便演示，我新建了四个文件。
1. 第2行，`[ah]uawei`表示，`a`和`h`任选一个，后面紧挨着`uawei`。匹配的字符见第3行显示结果。
1. 第4行，我们可以看出短横线`-`的意思，表示一个序列。也支持数字的连续显示，但是只支持个位数，**是否如此请核实**。
1. 第6行，其实这些元字符可以配合使用。

### 操作符

本节内容见第\@ref(sec:redirect)小节。本节从略。

### 花括号`{}`

第\@ref(filesystem:metachar)小节提到的均为归类，前提是筛选，选择已经存在的事物，对已有的事情分类（**是否如此请核实**）。如果你想创建一个集合，可以选择花括号`{}`的方式，列出所有相关的元素。

```bash
$\$$ touch deepin{1,2,3,4}
$\$$ ls deepin*
deepin1  deepin2  deepin3  deepin4
$\$$ rm ./*
$\$$ touch {deepin,深度}-{5,6,7,8}
$\$$ ls
deepin-5  deepin-6  deepin-7  deepin-8  深度-5  深度-6  深度-7  深度-8
$\$$ rm {deepin,深度}-{5,6,7,8}
$\$$ ls
$\$$ touch {a..e}{1..3}
$\$$ ls
a1  a2  a3  b1  b2  b3  c1  c2  c3  d1  d2  d3  e1  e2  e3
$\$$ rm ./*
$\$$ touch {A..a}
touch: 无法创建'': 没有那个文件或目录
$\$$ ls
'`'   _    ]   A   C   E   G   I   K   M   O   Q   S   U   W   Y
'^'  '['   a   B   D   F   H   J   L   N   P   R   T   V   X   Z
$\$$ rm ./*
$\$$ touch {aa..ac}
$\$$ ls
{aa..ac}
$\$$ rm ./*
$\$$ touch {11..21}
$\$$ ls
11  12  13  14  15  16  17  18  19  20  21
$\$$ rm ./*
$\$$ touch {33..22}
$\$$ touch {z..b}
```

**解释**

1. 第1行，创建了`deepin`开头，以后面集合元素结尾的文件。
1. 第5行，集合拼接在一起，类似于笛卡尔积的形式组合起来。
1. 第10行，对于单字母支持序列功能，多字母则不支持。对于数字支持序列功能。按照ASCII码排序，从`A`到`a`包含不显示的字符，影响最终的显示。
1. 最后两行，没有显示结果，有兴趣的读者可以使用`ls`看看结果。

## 几个常用的目录

- `$HOME` 主目录
- `~` 波浪线，位于键盘左上角第二行开头的那个键（按下的时候需要按`shift`键），也是表示主目录，为了跳转到其他人的主目录，也可用使用`~<username>`的方式。比如跳转到`litianci`的主目录，`cd ~litianci`
- `-` 或者 `$OLDPWD`,表示上一个目录，这个是短横线，不是减号。如果你在两个目录之间切换的话，`cd -`方便你跳转，如果你还没有切换目录，跳转到旧目录则会报错。`-`还有其他的功能，比如放权当前环境切换到新用户，`sudo su -`，这个命令就是不管你现在处于什么目录，切换到`root`根用户，且工作目录为`root`根用户的主目录。
- `.` 或 `$PWD` 当前工作目录。这两者是否有区别，待查。
- `..` 上级目录，也即父目录。对于`/`根目录而言，`..`和`.`都表示本级目录。

## 文件（夹）的权限和归属

Linux 是多用户的系统，为了在一定程度上保护数据隐私，对文件（夹）进行简单的权限控制。这也是你输入命令或者做其他事情的时候会遇到的没有权限问题的根源，甚至部分用户喜欢用`root`根用户操作，也是因为权限控制造成的某些不方便。为了更好的用权，也为了数据的安全，还请能用普通用户的情况下，尽量少用`root`根用户操作。下面对权限进行简要介绍。

对于一个文件（夹）来说，他一定归属于某个用户，且归属于某个用户组。也一定有其他不属于前两者的用户，简称其他用户，有时候也想访问该文件（夹）。那么这个权限就是针对这三类人来设定的。当然，由于某些用户（组）被删除等，造成文件（夹）归属的用户（组）不存在了，这些就是无主文件（夹），这也是存在安全隐患的。在下章内容会讲述通过`find`命令查找此类无主文件（夹）的方法，可以采用相关方法，重新赋予其归属用户（组）或者删除等，这里就不叙述了。

### 权限

针对这三类用户，权限又可以分为读（Read）、写（Write）和执行（Execute）三类。这三类权限详细介绍见下表。

本节内容转载自：https://blog.csdn.net/zhao12795969/article/details/53448039

后续有时间再整理。

Linux的权限不是很细致，只有RWX三种
r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。
w(Write,写入)：对文件而言，具有新增,修改,删除文件内容的权限；对目录来说，具有新建，删除，修改，移动目录内文件的权限。
x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。
1、目录的只读访问不允许使用cd进入目录，必须要有执行的权限才能进入。
2、只有执行权限只能进入目录，不能看到目录下的内容，要想看到目录下的文件名和目录名，需要可读权限。
3、一个文件能不能被删除，主要看该文件所在的目录对用户是否具有写权限，如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外

4、目录的w位不设置，即使你拥有目录中某文件的w权限也不能写该文件


linux权限详解

一个用户、一个组 
我们来看一看 Linux 权限和所有权模型。我们已经看到每个文件属于一个用户和一个组。这正是 Linux 中权限模型的核心。您可以在 ls -l 清单中查看用户和组：

$ ls -l /bin/bash

 

-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
在这个特殊的示例中，/bin/bash 可执行文件属于 root 用户，并且在 wheel 组中。Linux 权限模型通过允许给每个文件系统对象设置三种独立的权限级别来工作 — 它们为文件的所有者、文件的组以及所有其他用户。

理解“ls -l”

我们来看一看我们的 ls -l 输出，检查一下这个清单的第一栏：

$ ls -l /bin/bash
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
第一个字段 -rwxr-xr-x 包含该特殊文件的权限的符号表示。该字段中的首字符（-）指定该文件的类型，本例中它是一个常规文件。其它可能的首字符还有： 
“d”目录
“l”符号链接
“c”字符专门设备文件
“b”块专门设备文件
“p”先进先出
“s”套接字
三个三元组
$ ls -l /bin/bash
-rwxr-xr-x    1 root     wheel      430540 Dec 23 18:27 /bin/bash
该字段的其余部分由三个三元组字符组成。第一个三元字符组代表文件所有者的权限，第二个代表文件的组的权限，第三个代表所有其他用户的权限： 
"rwx"
"r-x"
"r-x"
上面，r 表示允许读（查看文件中的数据），w 表示允许写（修改文件以及删除），x 表示允许“执行”（运行程序）。将所有这些信息放在一起，我们可以发现每个人都能够读该文件的内容和执行该文件，但是只允许文件所有者（root 用户）可以以任何方式修改该文件。因此，虽然一般用户可以复制该文件，但是只允许 root 用户更新或删除它。 
我是谁？
在我们看怎样改变文件的用户所有权和组所有权之前，我们首先来看一看怎样得知您当前的用户标识和组成员资格。除非最近您使用过 su 命令，否则您当前的用户标识是您用来登录系统的用户标识。但是，如果您经常使用 su，您可能不记得您当前有效的用户标识。要查看用户标识，输入 whoami：
# whoami
root
# su drobbins
$ whoami
drobbins
我在哪一组？
要看看您属于哪一组，使用 group 命令：
$ groups
drobbins wheel audio
在上面的示例中，我是 drobbins、wheel 和 audio 组的成员。如果您想看看其他用户在什么组，指定他们的用户名作为参数： 
$ groups root daemon
root : root bin daemon sys adm disk wheel floppy dialout tape video
daemon : daemon bin adm
改变用户和组所有权
为了改变文件或其它文件系统对象的所有者或组，分别使用 chown 或 chgrp。这两个命令都要一个用户名或组名作参数，后面跟上一个或多个文件名。

# chown root /etc/passwd
# chgrp wheel /etc/passwd
您还可以用 chown 命令的另一种形式同时设置所有者和组： 
# chown root.wheel /etc/passwd
除非您是超级用户，否则您不可以使用 chown，然而任何人都可以使用 chgrp 来将文件的组所有权改为他们所属的组。 
递归的所有权改变
chown 和 chgrp 都有一个 -R 选项，该选项可以用来告诉它们递归地将所属权和组改变应用到整个目录树中。例如：
# chown -R drobbins /home/drobbins
介绍 chmod
chown 和 chgrp 可以用来改变文件系统对象的所有者和组，而另一个程序 — 叫做 chmod — 用来改变我们可以在 ls -l 清单中看到的 rwx 权限。chmod 带有两个或多个参数：“mode”，描述怎样改变权限，后面跟将会受到影响的文件或文件列表：
$ chmod +x scriptfile.sh
在上面的示例中，我们的“mode”是 +x。您可能会猜到，+x 模式告诉 chmod，使该特殊文件对于用户、组以及其它任何人都是可执行的。如果我们想要除去一个文件的所有执行权限，我们应该这样做： 
$ chmod -x scriptfile.sh
用户／组／其他粒度
到此，我们的 chmod 示例已经影响到了所有三个三元组 — 用户、组和所有其他用户。通常，一次只修改一个或两个三元组很方便。要这样做，只需要在 + 或 - 符号之前，给您想要修改的特定的三元组指定符号字符。对于“用户”三元组使用 u，对于“组”三元组使用 g，对于“其他／每个人”使用 o：
$ chmod go-w scriptfile.sh
我们刚除去了组和所有其他用户的写权限，而保留“所有者”权限不动。 
重新设置权限
除了交替打开和关闭权限位以外，我们还可以一起重新设置它们。通过使用 = 操作符，我们可以告诉 chmod 我们要指定权限和取消别的权限：
$ chmod =rx scriptfile.sh
上面，我们只设置了所有的“read”和“execute”位，没有设置所有的“write”位。如果您仅仅想重新设置特定的三元组，您可以像下面这样，在 = 之前指定该三元组的符号名：
$ chmod u=rx scriptfile.sh
                        数字模式
                        直到现在为止，我们使用了叫做“符号”的模式来用 chmod 指定权限的改变。然而，指定权限还有
                        一种普遍使用的方法 — 使用 4 位八进制数。使用叫做数字权限语法的语法，每一位代表一个权限
                        三元组。例如，在 1777 中，777 设置本章我们所讨论的“owner”、“group”和“other”
                        标志。1 用来设置专门的权限位，我们将在本章的结束部分讲到。这个图表说明了怎样解释第二到
                        四位（777）：
                        模式 数字 
                        rwx 7 
                        rw- 6 
                        r-x 5 
                        r-- 4 
                        -wx 3 
                        -w- 2 
                        --x 1 
                        --- 0
                         
                        数字权限语法
                        当您需要给一个文件指定所有权限时，数字权限语法特别有用，比如在下面的示例中：
$ chmod 0755 scriptfile.sh
                        $ ls -l scriptfile.sh
                        -rwxr-xr-x    1 drobbins drobbins        0 Jan  9 17:44 scriptfile.sh
                        在该示例中，我们使用了 0755 模式，它展开为一个完整的权限设置“-rwxr-xr-x”。
                        Umask
                        
当进程创建了新文件时，它指定新文件应该具有的权限。通常，所请求的模式是 0666（每个人可读和可写），它比我们希望的具有更多的权限。幸运的是，不管什么时候创建了新文件，Linux 将参考叫做“umask”的东西。系统用 umask 值来将初始指定的权限降低为更合理、更安全的权限。您可以通过在命令行中输入 umask 来查看您当前的 umask 设置：
                        $ umask
                        0022
                        Linux 系统上，umask 的缺省值一般为 0022，它允许其他人读您的新文件（如果他们可以得到它们），但是不能进行修改。为了在缺省的情况下使新文件更安全，您可以改变 umask 设置： $ umask 0077umask 将确保组和其他用户对于新创建的文件绝对没有任何权限。那么，umask 怎样工作呢？与文件的“常规”权限不同，umask 指定应该关闭哪一个权限。我们来参阅一下我们的“模式到数字”映射表，从而使我们可以理解 0077 的 umask 的意思是什么： 模式 数字 rwx 7 rw- 6 r-x 5 r-- 4 -wx 3 -w- 2 --x 1 --- 0 使用该表，0077 的最后三位扩展为 ---rwxrwx。现在，请记住 umask 告诉系统禁用哪个权限。根据推断，我们可以看到将关闭所有“组”和“其他”权限，而“用户”权限将保留不动。
介绍 suid 和 sgid
                        当您最初登录时，将启动一个新的 shell 进程。您已经知道，但是您可能还不知道这个新的 shell
                         进程（通常是 bash）使用您的用户标识运行。照这样，bash 程序可以访问所有属于您的文件和
                        目录。事实上，作为用户，我们完全依靠其它程序来代表我们执行操作。因为您启动的程序继承了
                        您的用户标识，因此它们不能访问任何不允许您访问的文件系统对象。
                        例如，一般用户不能直接修改 passwd 文件，因为“write”标志已经对除“root 用户”以外的每个用户关闭：
$ ls -l /etc/passwd
                        -rw-r--r--    1 root     wheel        1355 Nov  1 21:16 /etc/passwd
                        但是，一般用户确实需要在他们需要改变其密码的任何时候，能够修改 /etc/passwd（至少间接地）。但是，如果用户不能修改该文件，究竟怎样完成这个工作呢？
                        Suid
                        幸好，Linux 权限模型有两个专门的位，叫做“suid”和“sgid”。当设置了一个可执行程序的“suid”这一位时，它将代表可执行文件的所有者运行，而不是代表启动程序的人运行。现在，回到 /etc/passwd 问题。如果看一看 passwd 可执行文件，我们可以看到它属于 root 用户：
                        $ ls -l /usr/bin/passwd
                        -rwsr-xr-x    1 root     wheel       17588 Sep 24 00:53 /usr/bin/passwd
                        您还将注意到，这里有一个 s 取替了用户权限三元组中的一个 x。这表明，对于这个特殊程序，设置了 suid 和可执行位。由于这个原因，当 passwd 运行时，它将代表 root 用户执行（具有完全超级用户访问权），而不是代表运行它的用户运行。又因为 passwd 以 root 用户访问权运行，所以能够修改 /etc/passwd 文件，而没有什么问题。
                        suid/sgid 告诫说明
                        我们看到了 suid 怎样工作，sgid 以同样的方式工作。它允许程序继承程序的组所有权，而不是当前用户的程序所有权。这里有一些关于 suid 和 sgid 的其它的但是很重要的信息。首先，suid 和 sgid 占据与 ls -l 清单中 x 位相同的空间。如果还设置了 x 位，则相应的位表示为 s（小写）。但是，如果没有设置 x 位，它将表示为 S（大写）。另一个很重要的提示：在许多环境中，suid 和 suid 很管用，但是不恰当地使用这些位可能使系统的安全遭到破坏。最好尽可能地少用“suid”程序。passwd 命令是为数不多的必须使用“suid”的命令之一。 
                        改变 suid 和 sgid
                        设置和除去 suid 与 sgid 位相当简单。这里，我们设置 suid 位：
                        # chmod u+s /usr/bin/myapp
                        此处，我们从一个目录除去 sgid 位。我们将看到 sgid 位怎样影响下面几屏中的目录：
# chmod g-s /home/drobbins
                        权限和目到此为止，我们从常规文件的角度来看权限。当从目录的角度看权限时，情况有一点不同。目录使用同样的权限标志，但是它们被解释为表示略微不同的含义。 对于一个目录，如果设置了“read”标志，您可以列出目录的内容；“write”表示您可以在目录中创建文件，“execute”表示您可以进入该目录并访问内部的任何子目录。没有“execute”标志，目录内的文件系统对象是不可访问的。没有“read”标志，目录内的文件系统对象是不可查看的，但是只要有人知道磁盘上对象的完整路径，就仍然可以访问目录内的对象。目录和 sgid如果启用了目录的“sgid”标志，在目录内创建的任何文件系统对象将继承目录的组。当您需要创建一个属于同一组的一组人使用的目录树时，这种特殊的功能很管用。只需要这样做： 
# mkdir /home/groupspace
                        # chgrp mygroup /home/groupspace
                        # chmod g+s /home/groupspace
                        现在，mygroup 组中的所有用户都可以在 /home/groupspace 内创建文件或目录，同样，他
                        们也将自动地分配到 mygroup 的组所有权。根据用户的 umask 设置，新文件系统对象对于 
                        mygroup 组的其他成员来说，可以或不可以是可读、可写或可执行的。
                        目录和删除
                        缺省情况下，Linux 目录以一种不是在所有情况下都很理想的方式表现。一般来说，只要对一个
                        目录有写访问权，任何人都可以重命名或删除该目录中的文件。对于个别用户使用的目录，这种行
                        为是很合理的。
                        但是，对于很多用户使用的目录来说，尤其是 /tmp 和 /var/tmp，这种行为可能会产生麻烦。
                        因为任何人都可以写这些目录，任何人都可以删除或重命名任何其他人的文件 — 即使是不属于
                        他们的！显然，当任何其他用户在任何时候都可以输入“rm -rf /tmp/*”并损坏每个人的文
                        件时，很难把 /tmp 用于任何有意义的文件。
                        所幸，Linux 有叫做“粘滞位”（sticky bit）的东西。当给 /tmp 设置了粘滞位（用 
                        chmod +t），唯一能够删除或重命名 /tmp 中文件的是该目录的所有者（通常是 root 用户）
                        、文件的所有者或 root 用户。事实上，所有 Linux 分发包都缺省地启用了 /tmp 的粘滞位，
                        而您还可以发现粘滞位在其它情况下也很管用。
                        难以理解的第一位
                        总结本章，我们最后来看一看数字模式的难以理解的第一位数。您可以看到，这个第一位数
                        用来设置 sticky、suid 和 sgid 位： 
                        suid sgid sticky 模式数字 on on on 7 on on off 6 on off on 5 on off off 4 off on on 3 off on off 2 off off on 1 off off off 0 
                        这里有一个怎样用 4 位数字模式来设置一个目录的权限的示例，该目录将由一个工作组使用： 
                        # chmod 1775 /home/groupfiles
                        请想一想 1755 数字模式权限设置的含义。
linux权限补充：rwt rwT rws rwS 特殊权限

众所周知，Linux的文件权限如: 777；666等，其实只要在相应的文件上加上UID的权限，就可以用到加权限人的身份去运行这个文件。所以我们只需要将bash复制出来到另一个地方，然后用root加上UID权限,只要用户运行此Shell就可以用用root的身份来执行任何文件了

一个文件都有一个所有者, 表示该文件是谁创建的. 同时, 该文件还有一个组编号, 表示该文件所属的组, 一般为文件所有者所属的组.

如果是一个可执行文件, 那么在执行时, 一般该文件只拥有调用该文件的用户具有的权限. 而setuid, setgid 可以来改变这种设置. 

setuid：该位是让普通用户可以以root用户的角色运行只有root帐号才能运行的程序或命令。比如我们用普通用户运行passwd命令来更改自己的口令，实际上最终更改的是/etc/passwd文件我们知道/etc/passwd文件是用户管理的配置文件，只有root权限的用户才能更改

　　[root@localhost ~]# ls -l /etc/passwd

　　-rw-r--r-- 1 root root 2379 04-21 13:18 /etc/passwd

　　作为普通用户如果修改自己的口令通过修改/etc/passwd肯定是不可完成的任务，但是不是可以通过一个命令来修改呢答案是肯定的，作为普通用户可以通过passwd 来修改自己的口令这归功于passwd命令的权限我们来看一下；

　　[root@localhost ~]# ls -l /usr/bin/passwd

　　-r-s--x--x 1 root root 21944 02-12 16:15 /usr/bin/passwd

　　因为/usr/bin/passwd 文件已经设置了setuid 权限位（也就是r-s--x--x中的s），所以普通用户能临时变成root，间接的修改/etc/passwd，以达到修改自己口令的权限

setgid: 该权限只对目录有效. 目录被设置该位后, 任何用户在此目录下创建的文件都具有和该目录所属的组相同的组.

sticky bit: 该位可以理解为防删除位. 一个文件是否可以被某用户删除, 主要取决于该文件所属的组是否对该用户具有写权限. 如果没有写权限, 则这个目录下的所有文件都不能被删除, 同时也不能添加新的文件. 如果希望用户能够添加文件但同时不能删除文件, 则可以对文件使用sticky bit位. 设置该位后, 就算用户对目录具有写权限, 也不能删除该文件.

下面说一下如何操作这些标志:

操作这些标志与操作文件权限的命令是一样的, 都是 chmod. 有两种方法来操作,

1) chmod u+s temp -- 为temp文件加上setuid标志. (setuid 只对文件有效)

chmod g+s tempdir -- 为tempdir目录加上setgid标志 (setgid 只对目录有效)

chmod o+t temp -- 为temp文件加上sticky标志 (sticky只对文件有效)

2) 采用八进制方式. 对一般文件通过三组八进制数字来置标志, 如 666, 777, 644等. 如果设置这些特殊标志, 则在这组数字之外外加一组八进制数字. 如 4666, 2777等. 这一组八进制数字三位的意义如下,

abc

a - setuid位, 如果该位为1, 则表示设置setuid 4---

b - setgid位, 如果该位为1, 则表示设置setgid 2---

c - sticky位, 如果该位为1, 则表示设置sticky 1---

设置完这些标志后, 可以用 ls -l 来查看. 如果有这些标志, 则会在原来的执行标志位置上显示. 如

rwsrw-r-- 表示有setuid标志

rwxrwsrw- 表示有setgid标志

rwxrw-rwt 表示有sticky标志

那么原来的执行标志x到哪里去了呢? 系统是这样规定的, 如果本来在该位上有x, 则这些特殊标志显示为小写字母 (s, s, t). 否则, 显示为大写字母 (S, S, T)

### 归属

参考网页：

- https://www.cnblogs.com/DawaTech/p/7249734.html

chgrp  用户名    文件名  -R

chown 用户名   文件名  -R

 

-R表示递归目录下所有文件


 
一、修改文件所属组群——chgrp
   修改文件所属组群很简单-chgrp命令，就是change group的缩写（我们可以利用这些来记忆命令）
   语法：chgrp  组群  文件名/目录 
   举例：
[root@redhat ~]# groupadd groupa
[root@redhat ~]# groupadd groupb
[root@redhat ~]# useradd   -g groupa zgz
[root@redhat ~]# su - zgz
[zgz@redhat ~]$ touch filea
[zgz@redhat ~]$ touch fileb
[zgz@redhat ~]$ ls -l
total 8
-rw-r--r--  1 zgz groupa 0 Sep 26 05:48 filea
-rw-r--r--  1 zgz groupa 0 Sep 26 05:50 fileb
          --
[root@redhat zgz]# chgrp  groupb filea      --改变filea所属群组
[root@redhat zgz]# ls -l
total 8
-rw-r--r--  1 zgz groupb 0 Sep 26 05:48 filea
-rw-r--r--  1 zgz groupa 0 Sep 26 05:50 fileb
 
二、修改文件拥有者——chown
   修改组群的命令使chgrp，即change group，那么修改文件拥有者的命令自然就是chown，即change owner。chown功能很多，不仅仅能更改文件拥有者，还可以修改文件所属组群。如果需要将某一目录下的所有文件都改变其拥有者，可以使用-R参数。
   语法如下：
   chown [-R] 账号名称      文件/目录
   chown [-R] 账号名称:组群  文件/目录
   举例：
[root@redhat zgz]# ls -l
total 20
-rw-r--r--  1 zgz groupb    0 Sep 26 05:48 filea
-rw-r--r--  1 zgz groupa    3 Sep 26 05:59 fileb
drwxr-xr-x  2 zgz groupa 4096 Sep 26 06:07 zgzdir
[root@redhat zgz]# chown myy fileb --修改fileb的拥有者为myy
[root@redhat zgz]# ls -l
total 20
-rw-r--r--  1 zgz groupb    0 Sep 26 05:48 filea
-rw-r--r--  1 myy groupa    3 Sep 26 05:59 fileb
drwxr-xr-x  2 zgz groupa 4096 Sep 26 06:07 zgzdir
[root@redhat zgz]# chown myy:groupa filea --修改filea的拥有者为myy，并且同
[root@redhat zgz]# ls -l时修改组群为groupa
total 20
-rw-r--r--  1 myy groupa    0 Sep 26 05:48 filea
-rw-r--r--  1 myy groupa    3 Sep 26 05:59 fileb
drwxr-xr-x  2 zgz groupa 4096 Sep 26 06:07 zgzdir
[root@redhat zgz]# chown -R myy  zgzdir                同时改变其下所有文件拥有者
total 20
-rw-r--r--  1 myy groupa    0 Sep 26 05:48 filea
-rw-r--r--  1 myy groupa    3 Sep 26 05:59 fileb
drwxr-xr-x  2 myy groupa 4096 Sep 26 06:07 zgzdir
[root@redhat zgz]# cd zgzdir/
[root@redhat zgzdir]# ls -l
total 8
-rw-r--r--  1 myy groupa 0 Sep 26 06:07 filec
-rw-r--r--  1 myy groupa 0 Sep 26 06:07 filed

## 文件（夹）的创建、查看、移动、复制和删除

有点类似数据库的增删改查（CRUD,Create,Read,Update,Delete），这里只提到了文件（夹）的创建、查看、移动（包括重命名）、复制和删除。修改涉及到文件的权限以及日期等等内容，这里略过不提。

### 文件（夹）的创建

对于文件夹的创建，常用`mkdir`这个命令。具体方法，前面已经讲解了。对于文件的创建，通常使用`touch`创建文件，通过`man touch`可以看出，一般情况，`touch`只是对访问和更改的时间戳重置为当前时间戳，创建文件只是附带功能。另外一般的编辑器，还有其他文件都有新建保存功能，这样也可用创建文件。这里就不详细介绍了。

### 文件（夹）的查看

对于文件的内容查看，可以通过各种阅读器或者编辑器等，根据文件的类型做出不同选择。因为Unix哲学奉行\cqh 一切皆文件\cqt ，编辑器是一种比较常见的查看方式，这个见第\@ref(chap:vim-find)章。

文件（夹）的查看，通常采用**深度文件管理器**。对于其属性，可以通过**深度文件管理器**右击找到属性来查看。当然在命令行下`ls`也是一个非常强大的存在。看下面的例子。

```bash
$\$$ ls
$\$$ ls -la
$\$$ ls -lR
```

**解释**

1. `ls`的选项`-a`表示把当前包含隐藏文件（夹）在内的所有文件（夹）显示出来。
1. `-R`选项是递归显示，可以把各个子文件夹的内容也显示出来。`-l`的显示内容，见上面章节说明。更多内容，可以查看`man ls`。
### 文件（夹）的移动及重命名

文件（夹）的移动和重命名是通过`mv`命令实现的。

```bash
$\$$ mv litianci deepin
$\$$ mv deepin ~
$\$$ mv test1 test2 test3 ~
$\$$ mv ~/deepin-bible/ ~/test/
$\$$ mv ~/Desktop/* ~/test/
```

**解释**

1. 第1行，对文件`litianci`重命名为 `deepin`。`mv`重命名时，不区分文件夹或文件。
1. 第2行，把文件 `deepin`移动到`~`文件夹。
1. 第3行，`mv`支持多个文件同时移动到最后面一个文件夹。请注意，**当多个文件（夹）同时移动时，最后一个必须是文件夹或指向文件夹的链接**。
1. 第4行，把文件夹`deepin-bible`文件夹，包括文件夹的内容（含隐藏内容），移动到`~/test/`文件夹。
1. 第5行，只是把文件夹`Desktop`内的非隐藏内容，移动到`~/test/`文件夹。

注意，默认的`mv`，对于重名冲突是直接覆盖的。如果想不被覆盖，建议在`~/.bashrc`内加上`alias mv='mv -i'`，遇到这类的问题的时候，就会征询你的意见再决定要不要覆盖。

### 文件（夹）的复制

```bash
$\$$ cp litianci deepin
$\$$ cp deepin ~
$\$$ cp test1 test2 test3 ~
$\$$ cp -r ~/deepin-bible/ ~/test/
$\$$ cp -ra ~/Desktop/* ~/test/
```

**解释**

1. 第1-3行，类似`mv`命令，实现对文件的复制，不含文件夹的复制。
1. 第4行，对于文件夹的复制，需要带`-r`选项，递归（`recursive`）的意思。
1. 第5行，复制`-a`选项，表示复制后的文件（夹）各时间戳和权限跟原文件（夹）一样。

### 文件（夹）的删除

```bash
$\$$ rm deepin
$\$$ rm ./-
$\$$ rm *
$\$$ rmdir /home/joe/nothing/
$\$$ rm -r /home/joe/bigdir/
$\$$ rm -rf /home/joe/hugedir/
$\$$ sudo rm -rf /#千万不要试运行
```

**解释**

1. 第1行，普通文件可以直接删除。不支持文件夹直接删除。如果要删除文件夹见第4-6行。
1. 第2行，对于特殊文件，比如`-`，一般写绝对路径。
1. 第3行，`*`一般代表的都是非隐藏文件（夹）。没有`-r`递归选项，也可用删除当前文件夹下的所有非隐藏内容。
1. 第4行，删除文件夹的命令`rmdir`，删除了`nothing`文件夹及其内容。
1. 第5-6行，`-r`表示递归，可以使用`rm`删除文件夹。`-f`是强制删除，实际是不用询问直接删除，对于没有权限删除的，依旧无法删除。
1. 第7行，千万不要试运行。但是有时候为了删除本文件夹下的内容，往往错输。

我的建议是`alias rm='trash-put'`，把删除改为放置到回收站。具体做法见附录\@ref(chap:faqs)。

## 总结

