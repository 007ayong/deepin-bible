# 文件系统 {#chap:filesystem}

通过阅读本章，你将会了解到以下几项内容。

- 了解文件系统
- 查看文件（夹）及属性
- 创建文件（夹）
- 查看设置文件（夹）权限和归属
- 文件（夹）的剪切复制粘贴删除和重命名

## 树形结构

参考网页：

- https://blog.csdn.net/mzl87/article/details/79673012
- https://www.cnblogs.com/CoderJYF/p/6092604.html
- https://blog.csdn.net/fan0220/article/details/53079618

![Linux系统目录结构图](images/linux-fs-tree.png)

常用文件夹说明。

- `/`  —— 根目录，一般根目录下只存放目录，不要存放文件。/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中。
- `/bin`  ——           存放系统中最常用的二进制可执行文件（二进制文件）。基础系统所需要的那些命令位于此目录，也是最小系统所需要的命令；例如ls、cp、mkdir等命令。功能和/usr/bin类似，这个目录中的文件都是可执行的，普通用户都可以使用命令 
- `/boot`  ——           存放Linux内核和系统启动文件，包括Grub、lilo启动程序 
- `/dev`  ——            存放所有设备文件，包括硬盘、分区、键盘、鼠标、USB等 
- `/etc`  ——            存放系统所有配置文件，例如passwd存放用户账户信息，hostname存放主机名等。/etc/fstab是开机自动挂载一些分区的，在里面写入一些分区信息，就能实现开机挂载分区 
- `/home`  ——           用户目录的默认位置 
- `/initrd`  ——         存放启动时挂载initrd.img映像文件的目录，以及载入所需设备模块的目录 
- `/lib`  ——            存放共享的库文件，包含许多被/bin和/sbin中程序使用的库文件 
- `/lost+found`  ——     在ext2或者ext3文件系统中，当系统意外崩溃或者计算机意外关机，而产生一些文件碎片存放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。有时系统发生问题，有很多的文件被移动到这个目录中，可能会用手工的方式来修复或移动到文件的原位置上 
- `/media`  ——          即插即用型设备的挂载点自动在这个目录下创建。例如USB自动挂载后会在这个目录下产生一个目录；CDROM/DVD自动挂载后，也会在这个目录中创建一个目录，存放临时读入的文件 
- `/mnt`  ——            此目录通常用于作为被挂载的文件系统的挂载点 
- `/proc`  ——           存放所有标志为文件的进程，它们是通过进程号或其他的系统动态信息进行标识。例如CPU、硬盘分区、内存信息等存放在这里 
- `/opt`  ——            作为可选文件和程序的存放目录。有些软件包也会被安装在这里，也就是自定义软件包；有些用户自己编译的软件包，就可以安装在这个目录中 
- `/root`  ——           根用户（超级用户）的主目录 
- `/sbin`  ——           大多是涉及系统管理的命令的存放地，也是超级权限用户root的可执行命令存放地。普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的。注意，凡是目录sbin中包含的都是root权限才能执行的 
- `/srv`  ——            存放系统所提供的服务数据 
- `/sys`  ——            该目录用于将系统设备组织或层次结构，并向用户提供详细的内核数据信息 
- `/tmp`  ——            临时文件目录，有时用户运行程序的时候，会产生临时文件。/var/tmp目录和这个目录相似 
- `/usr`  ——            用于存放与系统用户直接有关的文件和目录，如应用程序及支出系统的库文件 
    - `/usr/X11R6`  ——          X Window系统 
    - `/usr/bin`  ——            用户管理员的标准命令 
    - `/usr/include`  ——        C/C++等开发工具语言环境的标准include文件 
    - `/usr/lib`  ——            应用程序及程序报的链接库 
    - `/usr/local`  ——          系统管理员安装的应用程序 
    - `/usr/local/share`  ——    系统管理员安装的共享文件 
    - `/usr/sbin`  ——           用户和管理员的标准命令 
    - `/usr/share`  ——          存放使用手册等共享文件的地方 
    - `/usr/share/dict`  ——     存放词表的目录 
    - `/usr/share/man`  ——      系统使用手册 
    - `/usr/share/misc`  ——     一般数据 
    - `/usr/share/sgml`  ——     SGML数据 
    - `/usr/share/xml`  ——      XML数据 
- `/var`  ——            通常用于存放长度可变的文件，例如日志文件和打印机文件 
    - `/var/cache`  ——          应用程序缓存目录 
    - `/var/crash`  ——          系统错误信息 
    - `/var/games`  ——          游戏数据 
    - `/var/lib`  ——            各种状态数据 
    - `/var/lock`  ——           文件锁定记录 
    - `/var/log`  ——            日志记录 
    - `/var/mail`  ——           电子邮件 
    - `/var/opt`  ——            `/opt`目录的变量数据 
    - `/var/run`  ——            进程的标示数据 
    - `/var/spool`  ——          存放电子邮件，打印任务等的队列目录 
    - `/var/tmp`  ——            临时文件目录

## 文件系统常用命令

: 文件系统常用命令

-----------------------------------------------------------------------
**命令**    **解释**
-------     -----------------------------------------------------------
`cd`        改变目录

`pwd`       显示当前目录

`mkdir`     创建文件夹

`chmod`     修改文件（夹）权限

`ls`        列出文件夹内容
-----------------------------------------------------------------------

下面给出几个简单例子。

```bash
$ cd
$ cd ~
$ cd /usr/local/bin
$ cd -
$ cd ..
$ pwd
```

**解释**

1. `cd` 输入不带参数，默认是回到自己的主目录，也即`~`目录，第一行第二行效果是一样的。
1. `cd` 输入带一个目录，则跳转到该目录，如果你没有权限，则跳转失败。
1. `-`短横线表示上一个目录，也就是旧目录，方便你在两个目录之间切换。
1. `cd` 输入的目录支持相对路径和绝对路径。`..`表示上级目录或者叫父目录，`.`表示当前目录，对于`/`根目录，其父目录就是他本身。
1. `pwd`打印当前目录。

```bash
$ cd
$ mkdir dir1
$ mkdir -p dir2/dir22
$ ls -ld dir1
drwxr-xr-x 2 litianci litianci 4096 10月 31 22:24 dir1
$ chmod o-rx dir1
$ touch dir1
$ ls -ld dir1
drwxr-x--- 2 litianci litianci 4096 10月 31 23:22 dir1
```

**解释**

1. `cd` 到主目录。使用`mkdir`新建一个文件夹。如果你想创建嵌套的文件夹，或者多层文件夹，可以使用`mkdir -p`选项，这样就可以建立多层文件夹。
1. `ls -ld dir1`，`-d`选项，表示只显示文件夹本身，`-l`是列出详细信息。`drwxr-xr-x`表示：`d`该文件是个文件夹，`rwxr-xr-x`是该文件夹的权限。见后面详述。`2`表示其内部有2个子文件（夹），从上面的命令可以知道其实`dir1`是一个空文件夹，怎么会有两个子文件（夹）呢，其实是隐藏的`..`和`.`文件夹。你可以使用 `ls -la dir1`看到这连个文件夹。后面依次为本文件（夹）的用户、用户组、文件大小，修改日期和时间。最后是本文件名称。
1. 使用`chmod`命令，去除其他用户的读和执行权限（`-rx`）
1. 使用`touch`命令，修改`dir1`的**修改日期**。
1. 再次使用`ls -ld dir1`命令，会发现相关的数值发生了变化。

## 元字符和操作符

古人云\cqh 物以类聚，人以群分\cqt 。我们操作文件（夹）的时候，可能就需要批量操作。这个时候我们就可以这些文件（夹）\cqh 归类\cqt ，其实就是使用元字符表示某一类文件（夹）。这样操作起来更方便。

如果说元字符是对文件夹\cqh 分类\cqt ，那么操作符就是对\cqh 操作\cqt 按照一定的规则拼接。

### 元字符{#filesystem:metachar}

常用的元字符有如下三种方式。

- `*` 匹配任意数目的字符，跟正则表达式的`*`有所区别。
- `?` 匹配一个字符，一个汉字也是作为一个字符。
- `[...]` 匹配`[]`内的任意一个字符，支持短横线`-`表示连续的字符。一个汉字也是作为一个字符。

看下面例子，

```bash
$ mkdir test
$ cd test
$ touch huawei huashuo 华为 华硕 深度 深不可测
$ ls h*
huashuo  huawei
$ ls 华*
华硕  华为
$ ls 深*测
深不可测
```

**解释**

1. 第1-3行，创建空的文件夹`test`，并转到该文件夹，创建了`huawei`等六个文件。
1. 第4、6、8行，使用元字符`*`表示任意数目的字符，分别显示了匹配相关”分类“的文件。

下面紧接着上面的shell环境，继续例子，

```bash
$ ls h?????
huawei
$ ls 华?
华硕  华为
$ ls 深?
深度
```

**解释**

1. 第1行，可以看出每个`?`代表一个字符。
1. 第3、5行，可以看出一个汉字算作一个字符。

下面我们看看`[...]`相关的例子，

```bash
$ touch auawei buawei cuawei duawei
$ ls [ah]uawei
auawei  huawei
$ ls [a-dh]uawei
auawei  buawei  cuawei  duawei  huawei
$ ls [a-dh]u*
auawei  buawei  cuawei  duawei  huashuo  huawei
```

**解释**

1. 第1行，为了方便演示，我新建了四个文件。
1. 第2行，`[ah]uawei`表示，`a`和`h`任选一个，后面紧挨着`uawei`。匹配的字符见第3行显示结果。
1. 第4行，我们可以看出短横线`-`的意思，表示一个序列。也支持数字的连续显示，但是只支持个位数，**是否如此请核实**。
1. 第6行，其实这些元字符可以配合使用。

### 操作符

本节内容见第\@ref(sec:redirect)小节。本节从略。

### 花括号`{}`

第\@ref(filesystem:metachar)小节提到的均为归类，前提是筛选，选择已经存在的事物，对已有的事情分类（**是否如此请核实**）。如果你想创建一个集合，可以选择花括号`{}`的方式，列出所有相关的元素。

```bash
$ touch deepin{1,2,3,4}
$ ls deepin*
deepin1  deepin2  deepin3  deepin4
$ rm ./*
$ touch {deepin,深度}-{5,6,7,8}
$ ls
deepin-5  deepin-6  deepin-7  deepin-8  深度-5  深度-6  深度-7  深度-8
$ rm {deepin,深度}-{5,6,7,8}
$ ls
$ touch {a..e}{1..3}
$ ls
a1  a2  a3  b1  b2  b3  c1  c2  c3  d1  d2  d3  e1  e2  e3
$ rm ./*
$ touch {A..a}
touch: 无法创建'': 没有那个文件或目录
$ ls
'`'   _    ]   A   C   E   G   I   K   M   O   Q   S   U   W   Y
'^'  '['   a   B   D   F   H   J   L   N   P   R   T   V   X   Z
$ rm ./*
$ touch {aa..ac}
$ ls
{aa..ac}
$ rm ./*
$ touch {11..21}
$ ls
11  12  13  14  15  16  17  18  19  20  21
$ rm ./*
$ touch {33..22}
$ touch {z..b}
```

**解释**

1. 第1行，创建了`deepin`开头，以后面集合元素结尾的文件。
1. 第5行，集合拼接在一起，类似于笛卡尔积的形式组合起来。
1. 第10行，对于单字母支持序列功能，多字母则不支持。对于数字支持序列功能。按照ASCII码排序，从`A`到`a`包含不显示的字符，影响最终的显示。
1. 最后两行，没有显示结果，有兴趣的读者可以使用`ls`看看结果。

## 几个常用的目录

- `$HOME` 主目录
- `~` 波浪线，位于键盘左上角第二行开头的那个键（按下的时候需要按`shift`键），也是表示主目录，为了跳转到其他人的主目录，也可用使用`~<username>`的方式。比如跳转到`litianci`的主目录，`cd ~litianci`
- `-` 或者 `$OLDPWD`,表示上一个目录，这个是短横线，不是减号。如果你在两个目录之间切换的话，`cd -`方便你跳转，如果你还没有切换目录，跳转到旧目录则会报错。`-`还有其他的功能，比如放权当前环境切换到新用户，`sudo su -`，这个命令就是不管你现在处于什么目录，切换到`root`根用户，且工作目录为`root`根用户的主目录。
- `.` 或 `$PWD` 当前工作目录。这两者是否有区别，待查。
- `..` 上级目录，也即父目录。对于`/`根目录而言，`..`和`.`都表示本级目录。

## 文件（夹）的权限和归属

Linux 是多用户的系统，为了在一定程度上保护数据隐私，对文件（夹）进行简单的权限控制。这也是你输入命令或者做其他事情的时候会遇到的没有权限问题的根源，甚至部分用户喜欢用`root`根用户操作，也是因为权限控制造成的某些不方便。为了更好的用权，也为了数据的安全，还请能用普通用户的情况下，尽量少用`root`根用户操作。下面对权限进行简要介绍。

对于一个文件（夹）来说，他一定归属于某个用户，且归属于某个用户组。也一定有其他不属于前两者的用户，简称其他用户，有时候也想访问该文件（夹）。那么这个权限就是针对这三类人来设定的。当然，由于某些用户（组）被删除等，造成文件（夹）归属的用户（组）不存在了，这些就是无主文件（夹），这也是存在安全隐患的。在下章内容会讲述通过`find`命令查找此类无主文件（夹）的方法，可以采用相关方法，重新赋予其归属用户（组）或者删除等，这里就不叙述了。

### 权限简介

参考网页：

- https://blog.csdn.net/zhao12795969/article/details/53448039

针对这三类用户，权限又可以分为读（Read）、写（Write）和执行（eXecute）三类。

- r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。
- w(Write,写入)：对文件而言，具有新增,修改,删除文件内容的权限；对目录来说，具有新建，删除，修改，移动目录内文件的权限。
- x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。

**注意**

1. 目录的只读访问不允许使用cd进入目录，必须要有执行的权限才能进入。
1. 只有执行权限只能进入目录，不能看到目录下的内容，要想看到目录下的文件名和目录名，需要可读权限。
1. 一个文件能不能被删除，主要看该文件所在的目录对用户是否具有写权限，如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外。
1. 目录的w位不设置，即使你拥有目录中某文件的w权限也不能写该文件。
1. 以上仅限于 `ext3/4`等文件系统的文件。对于安装`windows10`双系统的电脑，还需要注意是否`windows10`开启电源保护模式，哪怕你是`ext4`格式，依旧为只读，无法更改文件。


每个文件属于一个用户和一个组。命令`ls -l`可以查看用户和组，比如，

```bash
$ ls -l /bin/bash 
-rwxr-xr-x 1 root root 1111240 5月  13  2018 /bin/bash
```

第二行为输出结果，表明 `/bin/bash` 属于 root 用户， root 组。`ls -l` 命令的第一个字段 `-rwxr-xr-x` 包含`/bin/bash`的权限的符号表示。该字段中的首字符（`-`）指定该文件的类型，本例中它是一个常规文件。可能的首字符如下： 

- `-` 普通文件
- `d` 目录
- `l` 符号链接
- `c` 字符专门设备文件
- `b` 块专门设备文件
- `p` 先进先出
- `s` 套接字

首字符后紧接着三个三元组`rwx`，`r-x`，`r-x`，第一个三元字符组代表文件所有者的权限，第二个代表文件的所属组的权限，第三个代表其他用户的权限。但是 root 用户，往往会被跳过这些权限检查（**待核实**）。

### 权限更改`chmod`

`chmod` 用于更改 `rwx` 权限，带有两个或多个参数：`mode`，描述怎样改变权限，后面跟将会受到影响的文件或文件列表：

```bash
$ chmod +x bashscript
```

上例`+x`表示对`bashscript`的三类人员（拥有者、拥有组和其他人）均增加可执行权限。如果我们想要除去一个文件的所有执行权限，

```bash
$ chmod -x bashscript
```

为了更精细的控制权限，比如只修改部分人员权限，需要在`+-`符号前加上这部分人员的代号。`a`表示所有人员，`u`表示拥有者，`g`表示拥有组，`o`表示其他人员。这些代号可以合用。比如下面这行命令表示组和其他人员去除读写权限增加执行权限。

```bash
$ chmod go-rw+x bashscript
```

对于权限，除了`+-`外，还可以使用等号`=`，表示只保留这些权限，未涉及的权限全部取消，有例外，见下文。

```bash
$ chmod =rx bashscript
```

**注意**

使用`+-=`改变权限的时候，最好在前面加上相关人员的代号，比如`a`,`u`，`g`,`o`的组合，否则，可能跟你预期的结果不一样。

```bash
$ chmod a-rwx bashscript
$ chmod +rwx bashscript # + 不一定跟你期望的一样
$ ls -l bashscript # rwxr-xr-x
$ chmod a-rwx bashscript
$ chmod a+rwx bashscript
$ ls -l bashscript # rwxrwxrwx
$ chmod -rwx bashscript # - 不一定跟你期望的一样
$ ls -l bashscript # ----w--w-
$ chmod a-rwx bashscript
$ ls -l bashscript # ---------
$ chmod =rwx bashscript
$ ls -l bashscript # rwxr-xr-x
```

以上是因为存在权限掩码`umask`这个参数，在终端输入`umask`回车，输出本机`umask=0022`,怎么是数字呢？这是因为权限也可用用数字表示，关于权限掩码`umask`在后面详述。

数字形式的权限，使用4位八进制数，每一位代表一个权限三元组。例如，在 `1777` 中，`777` 设置本章我们所讨论的`owner`、`group`和`other`标志。`1` 用来设置专门的权限位，稍后再讲。这个图表说明了怎样解释第二到

： 字符形式权限和数字形式权限对照表

 **字符**    **数字**    **字符**    **数字**    **字符**    **数字**    **字符**    **数字**
----------  ----------  ----------  ----------  ----------  ----------  ----------  ----------
 `rwx`       7    		 `rw-`     	 6 		     `r-x` 	     5     		 `r--`	     4 
 `-wx`     	 3 		     `-w-` 	     2     		 `--x`    	 1 		     `---`	     0

采用数字形式的权限管理方法，比如，

```bash
$ chmod 0755 bashscript
$ ls -l bashscript
-rwxr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript
```

就实现跟字符形式等同的权限设置。

### 权限掩码`umask`

当进程创建了新文件时，它指定新文件应该具有的权限。通常，所请求的模式是 0666（每个人可读和可写），它比我们希望的具有更多的权限。幸运的是，不管什么时候创建了新文件，Linux 将参考叫做权限掩码`umask`的东西。系统用`umask`值来将初始指定的权限降低为更合理、更安全的权限。您可以通过在命令行中输入`umask`来查看您当前的`umask`设置，

```bash
$ umask
0022
```

Linux 系统上，`umask` 的缺省值一般为 `0022`，它允许其他人读您的新文件（如果他们可以得到它们），但是不能进行修改。为了在缺省的情况下使新文件更安全，您可以改变 `umask` 设置，

```bash
$ umask 0077
$ touch newfile # 新建一个文件
$ ls -l newfile
-rw------- 1 litianci litianci 0 11月 21 18:39 newfile
```

`umask` 将确保组和其他用户对于新创建的文件绝对没有任何权限。参阅上方的《字符形式权限和数字形式权限对照表》，当`umask=0077`时，对应字符形式权限为 `---rwxrwx`。而新建文件的请求权限为`0666`（`rw-rw-rw-`），禁用掉`0077`后，就剩上方显示的`rw-------`权限了。


#### `suid` 和 `sgid`

当您最初登录时，将启动一个新的 shell 进程。这个新的 shell 进程（通常是 bash）使用您的用户标识运行，可以访问所有属于您的文件（夹）。您启动的程序继承了您的用户标识，因此它们不能访问任何不允许您访问的文件系统对象。例如，一般用户不能直接修改 */etc/passwd* 文件，因为`write`标志已经对除`root 用户`以外的每个用户关闭，

```bash
$ ls -l /etc/passwd
-rw-r--r-- 1 root root 2438 11月 21 15:54 /etc/passwd
```

但是，一般用户确实需要在他们需要改变其密码的任何时候，能够修改 */etc/passwd*（至少间接地）。但是，如果用户不能修改该文件，究竟怎样完成这个工作呢？

幸好，Linux 权限模型有两个专门的位，叫做`suid`和`sgid`。当设置了一个可执行程序的`suid`这一位时，它将代表可执行文件的所有者运行，而不是代表启动程序的人运行。现在回到上面这个问题。查看 */usr/bin/passwd* 可执行文件，

```bash
$ ls -l /usr/bin/passwd
-rwsr-xr-x 1 root root 59640 9月  28  2017 /usr/bin/passwd
```

您还将注意到，这里有一个 `s` 取替了用户权限三元组中的一个 `x`。这表明，对于这个特殊程序，设置了 `suid` 和可执行位。由于这个原因，当 `/usr/bin/passwd` 运行时，它将代表 root 用户执行（具有完全超级用户访问权），而不是代表运行它的用户运行。又因为 `/usr/bin/passwd` 以 root 用户访问权运行，所以能够修改 */etc/passwd* 文件，而没有什么问题。

我们看到了 `suid` 怎样工作，`sgid` 以同样的方式工作。它允许程序继承程序的组所有权，而不是当前用户的组所有权。

这里有一些关于 `suid` 和 `sgid` 的其它的但是很重要的信息。

首先，`suid` 和 `sgid` 分别占据与 `ls -l` 清单中用户`u`和用户组`g`的执行`x`位。如果设置了 `x` 位为可执行，则相应的位表示为 `s`（小写）否则为 `S`（大写）。

其次，在许多环境中，`suid` 和 `sgid` 很管用，但是不恰当地使用这些位可能使系统的安全遭到破坏。最好尽可能地少用`suid`程序。`/usr/bin/passwd` 命令是为数不多的必须使用`suid`的命令之一。 

设置和除去 `suid` 与 `sgid` 位相当简单。这里，我们设置 suid 位：

```bash
$ ls -l bashscript 
-rwxr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript
$ chmod u+s bashscript 
$ ls -l bashscript 
-rwsr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript
$ chmod u-x bashscript 
$ ls -l bashscript 
-rwSr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript
$ chmod g+s bashscript 
$ ls -l bashscript 
-rwSr-sr-x 1 litianci litianci 119 11月 17 22:32 bashscript
$ chmod g-s bashscript 
$ ls -l bashscript 
-rwSr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript
```

权限和目到此为止，我们从常规文件的角度来看权限。当从目录的角度看权限时，情况有一点不同。目录使用同样的权限标志，但是它们被解释为表示略微不同的含义。 对于一个目录，如果设置了`read`标志，您可以列出目录的内容；`write`表示您可以在目录中创建文件，`execute`表示您可以进入该目录并访问内部的任何子目录。没有`execute`标志，目录内的文件系统对象是不可访问的。没有`read`标志，目录内的文件系统对象是不可查看的，但是只要有人知道磁盘上对象的完整路径，就仍然可以访问目录内的对象。

如果启用了目录的`sgid`标志，在目录内创建的任何文件系统对象将继承目录的组。当您需要创建一个属于同一组的一组人使用的目录树时，这种特殊的功能很管用。只需要这样做，

```bash
$ mkdir -p /media/litianci/data/groupspace
$ sudo chgrp mygroup /media/litianci/data/groupspace
$ chmod g+s /media/litianci/data/groupspace
```

现在，mygroup 组中的所有用户都可以在 */media/litianci/data/groupspace* 内创建文件或目录，同样，他们也将自动地分配到 mygroup 的组所有权。根据用户的 `umask` 设置，新文件系统对象对于 mygroup 组的其他成员来说，可以或不可以是可读、可写或可执行的。

#### 目录和删除

缺省情况下，Linux 目录以一种不是在所有情况下都很理想的方式表现。一般来说，只要对一个目录有写访问权，任何人都可以重命名或删除该目录中的文件。对于个别用户使用的目录，这种行为是很合理的。

但是，对于很多用户使用的目录来说，尤其是 */tmp* 和 */var/tmp*，这种行为可能会产生麻烦。因为任何人都可以写这些目录，任何人都可以删除或重命名任何其他人的文件——即使是不属于他们的！显然，当任何其他用户在任何时候都可以输入`rm -rf /tmp/*`并损坏每个人的文件时，很难在 */tmp* 存放任何有意义的文件。

所幸，Linux 提供了\cqh 粘滞位\cqt （sticky bit）的东西。当给 */tmp* 设置了粘滞位（用`chmod +t`），唯一能够删除或重命名 */tmp* 中文件的是该目录的所有者（通常是 root 用户）、文件的所有者或 root 用户。事实上，所有 Linux 分发包都缺省地启用了 */tmp* 的粘滞位，而您还可以发现粘滞位在其它情况下也很管用。很显然，\cqh 粘滞位\cqt 是属于其他类型人员的权限，跟`suid`,`sgid`一样，占据的也是权限三元组的`x`位，小写是设置了执行权限，大写是禁用了执行权限。所不同的是他们分别占据`u`,`g`，`o`的`x`位。

```bash
$ ls -dl /tmp
drwxrwxrwt 15 root root 4096 11月 22 10:19 /tmp
$ sudo chmod o-x /tmp
$ ls -dl /tmp
drwxrwxrwT 16 root root 4096 11月 22 10:25 /tmp
```

#### 数字形式权限的第一位数字

现在我们回过头来看数字权限的第一位数字的意思，这也是一个八进制数字，`0-7`，转化为三位的二进制数，从高位到低位，分别表示`suid`,`sgid`,`sticky`。当设置该权限时为`1`，禁用该权限时为`0`。比如，`3`就表示，禁用`suid`,启用`sgid`,`sticky`。看下面例子。

```bash
$ chmod 1777 bashscript 
$ ls -l bashscript 
-rwxrwxrwt 1 litianci litianci 119 11月 17 22:32 bashscript
$ chmod 2777 bashscript 
$ ls -l bashscript 
-rwxrwsrwx 1 litianci litianci 119 11月 17 22:32 bashscript
$ chmod 4777 bashscript 
$ ls -l bashscript 
-rwsrwxrwx 1 litianci litianci 119 11月 17 22:32 bashscript
```

### 归属

参考网页：

- https://www.cnblogs.com/DawaTech/p/7249734.html

语法结构如下，

```bash
chgrp 组名 文件（夹） -R
chown 用户名 文件（夹） -R
```

其中`chgrp`表示改变组名；`chown`表示改变用户名；`-R`表示递归目录下所有文件，可略。**更改所属用户和所属组常常需要根用户权限。**

#### 修改文件所属组群`chgrp`

`chgrp`，就是change group的缩写（我们可以利用这些来记忆命令）。看例子，

```bash
[litianci]$ sudo groupadd groupa # 增加组 groupa
[litianci]$ sudo groupadd groupb # 增加组 groupb
[litianci]$ sudo useradd -g groupa deepin -m # 新增用户 deepin，默认组 groupa,自带主目录
[litianci]$ sudo su - deepin # 切换到 deepin 用户，- 表示不保存当前任何环境变量
[deepin]$ touch filea fileb # 创建两个文件
[deepin]$ ls -l
-rw-r--r-- 1 deepin groupa    0 11月 21 15:55 filea
-rw-r--r-- 1 deepin groupa    0 11月 21 15:55 fileb
[deepin]$ exit
[litianci]$ sudo chgrp groupb ~deepin/filea # 改变filea所属群组
[litianci]$ sudo ls -l ~deepin/
-rw-r--r-- 1 deepin groupb    0 11月 21 15:55 filea
-rw-r--r-- 1 deepin groupa    0 11月 21 15:55 fileb
```

由于新增用户权限的问题，后面使用其他用户（`ls -l`）访问文件的属性。执行命令的用户放在每行命令的开头了。

#### 修改文件拥有者`chown`

`chown`，即change owner改变归属用户。`chown`功能很多，不仅仅能更改文件拥有者，还可以修改文件所属组群。如果需要将某一目录下的所有文件都改变其拥有者，可以使用`-R`参数。

语法结构如下，

```bash
chown [-R] 账号名称      文件/目录
chown [-R] 账号名称:组群  文件/目录
```

下面简单示例，

```bash
$ touch demo
$ ls -l demo
-rw-r--r-- 1 litianci litianci 0 11月 21 16:13 demo
$ sudo chown deepin demo # 修改文件 demo 的拥有者为 deepin
$ ls -l demo
-rw-r--r-- 1 deepin litianci 0 11月 21 16:13 demo
$ sudo chown deepin:groupa demo # 修改 demo 的拥有者为 deepin，拥有组 groupa
-rw-r--r-- 1 deepin groupa 0 11月 21 16:13 demo
```

## 文件（夹）的创建、查看、移动、复制和删除

有点类似数据库的增删改查（CRUD,Create,Read,Update,Delete），这里只提到了文件（夹）的创建、查看、移动（包括重命名）、复制和删除。修改涉及到文件的权限以及日期等等内容，这里略过不提。

### 文件（夹）的创建

对于文件夹的创建，常用`mkdir`这个命令。具体方法，前面已经讲解了。对于文件的创建，通常使用`touch`创建文件，通过`man touch`可以看出，一般情况，`touch`只是对访问和更改的时间戳重置为当前时间戳，创建文件只是附带功能。另外一般的编辑器，还有其他文件都有新建保存功能，这样也可用创建文件。这里就不详细介绍了。

### 文件（夹）的查看

对于文件的内容查看，可以通过各种阅读器或者编辑器等，根据文件的类型做出不同选择。因为Unix哲学奉行\cqh 一切皆文件\cqt ，编辑器是一种比较常见的查看方式，这个见第\@ref(chap:vim-find)章。

文件（夹）的查看，通常采用**深度文件管理器**。对于其属性，可以通过**深度文件管理器**右击找到属性来查看。当然在命令行下`ls`也是一个非常强大的存在。看下面的例子。

```bash
$ ls
$ ls -la
$ ls -lR
```

**解释**

1. `ls`的选项`-a`表示把当前包含隐藏文件（夹）在内的所有文件（夹）显示出来。
1. `-R`选项是递归显示，可以把各个子文件夹的内容也显示出来。`-l`的显示内容，见上面章节说明。更多内容，可以查看`man ls`。
### 文件（夹）的移动及重命名

文件（夹）的移动和重命名是通过`mv`命令实现的。

```bash
$ mv litianci deepin
$ mv deepin ~
$ mv test1 test2 test3 ~
$ mv ~/deepin-bible/ ~/test/
$ mv ~/Desktop/* ~/test/
```

**解释**

1. 第1行，对文件`litianci`重命名为 `deepin`。`mv`重命名时，不区分文件夹或文件。
1. 第2行，把文件 `deepin`移动到`~`文件夹。
1. 第3行，`mv`支持多个文件同时移动到最后面一个文件夹。请注意，**当多个文件（夹）同时移动时，最后一个必须是文件夹或指向文件夹的链接**。
1. 第4行，把文件夹`deepin-bible`文件夹，包括文件夹的内容（含隐藏内容），移动到`~/test/`文件夹。
1. 第5行，只是把文件夹`Desktop`内的非隐藏内容，移动到`~/test/`文件夹。

注意，默认的`mv`，对于重名冲突是直接覆盖的。如果想不被覆盖，建议在`~/.bashrc`内加上`alias mv='mv -i'`，遇到这类的问题的时候，就会征询你的意见再决定要不要覆盖。

### 文件（夹）的复制

```bash
$ cp litianci deepin
$ cp deepin ~
$ cp test1 test2 test3 ~
$ cp -r ~/deepin-bible/ ~/test/
$ cp -ra ~/Desktop/* ~/test/
```

**解释**

1. 第1-3行，类似`mv`命令，实现对文件的复制，不含文件夹的复制。
1. 第4行，对于文件夹的复制，需要带`-r`选项，递归（`recursive`）的意思。
1. 第5行，复制`-a`选项，表示复制后的文件（夹）各时间戳和权限跟原文件（夹）一样。

### 文件（夹）的删除

```bash
$ rm deepin
$ rm ./-
$ rm *
$ rmdir /home/joe/nothing/
$ rm -r /home/joe/bigdir/
$ rm -rf /home/joe/hugedir/
$ sudo rm -rf / #千万不要试运行
```

**解释**

1. 第1行，普通文件可以直接删除。不支持文件夹直接删除。如果要删除文件夹见第4-6行。
1. 第2行，对于特殊文件，比如`-`，一般写绝对路径。
1. 第3行，`*`一般代表的都是非隐藏文件（夹）。没有`-r`递归选项，也可用删除当前文件夹下的所有非隐藏内容。
1. 第4行，删除文件夹的命令`rmdir`，删除了`nothing`文件夹及其内容。
1. 第5-6行，`-r`表示递归，可以使用`rm`删除文件夹。`-f`是强制删除，实际是不用询问直接删除，对于没有权限删除的，依旧无法删除。
1. 第7行，千万不要试运行。但是有时候为了删除本文件夹下的内容，往往错输。

我的建议是`alias rm='trash-put'`，把删除改为放置到回收站。具体做法见附录\@ref(chap:faqs)。

## 总结

本章介绍了Linux操作系统的文件结构，并对文件的权限和归属情况进行了介绍，最后对文件的改动复制等作了简要介绍。
