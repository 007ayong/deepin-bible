[
["section-1.html", "深度易经 1 前言", " 深度易经 深度操作系统爱好者 2019年02月10日 1 前言 为什么要写这本书呢？起源于去武汉参观辛亥革命博物馆。深深的被孙中山的“敢为天下先”所感动。另外也要感谢深度科技公司的 jingle 提供的帮助和支持，内心总是感觉深度科技就是敢为天下先的代表，俺也不能自甘落后，于是下决心写本书。 另外感谢深度公司还给资助了二百来块钱，太感谢啦，写在这里的稿费。还有很多默默支持的小伙伴，在此一并表示感谢。 另外还要说一个中国早就存在的二大爷精神。虽然60多年过去了，你二大爷还是你二大爷。它代表了一种个性要强不怕输敢于拼搏的精神。也用于纪念我逝去的二大爷。写这本书，也表达对他的敬意和怀念。 本书的封面，是我的好友王一凡帮助设计的，特别表示感谢。相信大家一看到这两个动物就会明白所代表的啥意思。不再过多解释。 本书结构如下。 打算模仿《Linux Bible》，采取深入浅出的方式，先介绍一些简单的使用方法，然后后面进行深入。 第一部分 Linux 及 Deepin 入门常识 第二部分 用户相关 第三部分 第四部分 第五部分 附录及其他 本书模板制作说明 常见问题 其中，第一部分主要介绍 Linux 及 Deepin 的哲学以及相关的知识。 第二部分，第三部分， 文件名采用如下方式， xxx-name.Rmd。其中 xxx 表示从 000 到 999，第一位表示第几部分，后两位如果为 00 表示该部分的简介，如果是其他数字则表示章节。name 是对应章节的名字。一章一个文件。 本书的代码规范。 文件和目录用斜体表示，也就是用 * 括起来。 "],
["section-2.html", "2 致谢", " 2 致谢 首先感谢 bookdown 的开发者，谢益辉和他的小伙伴们，提供了这么好的一个做笔记的模板。另外，本书籍模板获得第一届bookdown大奖赛的三等奖，可作为一些技术资料的书籍制作模板。 当然也要感谢《Linux Bible》的作者，以及为 Linux 做出贡献的那些人。 也有深度科技公司，谢谢他们给提供了这么好的一个操作系统。 也要谢谢各位支持我的好友、网友和亲人。给了我很大的动力，让我开启这个活动。能不能坚持下去，相信自己。 当然最主要的是家人的支持。前些日子，深度副总王勇辞职，提到自己深夜加班，家人来公司找的事情，深有同感。写点文字还是很费时间的，在休息时间不能很好的陪陪家人，很容易带来家庭矛盾，而且很需要家人来理解，做好家人的工作。如果写的不好，对别人不说愧疚不愧疚，至少对家人是一种很大的不负责任。 如果您也想感谢这份模板的话，可以捐款支持本人工作。有钱的捧个钱场，没钱的扫扫红包，也算帮忙。谢谢。 捐款名录 捐款人 金额 日期 备注 捐款人 金额 日期 备注 *小定 6.66 20181007 *小定 6.66 20181007 "],
["author.html", "3 作者简介", " 3 作者简介 这将是一群深度操作系统爱好者的杰作！！！ 我一直致力于寻找合作者，但是我感觉现在有点迷茫。这边进度实在是慢，常常一个月写不了多少内容，可能一个月就几百字，都写不到一页内容。经常停下来。我只是想告诉别人，这个事业还在继续中。我却找不到一点点进步的身影。 现在（2017-10-29）写作进行的很困难，主要是零碎的时间很难用于整理大篇大篇的文字。还有其他繁重的任务要做，似乎不太容易写。我觉得可以分析一下困难，研究一下对策。不要再让这本书半途而废了。现在遇到的问题，负责带教，挤占了较多的时间，一时半会，他们也帮不上忙。还有两个网站的内容在整理，不可荒废。包括驾校也要报名。结婚的事情，还有一大堆。也就是有这么几件事，婚前准备，两个网站的维护，驾校考试，带教学习，完成本书第一版草稿，基本就是这么个优先级顺序，当然时刻伴随着要上班这个无法逃脱的事情。鉴于此，我认为接下来可以这样安排。婚前准备虽然优先级高，但是实际占场时间不多，如果可以快速下决定，花不了太长时间的。两个网站的维护，基本上要浪费掉很多晚上的时间。可以每天抽出两个小时的时间，弄一弄。驾校的事情，周末可以去试试，也可以在工作间隙去练练。带教学习，也是很耗费时间的，每次可能要一到两个小时，一周也就两到三次。可以跟网站维护交叉进行。完成本书第一版草稿，更是要耗费几年时间的任务。另外带教学习的就是本书，可以充分利用这个带教的事情，毕竟有徒弟可以帮着写写画画的。制定这么一个时间表，有时间里面把婚前准备的事情给结束掉，避免多次设想，带来的巨大时间浪费。每周抽出两到三天晚上带教，可以做好任务安排，每完成一章课程，作业就是帮我整理本草稿。剩下的两到三天去编写网站代码，做好维护，且不再增加新的网站或者其他任务了。驾校的事情，暂且缓一缓，找个时间去把科目一考了。 终于领结婚证了（2017-11-03），我现在觉得写作特别耗费时间，需要庙算一下，好好规划一下，要写哪些内容。 github 的一些功能是非常值得充分利用的，比如 issue，这样可以充分利用零碎时间。半夜我坐在一个孤独的房间，又不看书，怎么可能写好这个笔记。必须边学习边做笔记，也就是写到 issue 上。不要手机整天微信、支付宝了。 （2018-12-04）工作尚可。妻子怀孕，也不能多陪伴，心有内疚。感觉很多事情一团糟，停下来，重整行装再出发。期待明天更美好吧。(2019-01-06)儿子出生，忙着带孩子，期间很忙，告诉自己，一定要坚持下来。 当前贡献者：黄煌、贺鹏飞、董春柏、邱鹏飞、高洪亮，还有参考网页的一些好友，抱歉没来得及写在这里，以后慢慢添加，在此表示感谢。 "],
["chap-linux-intro.html", "4 GNU/Linux 操作系统简介 4.1 GNU/Linux 使用范围 4.2 GNU/Linux 是什么 4.3 Unix 哲学 4.4 GNU/Linux 发行版的出现 4.5 如何提高自己的 Linux 技术 4.6 总结", " 4 GNU/Linux 操作系统简介 通过阅读本章，你将会了解到以下几项内容。 GNU/Linux 使用范围。 GNU/Linux 发展简史以及 GPL 协议。 Unix 哲学简介 如何学习 GNU/Linux。 4.1 GNU/Linux 使用范围 有人说， GNU/Linux 作为服务器操作系统，在市场上占有绝对优势，在超级计算机前 500 名中更是占有垄断地位。好吧，这些都不是我们关心的事情。我们关心的是 GNU/Linux 好用不，适合我不。 如果你是程序员。你可以用它方便的写代码，并很容易调试。有功能异常强大的终端，供你跟整个世界沟通。方便你写文档，比如石墨文档等软件。对于公司办公需要的内部邮件系统，以及内部聊天系统，可能不是很好用，但都有相关的替代软件，比如雷鸟邮件、飞鸽等。 如果你是办公室文员。那办公呢，搜狗拼音输入法，赫然在列，金山的 WPS 办公套件也是能满足你基本需求的。那 QQ 呢，这个也是必须有的，能不能告诉你，在深度 Linux 已经实现视频聊天了呢。当然还有很多特殊的办公软件在 GNU/Linux 下没有可用的版本。比如 photo shop， autoCAD 等。根据具体情况来采纳吧。 如果你只是在家里使用。比如趣味性，听听音乐，看看电影，这些都是可以办得到的。那打游戏呢？很不幸的告诉你，Linux 操作系统下能玩的游戏真心不多，但是各位游戏大佬也在逐步把部分游戏移植到 GNU/Linux 系统下，比如 steam 下的很多游戏开始支持 GNU/Linux 系统了。 如果你是求职者。当然为了更好的找工作，提高技术能力，期待更好的薪水，技多不压身，不妨来学学 GNU/Linux，甚至可以考考某些证书，绝对技多不压身。 另外 GNU/Linux 桌面操作系统，稳定性不是很高，但也没有 Windows 下全家桶系列乱弹窗的软件。如果你对桌面清洁有特殊爱好，且 GNU/Linux 能满足你日常工作生活需要，不妨来试试它吧。 4.2 GNU/Linux 是什么 什么？其实他就是一个电脑操作系统啦。那操作系统是啥，那我也不知道啦，这个你可以百度一下，简单的说就是方便你操作电脑的一个软件系统。关于 Linux 有啥发展历史，以及跟 GPL 协议有啥关系。这些网上都有铺天盖地的介绍，本书就不介绍啦。不过还是要介绍两个人，一位是 GNU 的老大Richard Stallman，一位是 Linux 的老大 Linus。 4.2.1 Richard Stallman 本节摘自百度百科，有改动。 个人经历 理查德·马修·斯托曼（Richard Matthew Stallman, RMS）1953年出生于美国纽约曼哈顿地区，1971年进入哈佛大学学习，同年受聘于麻省理工学院人工智能实验室（AI Laboratory），成为一名职业黑客。 在AI实验室工作期间，斯托曼开发了多种今后影响深远的软件，其中最著名的就是Emacs。斯托曼在AI是一名典型的黑客，是整个黑客文化的一份子。 然而进入八十年代后，黑客社群在软件工业商业化的强大压力下日渐土崩瓦解，甚至连AI实验室的许多黑客也组成了Symbolic公司，试图以专利软件来取代实验室中黑客文化的产物－－免费可自由流通的软件。 斯托曼对此感到气愤与无奈。在对Symbolic进行了一段时间的抗争后，他于1985年发表了著名的GNU宣言(GNU Manifesto)，正式宣布要开始进行一项宏伟的计划：创造一套完全自由免费，兼容于Unix的操作系统GNU（GNU’s Not Unix!）。之后他又建立了自由软件基金会来协助该计划。 他于1989年与一群律师起草了广为使用的GNU通用公共协议证书（GNU General Public License, GNU GPL），创造性地提出了反版权（或版权属左，或开权，copyleft）的概念。 同时，GNU计划中除了最关键的Hurd操作系统内核之外，其他绝大多数软件已经完成。 1991年芬兰大学生Linus Torvalds在GPL条例下发布他自己创作的Linux操作系统内核，至此GNU计划正式完成，操作系统被命名为GNU/Linux（或简称Linux）。 斯托曼是一名坚定的自由软件运动倡导者与其他提倡开放源代码的人不同，斯托曼并不是从软件质量的角度而是从道德的角度来看待自由软件。他认为使用专利软件是非常不道德的事，只有附带了源代码的程序才是符合其道德标准的。对此许多人表示异议，并也因此有了自由软件运动与开源软件运动之分。 GNU 斯托曼做了一个与Unix兼容的操作系统。这样容易被移植，而且Unix用户可以方便地转移过来。这个系统的名字就叫GNU，这个名字的确定就是遵循黑客传统，是一个递归的缩略词:GNU IS NOT UNIX。 但一个操作系统并不仅仅意味着一个内核（管理磁盘，内存分配等），而且仅能运行其他程序也是不够的。一个完整的操作系统，还需要有指令处理器、汇编程序、编译器、解释程序、调试器、文本编辑器、邮件软件等等，这样才能形成一个完整的系统。斯托曼决定尽可能采用已有的自由软件，比如一开始他将Tex作为主要的文本格式标识符，几年后他又用X Window系统作为GNU的窗口系统。 1984年1月，斯托曼已启动了GNU计划，他担心MIT会要求产品的所有权，会给产品强加入他们的销售条件，最终又会成为专有软件，因而他辞去了MIT工作。辞职后，他为买不起电脑而发愁时，发现自己原来在人工智能实验室的办公室，还没有分给其他人用时，他就每天晚上溜进去工作。 GNU工程启动后，斯托曼听说有一个自由大学编译器套件（VUCK）。他去询问能否用入GNU。答复是嘲弄式的，说对大学是自由的，但对软件本身不行。于是，他决定为GNU编写的第一个软件就是一个多语言、多平台的编译器。他想利用Pastel编译器的源代码，但最终放弃。他从头编写了新的编译器，名为GCC(the GNU Compiler Collection)。 1984年9月，斯托曼开始开发字处理器GNU Emacs，1985年初，它开始可以工作。这使它可以在Unix系统上进行文本编辑。此时，许多人想使用Emacs，因此一个现实的问题是:如何传播它？ 当然，他将其放到了MIT计算机的匿名服务器上。但那时互联网还未普及，人们很难通过FTP获得拷贝，而且失业的斯托曼也需要收入。于是，他宣布任何人都可以用150美元的价格获得全部程序。当然，所支付的费用是远低于当时的专有软件的价格的，并且用户可以得到软件的源代码。这样，自由软件的分销商业模式就此诞生。如今，整个基于Linux的GNU系统都是如此。 4.2.2 Linus Torvalds 本节摘自百度百科，有改动。 个人经历 林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds），1969年12月28日出生于芬兰赫尔辛基市。父亲尼尔斯·托瓦兹（Nils Torvalds）是一名活跃的共产主义者及电台记者，曾当选芬兰共产党中央委员会委员。托瓦兹家族属于在芬兰占6%的少数民族芬兰瑞典人。他毕业于赫尔辛基大学计算机系，1997年至2003年在美国加州硅谷任职于全美达公司（Transmeta Corporation），现受聘于开放源代码开发实验（OSDL：Open Source Development Labs, Inc），全力开发Linux内核。与妻子托芙（Tove，芬兰前女子空手道冠军）育有三个女孩。 与很多其他黑客不同，托瓦兹行事低调，一般很少评论商业竞争对手（例如微软）产品的好坏，但坚持开放源代码信念，并对微软等对手的FUD战略大为不满。 例如，在一封回应微软资深副总裁Craig Mundie有关开放源代码运动的评论（Mundie批评开放源代码运动破坏了知识产权）的电子邮件中，托瓦兹写道：我不知道Mundie是否听说过艾萨克·牛顿（Isaac Newton）爵士？他不仅因为创立了经典物理学（以及他和苹果的故事）而出名，也还因为说过这样一句话而闻名于世：我之所以能够看得更远，是因为我站在巨人肩膀上的缘故。托瓦兹又说道：我宁愿听牛顿的也不愿听Mundie的。他（牛顿）虽然死了快300年了，却也没有让房间这样得臭气熏天。 现年49岁的林纳斯目前受聘于开放源代码开发实验室（OSDL，Open Source Development Labs），全身心的开发Linux内核。尽管这位年轻人看上去毫不起眼，比如林纳斯曾在他的自传《乐者为王》（Just for Fun）中自嘲：我是一个长相丑陋的孩子，凡是见过我小时候照片的人，都会觉得我的相貌酷似河狸。再想象一下我不修边幅的衣着，以及一个托瓦兹家族祖祖辈辈遗传下来的大鼻子，这样，在你脑海中我的模样就形成了。但这丝毫也影响不了林纳斯对整个商业社会的巨大价值—Linux代表着网络时代新形式的开放知识产权形态，这将从根基上颠覆以Windows为代表的封闭式软件产权的传统商业模式。更重要的是，这样的颠覆早已悄悄的出现在了商业社会的各个角落。 Linux 颠覆世界的自由主义教皇林纳斯。 有些人生来就具有统率百万人的领袖风范；另一些人则是为写出颠覆世界的软件而生。唯一一个能同时做到这两者的人，就是托瓦兹。美国《时代》周刊对Linux之父林纳斯·托瓦兹（Linus Torvalds）给出了极高的评价。甚至，在《时代》周刊根据读者投票评选出的二十世纪100位最重要人物中，林纳斯居然排到了第15位，而从20世纪的最后几年就开始霸占全球首富称号的盖茨不过才是第17位。 林纳斯的出名和重要来得并没什么先兆，尽管这个1969年出生在芬兰赫尔辛基的天才在年少时就已经颇具黑客神韵—对于电脑的着迷使他很早就能够驱使电脑做事情，对一切细节也都能控制自如。但当林纳斯在1991年就读于赫尔辛基大学期间刚刚开始对Unix产生浓厚兴趣，尝试着在Minix（Unix的变种）上做一些开发工作的时候，他从来也没想过会构建出一个新操作系统的内核来。 Linux的诞生显得充满了偶然。林纳斯经常要用他的终端仿真器（Terminal Emulator）去访问大学主机上的新闻组和邮件，为了方便读写和下载文件，他自己编写了磁盘驱动程序和文件系统，这些在后来成为了Linux第一个内核的雏形。当时，他年仅21岁。 在自由软件之父理查德·斯托曼（Richard Stallman）某些精神的感召下，林纳斯很快以Linux的名字把这款类Unix的操作系统加入到了自由软件基金（FSF）的GNU计划中，并通过GPL的通用性授权，允许用户销售、拷贝并且改动程序，但你必须将同样的自由传递下去，而且必须免费公开你修改后的代码。这说明，Linux并不是被刻意创造的，它完全是日积月累的结果，是经验、创意和一小段一小段代码的集合体。 无疑，正是林纳斯的这一举措带给了Linux和他自己巨大的成功和极高的声誉。短短几年间，在Linux身边已经聚集了成千上万的狂热分子，大家不计得失的为Linux增补、修改，并随之将开源运动的自由主义精神传扬下去，人们几乎像看待神明一样对林纳斯顶礼膜拜。 然而，在1996年底，林纳斯突然离开赫尔辛基，只身奔赴美国硅谷，成为Transmeta公司的一员，直到2003年才离开。其中的原因曾经扑朔迷离，但现在看来，那只不过是林纳斯对于自身价值的一种现实性追求。虽然当时许多人都怀疑这会给发展中的Linux造成致命伤害，不过Linux在随后几年内的发展证明，这样的担心是多余的。 林纳斯说，Linux所取得的许多成功其实可以归结为他的缺点所致。我很懒散，我喜欢授权给其他人。就连Linux的企鹅形象标识也是林纳斯的妻子，曾获芬兰空手道冠军的托芙（Tove）想到的，因为林纳斯曾经在澳大利亚被一只企鹅咬过。黑客们，不，程序员们，把在Linux和其它开放源代码项目上的工作，放在比睡觉、锻炼身体、娱乐和聚会更优先的地位。因为他们乐于成为一个全球协作努力活动的一部分—Linux是世界上最大的协作项目。 4.3 Unix 哲学 参考： http://s3.eurecom.fr/~balzarot/softdev/material/0_2_unix_philosophy.pdf 因为 Linux 是类 Unix 操作系统，这里摘抄一些 Unix 哲学相关的内容，方便大家对 Linux 有个浅显的认识。 4.3.1 Unix 哲学核心 英语原文， This is the UNIX philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface. — Doug McIlroy 汉语译文， 这是UNIX哲学： 程序，应当只做一件事，且要做好。 程序，应当能够协作。 程序，应当能够处理文本流，因为文本流是通用接口。 — Doug McIlroy 我觉得这种哲学思想都快适合做其他事情了，分而治之，统筹协调，打好基础。对于打算从事 Unix 编程的，还可以继续深入学习，这里就不多介绍了。 4.3.2 Unix 哲学下的用户 Unix 相信用户，并赋予其极多选择极大权力，但也要求用户必须花足够多的时间来学习。 但是，只要是个人，就会犯错误的，这种 Unix 绝对信任也有极大的危害。网上仅仅 rm -rf ./ 误删就害死了不少人。而且要花费非常多的时间来学习一门操作系统，也是一个极大的弊端。正是这种种缺陷，催生了各种发行版，后面4.4节再说。 4.3.3 Unix 哲学的对手 以当前桌面领域普及最广的 Windows 系统为对照，看看 Windows 和 Unix 的区别。 Unix 是以科学家和程序员为用户群体的，但是类 Unix 的 Linux 的用户群体也开始包含普通吃瓜群众了。而 Windows 是以所有人，当然包括那些普通群众，而且最主要的就是普通群众，为用户群体的。基于不同的目标用户，Unix 要提供各种可能性，让目标用户，来玩坏自己，实现各种功能，尽情的发挥自己的聪明才智，相当于给用户提供了大量积木块；Windows 则要提供傻瓜式服务，防备着你玩坏了，对你各种猜测，引导你去完成特定的任务，以免犯错，相当于给用户提供了一个个成品玩具。用参考文章的一句话来说Unix 的使用依赖用户的聪明才智，Windows 则隐藏这些技巧于操作系统和软件内部。 下面来分析一下，这两者的优缺点。 Windows 的优点，降低用户的学习时间成本；缺点，倡导傻瓜式用户，限制用户的灵活发挥。 Unix 的优点，提供更多的可能性；缺点，增大用户的学习时间成本。 当然，随着 GNU/Linux 发行版的活跃发布，Unix 哲学的一些缺点也在被慢慢修正。也许，未来的 GNU/Linux 发行版既能提供易操作的成品玩具，也附带大量灵活的积木零件，综合两者的优势，更方便也更灵活更高效。 4.4 GNU/Linux 发行版的出现 如果完全从 Unix 哲学起步，用源代码一步步编译为可用软件，对广大普通用户来说就太难了，GNU/Linux 也将举步维艰。以 Linux 为内核，外加 GNU 的一些软件和服务，添上图形界面等，满足用户的基本需求，这样发行版的出现，能够很好的解决上述难题，也就流行开来了。GNU/Linux 发行版的出现，也是对 Unix 哲学的一种实践补充。所以各发行版的目标和口号和 Unix 哲学还是有一定的区别，比如深度公司的口号免除新手痛苦、节约老手时间，就不会说，单一高效。 发行版的历史就不说了，当前常见的发行版有这两大类，Red Hat 系列和 Debian 系列，当然还有 slackware 以及其他有特殊目的的发行版等等，这里略过他们。 4.4.1 Red Hat 系 Red Hat 系列发行版是一个非常流行的 GNU/Linux 发行版，属于 Red Hat 公司，代码开源，通过售卖服务以及培训等收费，起步非常早。采用非常好用的 rpm 软件包管理器，系统非常稳定，安装简单，有图形化操作界面。该公司对近期比较热门的领域，比如云计算等也有涉猎。旗下主要有企业稳定版的 Red Hat Enterprise Linux 和功能实验版 Fedora 两类操作系统。另外有社区企业版 centos 发行版是完全复制 Red Hat Enterprise Linux 源码，并剔除 Red Hat 公司标志后编译成的发行版，稳定可靠，也值得了解一下。 4.4.2 Debian 系 Debian 也是一个早期的 GNU/Linux 发行版，有非常好用的软件包管理器，软件包为 deb 格式，系统稳定性非常高。有众多的发行版基于或者追根溯源到 Debian，比如本书介绍的对象 Deepin 深度操作系统，以及比较著名的 Ubuntu，国际排名非常靠前的 Linux Mint，网络安全必备的 Kali Linux，老旧电脑挚爱的 Lubuntu 等发行版。本书介绍的很多技术均适用于 Debian 系列的发行版。 4.5 如何提高自己的 Linux 技术 参考网页： https://www.tecmint.com/free-online-linux-learning-guide-for-beginners/ https://www.cnblogs.com/evilqliang/p/6247496.html https://blog.csdn.net/erlian1992/article/details/54586156 最好的办法就是直接上手！古人云临渊羡鱼，不如退而结网。下载一个 Linux 发行版，安装在自己的电脑上，平常多用，偶尔折腾一下，就差不多了。 4.5.1 首先安装 GNU/Linux 操作系统 当然这里肯定首先推荐 Deepin 深度操作系统，比较符合中国人的操作习惯。另外也可选择 Ubuntu 的一些分支版本，其中优麒麟就是做得比较好的一个发行版。 如果电脑配置不够高，或者比较老旧，也可用选择轻量版的 Lubuntu。电脑配置比较高的，也可用试着在虚拟机，比如 VirtualBox 虚拟机内安装上述这些操作系统。 4.5.2 平常多用 GNU/Linux 的部分发行版在某些情况下，已经能够满足我们的日常工作生活需要。在平常使用不需要太折腾的前提下，我们完全可以多用、经常用。 欧阳修《卖油翁》提到无他，惟手熟尔。Linux 技术也是学而时习之，不亦说乎的事情，用多了，自然知道咋回事啦。就像熟读唐诗三百首，不会作诗也会诌。使用熟练后，我们就会发现 Linux 也是可以提高办公效率的好工具。 4.5.3 多问多记 很喜欢毛泽东的读书方法不动笔墨不看书，遇到问题及时去查资料，然后记录下来，很有助于技术水平的提高。笔者曾在某公司实习，不得已整天跟 vim 打交道，刚入门也是效率低下，后来在身边好友帮助下以及网上搜索资料，慢慢写博客，也开始有点爱上 vim 了，半年下来，vim 码字母也能贼溜了。学习就是一个慢慢积累的过程，谁也不能一口吃成大胖子。曾经有一位日本人说赵先生，中国有五千年历史呢，咱们不急，慢慢来。慢慢来不等于不来，我们需要时刻督促自己不停的学习，活到老学到老。 4.5.4 定个计划 当你有一定认识后，你就会自觉不自觉的制定计划了，也会掌握更多的学习方法，这里我就不废话了。上面参考网页都是一些不错的经验介绍，希望对您有所帮助。 4.6 总结 本文首先根据用户角色，介绍了 GNU/Linux 操作系统的用途范围。通过介绍斯托曼和林纳斯两人的经历，附带讲解了 GNU 和 Linux 的发展历史，以及 GPL 协议的一些内容。接着介绍了 Unix 哲学相关的内容，最后对如何学习 GNU/Linux 提出了一些个人观点。 "],
["chap-linux-desktop-intro.html", "5 Linux 桌面系统简介 5.1 运行 Live CD/DVD 试用系统 5.2 X Window 系统简介 5.3 王勇谈 Wayland 5.4 常见的桌面环境 5.5 总结", " 5 Linux 桌面系统简介 通过阅读本章，你将会了解到以下几项内容。 从 Live CD/DVD 运行系统 X Window 系统 新秀 Wayland 的评价 常见的桌面环境（Desktop Environments）简介 随着技术的发展，电脑桌面操作系统也在不断的完善，虽然不能说是夕阳产业，但也在趋向一个完美的天花板。个人认为很多在 windows 和苹果桌面操作系统下的软件和操作体验，在 Linux 桌面这边一定会慢慢实现并赶上来的。未来软件会趋同，会跨平台。目前为止， Linux 桌面系统下已经有足够多的软件满足一般的日常生活需求了。 5.1 运行 Live CD/DVD 试用系统 本文一直强调能动手的就不要光动口，意思就是最好安装 GNU/Linux 操作系统。如果您不喜欢安装，也可用在不安装的前提下试用该系统。下面介绍如何试用系统。当然下载安装镜像还是不可避免的。 5.1.1 下载深度系统 下载深度操作系统系统最新版本的镜像文件（以便您能够体验到最新特性），下载地址：https://www.deepin.org/download/ 如图??所示， 如果您只是想试用系统，可以选择下载Live 系统。 注意：为了更加专注系统的发展，deepin 15.4版本将不再提供32位官方iso镜像，如需获取和技术支持，请发送邮件到 support@deepin.org。 5.1.2 把系统写到U盘里 安装说明： https://www.deepin.org/installation/ 现在流行 U 盘安装，当然也可用光盘安装。下面只介绍 U 盘启动器的制作，到这里下载系统启动盘制作工具。 根据自己操作系统情况请选择对应版本。另外也可用选择其他的制作软件，比如 Ultraiso 软件，网上搜索使用UltraISO（软碟通）制作U盘启动盘完整教程，可以找到相当多的资料，这里从略。 5.1.3 开始试用 试用版有一些功能受限，但是可以感受一下。不过还是强烈建议安装正常版本的软件。 参考： https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=157091 http://wiki.deepin.org/wiki/%E4%BD%93%E9%AA%8C%E5%AE%89%E8%A3%85 5.2 X Window 系统简介 当前主要的linux桌面发行版基本都是采用X Window 系统来提供桌面服务。 X Window是一种以位图方式显示的软件窗口系统，最初是1984年麻省理工学院的研究成果，之后变成UNIX、类UNIX、以及OpenVMS等操作系统所一致适用的标准化软件工具包及显示架构的运作协议。 X Window通过软件工具及架构协议来建立操作系统所用的图形用户界面，此后则逐渐扩展适用到各形各色的其他操作系统上，几乎所有的操作系统都能支持与使用X Window，GNOME和KDE也都是以X Window为基础建构成的。 X Window向用户提供基本的窗口功能支持，而显示窗口的内容、模式等可由用户自行定制，在用户定制与管理X Window系统时，需要使用窗口管理程序，窗口管理程序包括AfterStep、Enlightenment、Fvwm、MWM和TWM Window Maker等，供习惯不同的用户选用。 可以定制的窗口环境在给用户带来了个性化与灵活性的同时，要求用户有相对比较高的使用水平，不过这种机制带来的好处也是明显的，它不象Microsoft Window那样将窗口元件的风格、桌面、操作方式等千篇一律地规定死，只可以换一下墙纸、图标、调整字体大小等等，在X Window系统中可以有多种桌面环境的选择。 5.2.1 基本部件 X系统由三个相关的部分组成：服务端（Server）、客户端（Client）和通讯通道 (communication channel）。 服务端（Server） Server是控制显示器和输入设备（键盘和鼠标）的软件。Server可以创建视窗，在视窗中绘图和文字，回应Client程序的需求（requests），但它不会自己完成，只有在Client程序提出需求后才完成动作。 每一套显示设备只对应惟一的Server，而Server一般由系统供应商提供，通常无法被用户修改。对操作系统而言，Server只是一个普通的用户程序而已，因此很容易更换新版本，甚至更换成第三方提供的原始程序。 客户端（Client） Client是使用系统视窗功能的一些应用程序。在X下的应用程序称做Client，原因是它是Server的客户，要求Server回应它的请求完成特定动作。 Client无法直接影响视窗行为或显示效果，它们只能送一个请求（request）给Server，由Server来完成这些的请求。典型的请求通常是在某个视窗中写‘Hello World’的字符串，或者从A到B划一条直线。 Client的功能大致可分为两部分：向Server发出需求只是它的一部分功能，其他的功能是为用户执行程序而准备的。例如输入文字信息、作图、计算等等。通常，Client程序的这一部分是和X独立的，它对于X几乎不需要知道什么。通常，应用程序（特别是只大型的标准绘图软件、统计软件等）对许多输出设备具有输出的能力，而在X视窗中的显示只是Client程序许多输出中的一种，所以，Client程序中和X相关的部分只占整个程序中很小的一部分。 用户可以通过不同的途径使用Client程序：通过系统提供的程序使用；通过第三方的软件使用；或者用户为了某种特殊应用而自己编写的Client程序来使用。 通讯通道 (Communication channel） Client藉著它送 “需求” 给Server，而Server藉著它回送状态 (status) 及一些其它的资讯 (information)。 只要 Client 和 Server 都知道如何使用通道，通道的本身并不是很重要，在系统或网路上支援通讯型态的需求是内建於系统基本的X视窗函数馆(library)，所有和通讯型态有关的事都从函数馆独立出来，Client和Server之间的通讯只要藉著使用这函数馆（在标准X版为xlib）。 Server和Client之间的通信 Server和Client通信的方式大致有两类，对应于X系统的两种基本操作模式。 第一类，Server和Client在同一台机器上执行，它们可以共同使用机器上任何可用的通信方式做互动式信息处理。在这种模式下，X可以同其他传统的视窗系统一样高效工作。 第二类，Client在一台机器上运行，而显示器和Server则在另一台机器上运行。因此两者的信息交换就必须通过彼此都遵守的网络协议进行，最常用的协议为TCP/IP。这种通信方式一般被称为网络透明性，这也几乎是X独一无二的特性。 5.2.2 用户接口 X的设计目标之一就是能创建许多不同形式的用户接口。其他的是视窗系统提供具体的交互方式，而X只提供一般的架构，让系统创建者建造所需的交互风格。这种特性使得开发者可以在X的基础上建造全新的接口，并且可以在任何时刻根据自己的需要选用适当的接口。 一般来说，用户接口可以分为两部分。管理接口也就是视窗管理器，是命令的最高层，它负责在屏幕上创建或重建视窗，改变视窗的大小、位置，或者将视窗改变成图示等。 应用接口确定了用户和应用程序之间的交互风格，即用户如何利用视窗系统的设备程序来控制应用程序并传递输入行为。例如，如何用鼠标来选定一个选项。 5.2.3 用户界面 X刻意不去规范应用程序在用户界面上的具体细节设计，这些包括按钮、菜单和窗口的标题栏等等，这些都由窗口管理器（window manager）、GUI构件工具包、桌面环境（desktop environment）或者应用程序指定的GUI（如POS）等等的用户软件来提供，然而因为架构设计上保留了高度的弹性发挥空间，致使多年来X在基础、典型、一般性的用户界面上，也都有数目惊人的多样性选择。 在X的系统架构中，窗口管理器用于控制窗口程序的位置和外观，其界面类似Microsoft的Windows或者Macintosh（例如：KDE的KWin或者GNOME的Metacity），不过在控制机制上却截然不同（如：X提供的基本窗口管理器twm）。窗口管理器可能只是个框架（如：twm），但也可能提供了全套的桌面环境功能（如：Enlightenment）。 虽然不同的X用户界面可以有很大的差异，然而绝大多数的用户在使用X时，多是用已经打包的桌面环境，这种桌面环境不仅包含窗口管理器，还具备各种应用程序以及风格一致的界面，目前最流行的桌面环境是GNOME和KDE，二者已普遍应用于Linux操作系统上，而UNIX所用的标准桌面环境多是通用桌面环境CDE，然而有些UNIX也开始采用GNOME。 此外，X桌面环境及组件虽然很多，但同时也需要保持兼容性与互通性，这些由freedesktop org积极与努力地维持各种不同X桌面环境的兼容性，使竞争态势下仍不失X的兼容本色。 5.2.4 优缺点 优点 （1）任务分工明确 客户端可以在远程电脑上执行计算任务，而X Server仅负责复杂的图形显示，充分发挥X Server在显示上的优势。 只有X Server服务端与硬件打交道，所有的客户端都与硬件无关，这让不同的平台上的移植变得很容易。 客户端可以在不同的电脑上运行，从巨型机到个人电脑，从而充分发挥网络计算的优越性。 X系统只负责显示图形，并不限制显示和操作的风格，因此不同的X Window的风格并不相同，用户可以根据自己的喜好进行选择。 由于X Window系统只提供了最基本的系统调用，而具体的视窗都有很多共性，因此要开发X应用程序，应该首先使用开发工具包，而没有必要直接使用最基本的X Window 的系统调用，以简化编写程序的工作量。 （2）独立于操作系统 X不是内置于操作系统，它只是比用户层次稍高一些。在系统中也是一个相对独立的元件。这样做有如下优点： 易于安装和改版，甚至去除。这种工作不需要重启系统，也不会对其他应用程序造成干扰。 第三方很容易支持并加强它的功能。 X不会制定操作系统，只是一个标准，这也是第三方开发软件的原动力。 为了开发者。在Server上进行工作时，如果程序异常中断，只会影响到视窗系统，不会造成机器的损坏或操作系统内核的破坏。 缺点 （1）稳定性不强 在PC世界里，需要第三方硬件驱动的非主流的个人计算机软件往往不能支持那些专为Microsoft Windows出品的设备。X Window也不例外，它的实现往往缺少较新（或者非常旧）的高效的显卡驱动。 X Window的C/S体系（C/S架构）设计在应用程序和显示硬件之间多加了一层软件，导致绘图效率下降，所以引起了一些批评。 X也被批评提供了过多的对硬件的直接访问，从而影响了系统的稳定性。 （2）不规范的用户界面 X刻意不去规范用户界面和程序之间大多数的通信，导致出现了许多非常不同的界面，同时造成程序之间协同的困难；而客户机之间的互操作规范ICCCM以难以正确实现而闻名。后来的标准化尝试，也于事无补。长久以来这已经成为用户和程序员的噩梦。 直到最近，X也没有好地解决显示与打印机所打印的内容一致性（所见即所得）的解决方案。 （3）网络通信能力弱 X不能像VNC那样把客户端的通信从一个服务端卸下然后再附加到另一个上，但现在正在为X增加此功能的工作，另外还要实现通过VNC实现X Server的显示。 X Server和远端客户机之间的网络通信使用明文的缺陷，让攻击者使用封包截取程序就能够截获和阅读它。这一缺陷一般可以通过在SSH通信上使用X来解决。 设备中立和客户端与服务端的分离还带来了一定性能开销。 参考： https://baike.baidu.com/item/X%20Window/7249336?fr=aladdin 5.3 王勇谈 Wayland 本篇大部分为转载，有改动。 Wayland是一个简单的显示服务器（Display Server），与X Window属于同一级的事物，而不是仅仅作为X Window下X Server的替代（注：X Window下分X Server和X Client）。也就是说，Wayland不仅仅是要完全取代X Window，而且它将颠覆Linux桌面上X Client/X Server的概念，以后将没有所谓的X Client了，而是Wayland Client。更确切的说，Wayland只是一个协议（Protocol），就像X Window当前的协议——X11一样，它只定义了如何与内核通讯、如何与Client通讯，具体的策略，依然是交给开发者自己。所以Wayland依然是贯彻提供机制，而非策略的Unix程序。 Wayland相对于古老的X11来说最大的提升是，Gtk/Qt 这些图形库进行图形绘制时，不用像X11那样发送绘制消息到XServer来进行绘制，而是由Client自己进行图形绘制，Wayland只用担任图层混合器的作用。这样不但减少了X Client和X Server之间不必要的通讯，而且因为由Client自己进行渲染，所以很多画面撕裂和闪屏的现象从原理上就避免了。 大家可以看一下下面的两张架构图，图??和图??，来理解两者的差别： Wayland 因为要彻底从技术架构上颠覆Linux几十年X11的渲染方式，不论从架构设计还是代码实现上都会非常复杂，不但要开发协议本身，还需要开发适合Wayland的混合器和窗口管理器，最后导致Wayland 1.0稳定版一再跳票。 而Ubuntu在独立开发Unity桌面环境的同时，也仿造了Wayland的架构开发了自己的Mir显示服务器，除了等不及Wayland稳定之外，更重要的是Ubuntu要为了它的下一步宏伟计划 “Ubuntu Touch” ，按照Mark的设想，Mir不仅仅要像Wayland那样从原理上提升Linux图形渲染效率，而且Mir还得担负起手机和电脑融合的使命，可以让Ubuntu Touch的手机在插上显示器底座时，手机的应用通过Mir的支持，可以直接在外接显示器上显示手机应用窗口，最终达到当你手机放到底座时就是电脑，拿走就是手机的设想。 不论Wayland还是Mir，虽然底层架构都非常先进，但是为了兼容现有的X11程序，它们分别开发了 XWayland 和 XMir 用于在新的显示服务器协议上支持现有的大多数 X11 程序（主要是Gtk2/Qt3/Qt4开发的大多数应用）。 具有讽刺意味的是，Wayland和Mir本来就是要解决 X11 那种不适合现代PC场景繁琐的通讯协议，甚至很多开发者为了技术的洁癖都在大力安利 Wayland/Mir ，但是最后 XWayland 和 XMir 本身的兼容实现却比 X11 的实现更加恶心和繁琐，包括Mir的开发者最后都放弃 XMir 的开发。 正是因为Wayland/Mir这样的技术无法彻底解决和大部分原本就基于X11协议而开发的应用的兼容性问题，最后导致基于Wayland/Mir开发的桌面系统从 解决渲染性能问题转变到 无法运行很多现有Linux应用 这一个更加让用户难以接受的结果。这也是后面基于Mir开发的新版Unity难产的重要原因。 参考： https://www.jianshu.com/u/E6EbkP https://www.jianshu.com/p/86dd6e34ce91 https://baike.baidu.com/item/Wayland/7429696?fr=aladdin 5.4 常见的桌面环境 桌面环境是为了方便用户操作电脑的一系列工具的集合。常常包括以下几个或者全部的组件。 窗口管理器（Window manager） 面板（Panels） 菜单（Menus） 小工具（Widgets） 文件管理器（File Manager） 浏览器（Browser） 办公套件（Office Suite） 文本编辑器（Text Editor） 终端（Terminal） 显示管理器（Display Manager） Linux 桌面环境有很多种，比如 Cinnamon，Unity，GNOME，KDE，XFCE，LXDE，MATE，Enlightenment，Pantheon ，以及后面详细介绍的深度桌面 DDE(Deepin Desktop Environment)等。 5.4.1 Cinnamon 图??，Cinnamon 桌面环境很现代很时尚，界面类似 Win 7，是 Linux Mate 的默认桌面环境，托 Linux Mate的福，也非常流行。 此桌面环境，底部有一个面板，在右下角有一个带有快速启动图标和系统托盘的时尚菜单，有一系列的键盘快捷方式方便操作，视觉效果也很棒。同时也有很好的定制功能，比如更改壁纸，添加和位置面板，添加小程序到面板，也可以添加桌面提供新闻，天气和其他关键信息等。 内存使用情况：\\(\\approx\\) 175MB 优点： 仿Windows的操作习惯。 好看、特效多、小部件多 键盘快捷键功能强大 可定制 缺点： 与其他桌面相比太耗内存 可定制的功能还不够强大 5.4.2 GNOME 图??，GNOME桌面环境，包括 GNOME2 和 GNOME3，GNU计划的一部分，开放源码运动的一个重要组成部分，是一种让使用者容易操作和设定电脑环境的工具，目标是基于自由软件，为Unix或者类Unix操作系统构造一个功能完善、操作简单以及界面友好的桌面环境，是GNU计划的正式桌面环境。 内存使用情况：\\(\\approx\\) 250MB 优点： 现代的 有大量的核心应用程序和开发工具包，使得开发人员易于创建丰富的应用程序。 功能强大的键盘快捷键 搜索过滤功能强悍 缺点： 太耗内存 可定制性极差 5.4.3 KDE 图??，KDE桌面环境类似 Cinnamon，仿 Win 7。底部有一个面板，菜单，快速启动栏和系统托盘图标。可以在桌面上添加新闻和天气等小部件。默认安装有大量的应用程序。 内存使用情况：\\(\\approx\\) 300MB 优点： 仿Windows的操作习惯 提供大量的默认应用程序，包括Web浏览器和邮件客户端。 很多小部件 可定制能力强 缺点： 太耗内存 5.4.4 LXDE 图??，LXDE桌面环境非常适合旧计算机。能提供一些非常基础的功能。 内存使用情况：\\(\\approx\\) 85MB 优点： 非常小巧，适合旧电脑和配置较差的计算机 强大的定制能力 缺点： 默认应用程序较少 可用应用程序相比其他桌面环境体验感觉不够好 参考： https://wiki.deepin.org/wiki/Linux%E6%A1%8C%E9%9D%A2%E6%BC%94%E8%BF%9B https://www.deepin.org/developer-community/architectural-design/ https://itsfoss.com/best-linux-desktop-environments/ https://www.lifewire.com/best-linux-desktop-environments-4120912 https://www.tecmint.com/best-linux-desktop-environments/ 5.5 总结 本章介绍了如何在不安装系统的情况下，试用 GNU/Linux 系统。然后介绍了 X Window 系统的概况，同时附带介绍了当前新技术 Wayland 的状况。最后列举了常见的几种桌面环境。 "],
["chap-deepin-intro.html", "6 深度操作系统简介 6.1 深度科技简介 6.2 深度操作系统的安装 6.3 桌面使用 6.4 深度桌面常用软件 6.5 总结 6.6 附注", " 6 深度操作系统简介 本章打算重构，安装操作系统后移，把系统结构转移到这里来。 通过阅读本章，你将会了解到以下几项内容。 武汉深之度科技有限公司简介 深度操作系统的安装 深度桌面使用 深度桌面常用软件 摘自：深度商业官网、深度社区官网及深度百科。已获许可。 6.1 深度科技简介 武汉深之度科技有限公司 武汉深之度科技有限公司（以下简称深度科技）成立于 2011 年，是专注基于 Linux 的国产操作系统研发与服务的商业公司。 作为国内顶尖的操作系统研发团队，深度科技以提供安全可靠、美观易用的国产操作系统与开源解决方案为目标，拥有操作系统研发、行业定制、国际化、迁移和适配、交互设计、支持服务与培训等多方面专业人才，能够满足不同用户和应用场景对操作系统产品的广泛需求。 深度科技作为国产操作系统生态的打造者，不但与各芯片、整机、中间件、数据库等厂商结成了紧密合作关系，还与 360、金山、网易、搜狗等企业联合开发了多款符合中国用户需求的应用软件。深度科技的操作系统产品，已通过了公安部安全操作系统认证、工信部国产操作系统适配认证、入围国管局中央集中采购名录，并在国内党政军、金融、运营商、教育等客户中得到了广泛应用。 截止到 2015 年，深度操作系统下载超过 4000 万次，提供 30 种不同的语言版本，以及遍布六大洲的 70 多个镜像站点的升级服务。在全球开源操作系统排行榜上，深度操作系统长期保持前 20 名，也是排名最高的中国操作系统产品。 未来，深度科技将继续秉承开源和创新精神，以操作系统的自主可控替代为契机，争取在三年内成为中国市场主要操作系统供应商，五年后成为具备国际影响力的主流操作系统厂商。 深度操作系统项目 深度操作系统 是一个致力于为全球用户提供美观易用、安全可靠体验的 Linux 发行版。它不仅仅对最优秀的开源产品进行集成和配置，还基于 Qt 技术开发了深度桌面环境和深度控制中心，并且开发了一系列面向日常使用的深度特色应用如深度商店、深度截图、深度音乐、深度影院等。深度操作系统非常注重易用的体验和美观的设计，对于大多数用户来说，它易于安装和使用，能够很好的代替 Windows 系统进行工作与娱乐。 深度操作系统的历史可以追溯到 2004 年，其前身 Hiweed Linux 是中国第一个基于Debian的本地化版本。在 2008 年更名为深度操作系统，2011 年获得商业投资，已经建立起国内少有的拥有员工数十人专注于桌面 Linux 发行版的团队。深度操作系统与Sogou, WPS, Maxthon 等合作伙伴进行了多方位合作，共同打造基于 Linux 系统的生态系统。同时，我们还在努力解决迁移 Windows 平台软件带来的各种兼容性问题，以便用户平滑的过渡到开放安全的 Linux 平台上来。 对个人用户来说，使用深度操作系统不但完全免除了购买费用，而且不会被流行的各种病毒和木马感染。对于政府和企业用户，由于源代码开放可控，绝无后门隐患，安全性也更有保障，大大降低了维护代价和购买防护软件的费用。 近年来，深度操作系统发展迅速，获得全球40多个国家用户的支持，累计下载量数千万次，并成为在Distrowatch 上排名最高的中国 Linux 操作系统发行版。 非常欢迎您尝试深度操作系统作为您工作和生活的伙伴，作为中国鲜少地专注于桌面操作系统的团队，我们相信它将给您带来完全不同的体验！ 注：深度论坛网友 licardo 建议，改为。深以为然。但是考虑到转帖的别人的文章，就保留不变了，特此说明。 6.2 深度操作系统的安装 6.2.1 安装方案 全新安装 DEEPIN 单系统 所谓安装 deepin 单系统，即计算机上不保留其他操作系统，并且使用单独的分区格式化后安装 deepin。 准备工作： 如果是全新的电脑，或者硬盘中的文件数据均已备份无需保留，则直接使用光盘或优盘启动电脑进入安装操作即可。 如果电脑中已有文件数据，则可以在现有系统（如 Windows）下将文件移动或备份，留出至少一个20G的空白分区；或者使用磁盘工具（推荐分区助手，下载地址）并选择一个剩余空间合适的分区进行大小调整，使磁盘中有20G以上的未分配空间或空白分区。 与 WINDOWS 共存安装双/多系统 在计算机上已经安装后 Windows 操作系统的情况下，如果想要保留已有 Windows 系统，则可安装双/多系统，实现 deepin 与 Windows 的共存。 与全新安装一样的，保证磁盘上有20G以上的未分配空间或空白分区即可。 6.2.2 安装环境 请确保您的电脑满足以下的配置要求，如果您的电脑配置低于以下的要求，将无法完美的体验深度操作系统： 处理器：Intel Pentium IV 2GHz 或更快的处理器 内存：至少 2G 内存(RAM)，4G 以上是达到更好性能的推荐值 硬盘：至少 10 GB 的空闲空间 同时，您还需要一张光盘以及光驱，如果您的电脑无光驱设备，可登录深度科技官方网站下载镜像文件并制作优盘启动盘。 6.2.3 启动优盘的制作 请使用深度科技团队开发的深度启动盘软件制作工具制作启动优盘，你也可使用压缩软件打开深度操作系统镜像提取。 请根据自己操作系统类型的不同，选择对应操作系统的启动盘制作工具。将优盘插入电脑后，运行深度启动盘制作工具，选择深度操作系统镜像开始制作启动盘，制作期间请不要移除优盘，制作完成请选择重启电脑。 注意： 制作前请提前转移优盘中重要数据，制作时可能会清除优盘所有数据； 制作前建议讲优盘格式化为FAT32格式，以提高识别率； 部分优盘实则为移动硬盘，因此无法识别，请更换为正规优盘； 优盘容量大小不得小于8G，否则无法成功制作启动盘； 制作过程中请不要触碰优盘，以免因为写入不全导致制作失败。 6.2.4 安装过程 一般情况下电脑默认是从硬盘启动，因此，在使用光盘（优盘）安装系统之前，您需要先进入电脑的BIOS界面将光盘（优盘）设置为第一启动项。 台式机一般为 Delete 键、笔记本一般为 F2 或 F10 或 F12 键，即可进入 BIOS 设置界面。 您只需在享受一杯咖啡的时间，便可完成系统的安装。 1、将深度操作系统光盘（优盘）插入电脑光驱（USB接口）中。 2、启动电脑，将光盘（优盘）设置为第一启动项。 3、进入安装界面，选择需要安装的语言。 4、进入账户界面，输入系统用户名和密码。 5、点击下一步。 6、选择文件格式、挂载点、分配空间等。 7、点击安装。 8、在弹出的确认安装窗口中，点击确定。 9、将开始自动安装深度操作系统。 安装视频见：https://www.bilibili.com/video/av16993752/ 想对安装过程有更多理解，可以阅读附录F，或者网上搜索相关教程。 6.3 桌面使用 其实深度系统自带一套学习指南深度帮助手册。可以按下Super键，也即一般电脑上微软标志的那个键，或者苹果电脑上的花键。在搜索里输入深度帮助手册就能够找到。打开后，可以自学很多知识，本书摘录其中部分内容。 还有另外一套帮助工具，欢迎，同上，打开后，可以直接设置相关的选项。 6.3.1 开机 如果你使用过 Windows 操作系统，那么使用深度桌面操作系统也不是难事。这里主要讲社区版深度桌面操作系统。 开机登录后，点击Super键会弹出如下界面。 你可以对所需要的软件进行搜索。直接点击软件图标，就可以打开软件了。分类放置的软件。在任务栏驻留的软件打开时，还会有动画显示。 6.3.2 关机 同时按 Ctrl + Alt + Delete，或者点击右下角关机按钮，就会弹出关机界面，如下图所示。 6.3.3 控制中心-系统设置 点击任务栏，或者鼠标滑向桌面右下角几次，会在右侧出现控制中心面板。如下图所示。 首页展示快速入口、常用快捷设置等，让操作更加方便和快捷；天气详情、通知中心通过插件展示，今后会开放插件接口，让您可以更多的参与定制。有兴趣的话，可以点开逐步试试。 6.3.4 开机自启动 一些软件需要开机自启动，比如 QQ 还有一些保护眼睛的软件，比如定时休息的 workrave， 减少蓝光的 red-shift。点击 Super键，弹出所有的软件图标，看中要开机自启动的，右击选择开机启动。 6.3.5 常用快捷键 常用快捷键类似微软 Windows 操作系统，还可以自己定制快捷键。详情请参考控制中心 \\(-&gt;\\) 键盘和语言 \\(-&gt;\\) 快捷键。 6.3.6 安装软件 使用电脑，不可避免的要用到很多软件。深度商店为您解忧愁，方便您查找并安装相关的软件。当然除了深度商店，您还可以使用命令行安装软件，关于命令行安装软件的介绍详见后面章节。 6.3.7 卸载软件 按 windows 键，弹出的软件，右击选择卸载。或者命令行，这里就不介绍了，在后面详细说明。 6.4 深度桌面常用软件 打开深度商店，会有很多常用软件推荐，另外在官网深度原创应用有深度大量原创好用的软件，在官网深度合作应用等也有几个非常杰出的软件，下面介绍几款。 6.4.1 搜狗输入法 这个是系统默认自带的了，贴它是为了怀念曾经被输入法折磨的岁月。官网有详细介绍：http://pinyin.sogou.com/linux/?r=pinyin 不过我最希望有讯飞语音输入法，这个如果可以在 Linux 桌面下生存，是最好不过的。不过当前还没有 Linux 版本。 6.4.2 QQ 国人挚爱。可以视频。就不废话了。系统默认自带，如果没有，命令行安装。 $ sudo apt-get update $ sudo apt-get install deepin.com.qq.im 6.4.3 深度截图 深度截图是深度科技团队开发的一款精巧截图应用，它具有智能窗口识别、快捷键支持、图片编辑、延迟截图、智能保存、调节图像分辨率等功能。 深度截图也是系统默认自带的，如果没有，直接在深度商店搜索下载，也可以采用命令行安装。 $ sudo apt-get install deepin-screenshot 6.4.4 网易云音乐 为了带来更好的音乐体验，实现对音乐高品质的追求，经过网易云音乐与深度科技团队长达半年多的联合开发，大家期待已久的网易云音乐正式登陆Linux平台！ 深度操作系统用户可运行深度商店，搜索网易云音乐 进行安装体验，非深度操作系统用户可前往网易云音乐官网下载Linux客户端安装体验。另外，您也可以命令行安装。 $ sudo apt-get install netease-cloud-music 6.4.5 深度系统监视器 深度系统监视器是深度科技团队打造一款直观易用的系统监视器应用，它可以实时监控处理器状态、内存占用率、网络上传下载速度；还可以管理您的系统进程和应用进程，支持搜索进程和强制结束进程。 系统默认自带，如果没有，可以深度商店搜索下载，也可命令行安装。 $ sudo apt-get install deepin-system-monitor -y 6.4.6 深度无线投屏 深度演示助手是一款用于手机内容分享的演示工具。它支持照片分享功能，分享时可以对照片进行旋转、标记、聚焦等操作。甚至还可以直接将手机屏幕投射到电脑上，视频、游戏都轻松分享。另外还支持幻灯片远程控制，让您在演示幻灯片时无拘无束。 系统默认自带，如果没有，可以深度商店搜索下载，也可命令行安装。 $ sudo apt-get install deepin-presentation-assistant -y 6.5 总结 本章简要介绍了深度科技公司及深度操作系统的部分内容，并对桌面常用的一些操作和常用的若干软件做了简单描述。如果需要对深度操作系统的框架了解更多，可以阅读官网架构设计，或者更进一步阅读源代码。 6.6 附注 有建议说要转载王勇的文章，有机会试试。 "],
["chap-education-intro.html", "7 教学用的 Linux 软件 7.1 引言 7.2 笔记 7.3 课堂工具 7.4 文献阅读写作管理工具", " 7 教学用的 Linux 软件 参考网页： https://www.linux.com/news/best-linux-tools-teachers-and-students https://linux.cn/article-9722-1.html 7.1 引言 邓公当年曾说“计算机的普及要从娃娃做起。”其实深度操作系统的普及也可以从娃娃抓起。电脑的应用，更多的在于顺手的软件，教育方面也不例外。本章参考网上部分资料，介绍一些方便教学的软件。 7.2 笔记 毛主席的一个读书习惯“不动笔墨不读书”，既然要学习肯定是要做笔记的。GNU/Linux 操作系统下的笔记还是有很多种的，比如为知笔记、leanote、QOwnNotes、BasKet Note Pads、深度官方使用的石墨文档等，更多软件可以参考深度商店的办公学习软件列表。当然也有一些便笺软件，比如 Xpad 。读者可以根据自己情况选择需要的软件，下面以 leanote 和 Xpad 为例进行介绍。 7.2.1 leanote leanote 又称蚂蚁笔记，在深度商店里搜索 leanote, 如下图7.1所示，点击安装，等待安装完成，点击打开即可。 \\begin{figure} {\\includegraphics[width=100%]{images/education-leanote-install} } \\end{figure} 安装完成后，注册登录，就可以使用了。本人试用界面如图7.2。该笔记软件跟其他很多笔记软件类似，可以离线在线使用，甚至自建服务器。能够满足日常需要了。 \\begin{figure} {\\includegraphics[width=100%]{images/education-leanote-use} } \\end{figure} 7.2.2 Xpad 便笺 在深度商店里搜索 xpad，找到该软件，点击安装即可。安装成功后，按下 win 键或者鼠标点击左下角启动器按钮，弹出软件列表界面。如图7.3 或者 图7.4所示 \\begin{figure} {\\includegraphics[width=61.8%]{images/education-xpad-search-smallscreen} } \\end{figure} \\begin{figure} {\\includegraphics[width=100%]{images/education-xpad-search-fullscreen} } \\end{figure} 在上述界面中，都有搜索框，可以在搜索框里输入 xpad 查找。找到后，点击图标，就会打开类似图7.5的界面，跟 win7 便签很类似。 \\begin{figure} {\\includegraphics[width=61.8%]{images/education-xpad-start} } \\end{figure} Xpad 初始界面不一定符合用户习惯，可以自定义配置。在界面上右击，会弹出如图7.6列表，选择Preferences(首选项)，进行配置。 \\begin{figure} {\\includegraphics[width=61.8%]{images/education-xpad-rightclick} } \\end{figure} 为了方便，对弹出的界面图7.7，我做了如下配置，勾选了View &gt;&gt; Show Window Decorations用于显示窗口，以及 Startup &gt;&gt; Start Xpad automatically after login开机自启动。 \\begin{figure} {\\includegraphics[width=61.8%]{images/education-xpad-setwin} } \\end{figure} 如果需要删除某个便签，选中按下 Shift + Delete 键即可。 7.3 课堂工具 对于课堂工具，本章主要介绍师生屏幕广播软件，功能类似 Windows 下的 红蜘蛛多媒体网络教室软件以及。 7.3.1 Veyon 该软件开源，官网能够下载 Window 和 Linux 版本的安装包。主要功能允许教师查看学生桌面上发生了什么，控制他们的桌面，锁定他们的桌面，对桌面演示，打开或关闭桌面，向学生桌面发送文本消息等等。安装方式如下， $ sudo apt-get install veyon -y 具体使用方法，请参考官网文档或者网上搜索相关资料。 7.3.2 AContent AContent 是 aTutor 的一个加强包，能够创建和管理在线考试和测验，分享教学资料等。 下载地址 github源码 安装方法从略。使用有一定难度，不是太推荐。 7.3.3 Moodle 比较推荐这个，这是一个网站，需要预先安装服务器，比如 Apache，MySQL 等，为了方便可以使用一键安装软件 XAMPP 等。 官网 github源码 百度百科 其官网有相关说明，需要一定的网页技术知识，这里不赘述了。 7.4 文献阅读写作管理工具 对于学生和部分秉承“活到老学到老”精神的人来说，好的文献阅读工具必不可少。同样一些方便写作的编辑器也是很有市场的。对于 word 文档，比如金山 WPS 旗下产品或者永中等已经很多了，这里就不介绍了。对于程序员“编辑器之神” vim 和“神之编辑器”emacs 的争论也未曾停息。这里简要介绍几款论文写作的工具。 如果有更好的软件，或者使用方法，也请读者不吝赐教，感谢。 7.4.1 bookdown 参考网页： https://bookdown.org/yihui/bookdown/ Bookdown 基于 R Markdown，具有Markdown语法的简单性（您可以在5分钟内学习基础知识；参见附录D），提供多种输出格式（PDF/HTML/Word/…）。还添加了多页HTML输出、编号和交叉引用图形/表格/部分/方程、插入部分/附录等特性，支持GitBook样式便于创建优雅和吸引人的HTML图书页面。 尽管Bookdown包含“书”（book）一词，但不限于生成书籍，也可以生成课程讲义、学习笔记、软件手册、论文，甚至日记等。 另外，班门弄斧一下，本书就是采用 bookdown 模板编写的，自认为还是有点精美的。另外本人制作了上海交大论文模板，也有好事者赵鹏移植了若干模板，有兴趣把各高校论文 模板改为 bookdown 的，可以共同讨论。 7.4.2 VuFind 参考网页： https://www.oschina.net/p/vufind http://vufind.org/ VuFind 是图书馆资源门户系统，主要提供图书馆资源的检索和浏览功能，功能模块包括： Catalog Records Locally Cached Journals Digital Library Items Institutional Repository Institutional Bibliography Other Library Collections and Resources VuFind 是完全模块化的，你可以自由选择模块。全平台支持，当然包括 Linux，二进制文件官网提供下载。 7.4.3 Calibre 参考网页： https://calibre-ebook.com/ https://calibre-ebook.com/download_linux Calibre 是电子书管理软件，支持 Amazon、Apple、Bookeen、Ectaco、Endless Ideas、Google/HTC、Hanlin Song 设备及格式，功能十分强大。通常我都是按照官网提供的方法下载安装 $ sudo -v &amp;&amp; wget -nv -O- \\ https://download.calibre-ebook.com/linux-installer.sh \\ | sudo sh /dev/stdin 7.4.4 CAJViewer 参考网页： http://cajviewer.cnki.net/introduction.html “CAJViewer 7.2” 是光盘国家工程研究中心、清华同方知网(北京)技术有限公司 CAJViewer 系列产品截至 2006 年 11 月为止的最新版本，它充分吸取了当前市场上各种同类主流产品和自身上一版本 CAJViewer 6.0 的优点，经过长时间市场调查和系统设计而成，兼容 CAJ 和 PDF 等文件。 对于高校学生，这个阅读器你懂得。深度提供了相应版本。 7.4.5 搜索神器 Everything 参考网页： http://www.voidtools.com/ http://www.voidtools.com/downloads/ https://github.com/DoTheEvo/ANGRYsearch Everthing 正是当之无愧的最强文件搜索神器！！它可以在闪电般的瞬间从海量的硬盘中找到你需要的文件！速度快到绝对让你难以置信！首次接触到 Everything 可真让我惊讶和兴奋了许久！！而且它还是一款完全免费的软件，界面简洁高效，体积很小巧，但功能却非常丰富！Everything 文件搜索工具最大的优点是近乎变态的速度。其速度不是快，是快到离谱；用户不是满意，而是震惊。你甚至会愤怒，它凭什么这么快？！ — Everything 用户 当然这个 Everything 目前只能用于 Windows 系统。在深度下也有类似的软件，ANGRYsearch。如果感兴趣的不妨试试。源码有安装说明。 "],
["chap-shell.html", "8 shell 用法简介 8.1 用 shell 有啥好处？ 8.2 深度操作系统下 shell 简介 8.3 命令快捷编辑 8.4 命令连接与扩展 8.5 Shell 变量（Variables） 8.6 定制 shell 环境 8.7 命令帮助 8.8 总结", " 8 shell 用法简介 通过阅读本章，你将会了解到以下几项内容。 了解 Linux Shell 打开 Shell 终端的方法 Bash 语法简介 Bash 自动补全和输入历史 命令的拼接和拓展 变量和简写 如何使用理解帮助文档 作为普通人，使用电脑除了窗口图形界面外，还有个叫终端的字符界面。Linux 中通过在终端敲击字符跟电脑交互，这玩意就叫做 shell，并且相比图形界面（Graphic User Interfaces, GUI），通常 shell 功能更加强大。 深度系统默认采用的 shell是 bash（Bourne Again Shell），继承兼容于 UNIX 早期的 Bourne shell （作者：Stephen Bourne， 命令名为 sh），当然两者还是有那么一点点不同的。曾经有一段时间深度默认 shell 是 zsh，经群众投票又改回 bash了，其实那次投票是我发起的。 除此之外，类 UNIX 系统还有其他的一些 shell，比如 ksh,csh,tcsh，ash，当然还有非常好用的 zsh 等，有兴趣的可以查相关资料。 8.1 用 shell 有啥好处？ 为了装吗？不见得。 刚接触 Linux 桌面发行版的时候，按着教材说的，就在学习终端哦。遇到糟糕的 Linux 图形界面卡住了、死机啦，不得不网上搜索解决方案，能不用终端 shell 吗？作为小白，遇到各种各样的问题，查询询问的结果，大神的建议，也多半是在 shell 下解决啊，这叫不得不用。 后来慢慢脱离低级小白，开始喜欢上终端远程连接其他 Linux 电脑，享受这种快捷方便的操作。再后来终端下用 vim 写代码，键盘翻飞，似乎成为了一种享受。 再后来，开始接管一些服务器，开始学习计算机安全知识，似乎更离不开了 shell 了。似乎儿时那种黑客的感觉，只有通过 shell 才可以实现哦。 其实 Windows 下也有 DOS 和 CMD 这类字符操作界面，不过功能弱爆了， powershell 可能功能强大一些，有兴趣的可以查相关资料，这里不说了。 8.2 深度操作系统下 shell 简介 按照《Linux Bible》的说法，有三种方式打开 shell 操作界面，分别叫shell提示符（shell prompt），终端窗口（Terminal window），和虚拟控制台（virtual console）。我感觉深度操作系统就后面两种，第一种说是登录的时候出现的那种字符界面，不太容易遇到，暂且跳过。 深度操作系统登录后，进入桌面，按下 Ctrl + Alt + T （或F4或Alt + F2打开终端雷神模式，这个版本不同有所变化）会弹出深度终端窗口，这个软件在第三章已经作了介绍。可用于 shell 练习。对于虚拟控制台，可以通过按下 Ctrl + Alt + Fi 其中 Fi 表示 F1,F2,...,F6，分别弹出六个虚拟控制台，对于不同的电脑，可能Ctrl + Alt + F1 或者Ctrl + Alt + F7 打开的是图形界面（GUI）。 下面以深度终端窗口为例来说明。 打开深度终端的方式 快捷键的方式：按下 Ctrl + Alt + T 或者 F4 或 Alt + F2，弹出深度终端。 图形方式：按下 super 键，或者点击左下角的图标，会弹出已安装软件图标，找到深度终端的图标，点击即可。或者在最上面搜索框中搜索终端。 鼠标右键：在桌面上，右击选择在终端中打开，也可以进入深度终端。 打开终端后，右击窗口内部，选择设置，可以对终端的一些外观属性配置。 深度终端的显示说明 在每行命令行开头会如下显示， litianci@litianci-pc:~$ 解释 litianci@litianci-pc:~ 表示用户名和电脑名，并用@隔开，:后是当前工作目录～，～是主目录的意思，因为古老的键盘中～和Home是同一个按键，所以就用 ~代替主目录了。 $ 默认表示普通用户， # 默认表示 root 根用户。 这个显示说明是可以修改的，见后文 @ref() 小节。 在 $ 或者 # 后输入相关的命令字符。 $ 表示正在用普通用户权限运行后面的命令，而 # 则表示正在使用 root 根用户的权限。通常只有涉及重大核心系统功能的地方才需要用到root根用户权限。根据放权的最小权限原则，在普通用户权限可做的事情，建议不要使用 root 根用户权限。 8.2.1 牛刀小试 下面命令行首标志 $ 和 # 区分运行权限，其他显示信息略。输入结果行没有行首标志，每行会有序号方便区分。 $ whoami litianci $ who -H 名称 线路 时间 备注 litianci tty1 2018-09-20 09:07 (:0) $ grep litianci /etc/passwd litianci:x:1000:1000::/home/litianci:/bin/bash 解释 whoami 列出当前用户名 who -H 列出信息更详细，-H 表示显示头部标题列，第二行显示当前登录用户名litianci，当前登录线路终端tty1，当前用户登录系统时间2018-09-20 09:07，以及备注(:0)，该备注啥意思暂时没有找到，是不是图形界面的意思，待后续找资料。 第6行，是在/etc/passwd文件内查找该用户，在第7行最后/bin/bash，表示该用户默认的shell类型。实际操作时请把litianci换成你的账户名。 $ date 2018年 09月 21日 星期五 16:45:08 CST $ pwd /home/litianci $ hostname litianci-PC $ hostname -I 192.168.43.45 $ ls Desktop Documents Downloads Music Pictures Videos 解释 date 命令，无选项无参数时，输出当前日期、星期、时间和时区。其中CST表示中国标准时区，也即东八区。不过CST这个简写有歧义，代表如下几个时区， CST Central Standard Time (USA) UT-6:00 CST Central Standard Time (Australia) UT 9:30 CST China Standard Time UT 8:00 CST Cuba Standard Time UT-4:00 pwd 命令输出当前工作目录。 hostname 命令，无选项无参数时输出本机名称，如果加选项-I，则输出本机IP地址。 ls 命令列出当前目录下所有的可见文件及文件夹。 8.2.2 命令语法结构 为了丰富命令的功能，命令常常带多种选项及参数的，这里区分两个名称， 选项(Options)：是调整命令执行行为的开关，即，选项不同决定了命令的显示结果不同； 参数(Arguments)：是指命令的作用对象。 8.2.3 选项(Options) 选项分为长选项和短选项。下面示例中，-l -a -t就是短选项， $ ls -l -a -t $ ls -lat 解释 -l(long listing)，宽列，较长格式列出信息，-a(all)列出所有文件（夹），包括隐藏文件（夹），-t(time)按时间排序。 短选项一般使用-短横线引导。也有不带-的，比如ps aux，这类叫BSD风格的选项。 当有多个短选项时，各选项之间使用空格隔开。 有些短选项可以组合，比如 -l -a -t 可以组合为-lat。 有些短选项需带参数，比如-L 512M，则不便跟其他短选项组合，但如果位于最后一个也是可以组合的。比如tar cvf deepin-bible.tar ~/deepin-bible，各选项说明见后面8.2.5节解释。 $ ls --hide=Desktop Documents Downloads Music Pictures Videos 解释 --hide=Desktop，不列出 Desktop 这一文件夹。 长选项一般使用--两个短横线引导，而且后接完整英文单词。 长选项通常不能组合。 长选项如果需要参数，一般用=，比如--size=1G。不过也有用空格隔开的，比如 pandoc test.md --to latex表示使用pandoc命令把test.md文件转化为latex格式。 以上均为常见格式，具体使用方法，还需查看相关命令的帮助，比如cmd --help，获得正确用法。 8.2.4 参数(Arguments) 上面讲述选项有所介绍，通过空格或者等号传入参数，也有直接通过空格缀在命令后面的。比如， $ cd /media/litianci/data/ 跳转到/media/litianci/data/ 文件夹。 8.2.5 更多例子 为了方便大家上手，再多介绍几个例子。 $ tar cvf deepin-bible.tar ~/deepin-bible $ uname $ uname -a $ date $ date +&#39;%Y-%m-%d&#39; 2018-09-21 $ date +&#39;%A, %B %d, %Y&#39; 星期五, 九月 21, 2018 $ id uid=1000(litianci) gid=1000(litianci) 组=1000(litianci),7(lp),24(cdrom),27(sudo) $ who -aH 名称 线路 时间 空闲 进程号 备注 退出 系统引导 2018-09-21 15:54 运行级别 5 2018-09-21 07:54 litianci + tty1 2018-09-21 07:55 旧�� 3820 (:0) 登录 tty2 2018-09-21 21:48 21868 id=tty2 解释 第1行命令，c(create)表示创建压缩文件，v(verbose)表示详细信息，f(file)表示创建的文件为deepin-bible.tar；这是典型的组合命令，而最后一个组合选项f带参数deepin-bible.tar。~/deepin-bible置于最后，为待压缩文件夹。这样本条命令实现了对文件夹的压缩。 第2、3行，uname命令，显示系统名字，-a(all)选项，表示显示系统所有信息。 第4、5、7行，输出不同格式的日期时间格式。详细说明可以参考date --help的说明。有兴趣的可以多试试。注意系统语言对显示结果的影响。 第9行，id，常用于核实自己账户编号信息。 第11行，-a表示显示较多信息，具体信息参考who --help说明。-H已经在前面说明，显示列标题。 由于采用系统默认的中文，深度终端自作聪明的翻译，有些内容乱码。为了方便叙述，后面把终端显示改为英文的，也即在~/.bashrc文件加上所用语言选项，并执行。 $ echo LANG=en_US &gt;&gt; ～/.bashrc $ source ~/.bashrc 或者直接修改所有用户的 bash 信息，sudo gedit /etc/profile，修改最后一行的LC_ALL=C为LC_ALL=en。 回头再看who -aH命令，就清爽了。当然需要你对英文有一定理解了。 $ who -aH NAME LINE TIME IDLE PID COMMENT EXIT system boot Sep 21 15:54 run-level 5 Sep 21 07:54 litianci + tty1 Sep 21 07:55 old 3820 (:0) LOGIN tty2 Sep 21 22:02 25289 id=tty2 8.2.6 找找命令文件在哪里 相信大家都听说过一切皆文件的Unix哲学，其实很多命令都是可执行文件，是可以查看这部分命令的文件的。比如bash位于/bin/bash，那么命令bash和/bin/bash就是相同的。为啥我们可以简写为 bash呢？是因为shell有PATH（路径）这个环境变量。众多已知目录存放在 PATH 变量里，shell 遇到这些没有目录路径的命令，在查找其他默认命令集合无果后，就会去PATH路径变量里各目录下去找该文件名，从左到右查找，找到后就执行命令，找不到就会报错。那么你电脑上的 PATH 是啥呢？ $ echo $PATH /home/litianci/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:/sbin:/usr/sbin 一般命令，都存放在 /bin，/usr/bin，或 /usr/local/bin 文件夹。一般管理相关的命令放在 /sbin 和 /usr/sbin 文件夹，也有一些 GNU/Linux 发行版放在非常规文件夹下。这些文件夹以英文冒号 : 隔开。最后无冒号。 而最开始的/home/litianci/bin文件夹是自己所用的目录。你可以对 PATH 修改，添加某些你常用的命令文件夹。配置方法见后面叙述。 不过这里存在安全隐患，如果罪恶黑客侵入你系统，无权修改你系统级别的文件，但是有能力在你的文件夹下创建可执行文件，比如/home/litianci/bin，跟系统文件夹的命令同名，你以为你用的是系统的命令，并输入密码，却不料执行的是黑客想要的命令。对于系统管理员，建议输入命令的时候，把目录带全，避免这类权限泄露。 下面总结 shell 查找命令位置的优先级别。 别名（aliases）。别名就是某命令包含或不包含一系列选项的集合，便于输入。后面@ref()小节详述。 shell 保留字（Reserved word），构建 shell 脚本的基础，比如do，while等。见后面@ref()章详述。 函数（function），shell 中创建的命令集合。 shell 内置命令（built-in），这些命令在文件系统中是找不到的，比如cd改变工作目录，exit退出shell，echo输出文本，history查看之前命令运行历史，pwd显示当前工作目录，还有set和type等。 文件系统中可以执行的文件。比如PATH变量中那些目录下的文件等。 你输入的命令是哪个呢？ 在 bash 内，使用 $ type ls ls 是 `ls --color=auto` 的别名 可以看到你的命令是哪个命令。为了显示全部同一名称的命令，可以加-a选项。 $ type -a ls ls 是 `ls --color=auto` 的别名 ls 是 /bin/ls $ type -a cd cd 是 shell 内建 可以看到有两个ls命令。cd是内置命令（翻译有差距）。其他shell也可用which命令查找当前正在使用的命令是哪一个。 此外还有可以找命令文件位置的which和locate(深度系统未自带)，有兴趣的可以去找找资料。 8.3 命令快捷编辑 8.3.1 方便编辑的快捷键 如果命令不足够快捷，那还不如鼠标点点点呢。提到编辑器，在 Linux 世界就跳不过编辑器之神(vim)和神之编辑器(emacs)的争论。在这里不探讨孰是孰非。而 bash 默认的编辑方式就是这两者之一的 emacs 模式。如果喜欢 vim 的编辑方式，也可用设置为 vim 模式。在 ~/.bashrc文件末尾加上 set -o vi，下次启动终端的时候，就是 vi 模式了。所谓模式，也是为了方便编辑，提供一些快捷键等。我最喜欢用的快捷键，就是 Ctrl+A跳到行头，Ctrl+E跳到行尾和Ctrl+L清屏了。其他的都是键盘上下左右键切换，懒得记录这些快捷键。不过还是把这些快捷键列在下面吧。 光标跳转快捷键说明 快捷键 解释 Ctrl+F 向前一个字符 Ctrl+B 后退一个字符 Alt+F 向前一个单词 Alt+B 向后一个单词 Ctrl+A 跳到该行行首 Ctrl+E 跳到该行行尾 Ctrl+L 清空屏幕内容 注:清屏，只是把内容放到屏幕上方，并加入了很大一片空白，滚动鼠标还可以看到刚刚输出的内容。 编辑快捷键说明 快捷键 解释 Ctrl+D 删除当前字符 Backspace 删除前面字符 Ctrl+T 前后字符换位 Alt+T 前后单词换位 Alt+U 当前单词大写 Alt+L 当前单词小写 Alt+C 选中字符大写 Ctrl+V 插入特殊字符 注:每个快捷键具体动作，还需要多加练习记忆。对于插入特殊字符的，Ctrl+V比如插入表格键Table，则Ctrl+V+Tab,经测试不是那么回事。 复制粘贴快捷键说明 快捷键 解释 Ctrl+K 剪切光标到行尾的全部字符，含光标所在字符 Ctrl+U 剪切光标到行首的全部字符，不含光标所在字符 Ctrl+W 剪切光标前到当前单词词首的字符，不含光标 Alt+D 剪切光标后到当前单词词尾的字符，含光标 Ctrl+Y 粘贴到光标前 Alt+Y 循环显示刚刚剪切的内容，待你确定粘贴对象 Ctrl+C 删除整行 8.3.2 重输之前的命令 参考网页： https://blog.csdn.net/maplesky2017/article/details/78389068 https://www.cnblogs.com/5201351/articles/4208509.html bash 是会记录你已经输入命令的。使用history命令，可以查看相关内容。常见用法如下。 上下键查看以前的命令（包括Ctrl+N、Ctrl+P快捷键）； history 8 查看最近八条命令记录； history 查看最近$HISTSIZE条命令记录 !n 调用第n条命令，n是一个正整数； !! 调用上一条命令； !字符串 调用最后一以该字符串开头的命令。 本人感觉以上命令不太实用。除非你知道刚刚是啥命令，才方便操作。Matlab 软件的命令记录就很好查询。输入部分字符就可以把所有以该字符开头的命令记录一次列出。对于 bash，类似的功能非常鸡肋。在空行内按下快捷键Ctrl+R，输入部分字符，会查找相关命令记录，符合你需求，回车，就直接运行了。丝毫不给你重新编辑的机会，也无法上下翻阅，难用至极。另外还有快捷键Ctrl+S在深度操作系统下，不能用。另外两个Alt+P，Alt+N有心情的可以试试。如果哪位有好的用法，欢迎提供。 默认记录1000条命令，但是事实上记录文件里记录的命令条数可能超过此数值。可以输入如下命令查看， $ echo $HISTSIZE 1000 $ echo $HISTFILE /home/litianci/.bash_history 解释 第1行命令，查询命令记录条数，显示为1000。变量$HISTSIZE用于设置记录条数。 第3行命令，查看命令记录文件，本机为/home/litianci/.bash_history。 如果我们想修改记录条数，或者记录文件，可以/etc/profile修改相应的变量。下面以修改记录条数为200进行讲解。 $ sudo sed -i &#39;s/^HISTSIZE=1000/HISTSIZE=200/&#39; /etc/profile $ source /etc/profile #使其立即生效 上方命令使用的是sed输入的，您可以以其他方式，在文件/etc/profile加上一行HISTSIZE=200。并保存退出。 对于系统管理员来说，可能保存这些操作记录很危险。你可以设置零记录，或者把记录文件设置为垃圾箱。 HISTSIZE=0，HISTFILE=/dev/null 8.3.3 自动补全 参考网页： https://blog.csdn.net/mycwq/article/details/52420330?utm_source=copy http://www.techug.com/post/10-linux-completion-commands.html 在Linux命令行下，输入字符后，按两次Tab键，shell就会列出以这些字符打头的所有可用命令。如果只有一个命令匹配到，按一次Tab键就自动将这个命令补全。比如，想更改密码，但只记得这个命令前几个字母是pass。这时候，按Tab键，shell就自动输出 passwd 命令，非常方便。 有些发行版，比如centos最小化安装，常常只能补全命令名和文件名，则需要安装补全增强软件包bash-completion。而一般补全的内容有如下几种。 命令（Command）别名（alias）和函数名（function）。常规字符输入，敲一两次Tab键即可。 变量（Variable）。如果你输入了美元符号($), shell 会给你补全可能的变量。 用户名（Username）。如果你输入了波浪符号(~), shell 会给你补全可能的用户名。~username表示该用户的主目录。 主机名（Hostname）。如果你输入了邮箱符号(@), shell 会给你补全/etc/hosts文件里的主机名。 8.4 命令连接与扩展 前面 Unix 哲学讲程序，应当能够协作。命令协作靠的是元字符（metacharacter）功能。元字符有如下7个：|,&amp;,;,(,),&lt;,&gt;。 8.4.1 匿名管道 参考网页： https://www.cnblogs.com/pengliangcheng/p/5211786.html https://www.xuebuyuan.com/3234708.html https://www.jb51.net/article/120741.htm 管道字符|，意如其名，类似管道一样将管道入口的数据通过管道传递给管道出口。 管道是为了解决进程间通信问题而存在，它可以让两个进程之间的数据进行传递，将一个进程的输出数据传递给另一个进程作为其输入数据。管道左边是数据给予方，管道右边是数据接收方。 管道仅能处理经由前面一个指令传出的正确输出信息，也就是 standard output 的信息，对于stdandard error 信息没有直接处理能力。然后，传递给下一个命令，作为标准的输入 standard input。如下图所示， 管道命令只处理前一个命令正确输出，不处理错误输出 管道命令右边命令，必须能够接收标准输入流命令才行。 $ ps aux | grep &quot;ssh&quot; litianci 11012 0.0 0.0 14660 1124 pts/0 S+ 15:39 0:00 grep ssh 按一般想法，先执行了ps，得到输出后将输出数据传递给grep，这时候grep还没运行而ps已经运行完毕了，为什么还能统计到grep进程的信息呢？原因是管道实现的是进程间通信，两个进程之间存在交叉，在运行ps进程后开始收集进程信息，grep也已经开始并处于等待接收数据状态，当ps收集到任何数据后都将输出放入内存由管道传递给grep进行筛选。 管道其本质是数据传递，管道左边的输出数据放入内存，由管道右边的进程读取。假如内存不足以完全存放输出数据，则管道左边的进程将一直等待，直到管道右边取出内存中一部分的数据以让管道左边的进程继续输出，而管道右边的进程在管道左边的进程启动后也立刻启动了，但是它一直处于等待状态，等待接收管道传递来的数据。 也就是说，管道左右两边的进程运行几乎是没有先后顺序的。 上述管道是指匿名管道。使用匿名管道的过程中，可能已经发现管道两边的进程是同属一个进程组的，也就是说管道左方的数据只能传递给管道右方的进程，其他任何进程都没法读取此数据。但除了匿名管道，还有命名管道，命名管道是将一个进程的数据存储到一个管道文件(fifo)中，其他进程可以读取该管道文件来读取其中的数据，也就是说不再限制数据读取方。关于命名管道，请参阅Linux/Unix操作系统内核或编程类的书籍，一般都会有详细的介绍。 再来两个简单例子 $ cat /etc/passwd | sort | less $ gunzip &lt; /usr/share/man/man1/grep.1.gz | nroff -c -man | less 解释 第1行命令，cat 命令显示文件/etc/passwd的内容，输出到sort命令进行排序，再送给less命令显示出来。 第2行命令，gunzip 命令解压缩grep.1.gz文件，送给nroff命令调整为适合阅读的格式，传递到less命令显示出来。 8.4.2 重定向 参考网页： https://blog.csdn.net/u014536527/article/details/51010678 最常见的标准输入（stdin）、标准输出（stdout）和标准错误输出（stderr）的文件描述符分别是0、1和2，其中0、1、2也可以认为是它们的数字代号。 三个特殊的文件 名称 程序 代号 符号 标准输入 /dev/stdin 0 &lt;或&lt;&lt; 标准输出 /dev/stdout 1 &gt;或&gt;&gt; 标准错误输出 /dev/stderr 2 2&gt;或2&gt;&gt; &lt;、&gt;、2&gt;实现的是覆盖功能，&gt;&gt;、2&gt;&gt;实现的是追加的功能，但是&lt;&lt;不是追加功能，而是表示此处生成文档(here document)，在后面cat和重定向配合的内容里有说明。此外，还有&lt;&lt;&lt;，它表示此处字符串(here string)，也见下文。 一般-都是表示旧工作文件夹；有时候，-也表示/dev/stdin，。如： $ cat /etc/fstab | cat - 脚本中常见2&gt;&amp;1和&amp;&gt;的符号，它们都表示将stdout和stderr都重定向到同一个地方去，即重定向所有输出内容。如最常见的&amp;&gt; /dev/null表示将stdout或stderr丢到/dev/null表示丢弃输出信息，反过来，将/dev/null重定向到某个文件则表示清空文件。 $ cat /dev/null &gt; ab.sh 除此，还有以下几种方法快速清空文件 $ &gt; ab.sh $ : &gt; ab.sh # 或&quot;true &gt;ab.sh&quot;，其实它们都等价于&quot;&gt;ab.sh&quot; $ echo &#39;&#39; &gt; ab.sh $ truncate -s 0 ab.sh # truncate命令用于收缩和扩展文件大小 $ dd if=/dev/null of=ab.sh 最后最重要的一点：在有重定向符号的语句中，命令执行之前已经将文件截断了。所以如果正在编辑一个文件并将编辑的结果重定向回这个文件将出现异常，因为截断后就没有合适的内容用于编辑。一个简单的示例如下： $ head a.log &gt; a.log 有些时候直接使用&gt;覆盖输出是比较危险的。可以使用set -C来设置如果输出重定向文件已经存在则不覆盖。使用set +C来取消set -C的效果。如果在设置了set -C时仍然想强制覆盖，可以使用&gt;|代替&gt;来重定向输出。同理错误输出也有此特性。 $ set -C $ cat flip &gt;ttt.txt -bash: ttt.txt: cannot overwrite existing file $ cat flip &gt;| ttt.txt $ set +C 接下来讲 &lt;&lt; 一篇字符串。类似 PHP 语言的 &lt;&lt;&lt;功能 $ cat &gt;log1.txt &lt;&lt;EOF &gt; this is stdin character first! &gt; EOF 解释 第1行，&lt;&lt;EOF 表示下面另起一行，开始输入一篇字符，这篇字符直到其中一行为EOF截止。其中EOF可以换成你喜欢的字符串，一般采用大写，最好不要弄出特殊字符来。 第2行，就是输入的那篇字符。后面还可以输入很多。 第3行，输入EOF，表示这篇字符结束。 在bash中，&lt;&lt;和&lt;&lt;&lt;是特殊重定向符号。&lt;&lt;&lt; 表示的是其后字符串作为输入数据。 $ cat &lt;&lt;&lt; PATH 等价于 $ echo PATH | cat 一般情况下，重定向要么将信息输入到文件中，要么输出到屏幕上，但是既想输出到屏幕又想输出到文件就比较麻烦。使用tee的双重定向功能可以实现该想法。 tee [-a] file 选项说明： -a：默认是将输出覆盖到文件中，使用该选项将变为追加行为。 file：除了输出到标准输出中，还将输出到file中。如果file为“-”，则表示再输入一次到标准输出中。 例如下面的代码，将a开头的文件内容全部保存到b.log，同时把副本交给后面的的cat，使用这个cat又将内容保存到了x.log。其中“-”代表前面的stdin。 $ cat a* | tee b.log | cat - &gt;x.log 还可以直接输出到屏幕： $ cat a* | tee b.log | cat tee默认会使用覆盖的方式保存到文件，可以使用-a选项来追加到文件。如： $ cat a* | tee -a b.log | cat 8.4.3 重定向和管道的区别 管道命令与重定向区别 管道(|) 重定向(&gt;,&lt;) 左边命令应该做到标准输出，右边命令应该接受标准输入 左边的命令应该有标准输出(输入)，右边只能是文件 管道触发两个子进程执行|两边的程序 在一个进程内执行 $ cat test.sh| grep -n &#39;echo&#39; #“|”管道两边都必须是shell命令 $ grep -n &#39;echo&#39; &lt;test.sh #“重定向”符号，右边只能是文件 下面两个也是等同的。 $ (sed -n &#39;1,$p&#39;|grep -n &#39;echo&#39;)&lt;test.sh 这个脚本比较有意思了。由于前面是管道，后面需要把test.sh内容重定向到 sed ，然后sed输出通过管道，输入给grep.需要将前面用“()”运算符括起来。在单括号内的命令，可以把它们看作一个象一个命令样。如果不加括号test.sh就是grep 的输入了。 $ sed -n &#39;1,$p&#39;&lt;test.sh | grep -n &#39;echo&#39; 重定向运算符，在shell命令解析前，首先检查的（一个命令，执行前一定检查好它的输入，输出，也就是0,1,2 设备是否准备好），所以优先级会最高 $ sed -n &#39;1,10p&#39;&lt;test.sh | grep -n &#39;echo&#39; &lt;testsh.sh 哈哈，这个grep又接受管道输入，又有testsh.sh输入，那是不是2个都接收呢。刚才说了“&lt;”运算符会优先，管道还没有发送数据前，grep绑定了testsh.sh输入，这样sed命令输出就被抛弃了。这里一定要小心使用 下面是输出重定向例子。 $ cat test.sh&gt;test.txt $ cat test.sh|tee test.txt &amp;&gt;/dev/null 通过管道实现将结果存入文件,还需要借助命令tee，它会把管道过来标准输入写入文件test.txt ,然后将标准输入复制到标准输出(stdout),所以重定向到/dev/null 不显示输出。“&gt;”输出重定向，往往在命令最右边，接收左边命令的，输出结果，重定向到指定文件。也可以用到命令中间。 $ ls test.sh test1.sh testsh.sh 2&gt;err.txt | grep &#39;test&#39; 目录下面有：test,testsh文件，test1.sh不存在，因此将ls 命令错误输出输入到err.txt 正确输出，还会通过管道发送到grep命令。 $ ls test.sh test1.sh testsh.sh &amp;&gt;err.txt | grep &#39;test&#39; 这次打印结果是空，&amp;代表正确与错误输出 都输入给err.txt，通过管道继续往下面传递数据为空,所以没有什么显示的。 同样“&gt;”输出重定向符，优先级也是先解析，当一个命令有这个字符，它就会与左边命令标准输出绑定。准备好了这些，就等待命令执行输出数据，它就开始接收 从上面例子可以看，重定向与管道在使用时候很多时候可以通用，其实，在shell里面，经常是【条条大路通罗马】的。一般如果是命令间传递参数，还是管道的好，如果处理输出结果需要重定向到文件，还是用重定向输出比较好。 8.4.4 顺序执行 顺序执行，类似C语言的；语法。逐条执行命令。 $ date ; cat &lt;&lt;&lt; LONGLONGJOB | cat - ; date 2018年 09月 29日 星期六 17:16:12 CST LONGLONGJOB 2018年 09月 29日 星期六 17:16:12 CST 解释 本命令实现了对程序耗时的计算。而分号；的优先级是低于管道的。最终送给cat -中cat的只有LONGLONGJOB。 8.4.5 后台命令 有些命令比较耗时，或者其他原因，我们希望他们运行在后台。就可以用如下方式。 $ tar cf test.tar test &amp; [1] 9355 $ [1]+ 已完成 tar cf test.tar test 解释 第1行，命令末尾加&amp;即可让程序运行于后台。shell 会告诉该命令的进程号，示例中为9355；并且会为他编号。 第4行，命令运行介绍，shell 会告诉你已经完成了该后台命令。 在运行过程中，如果你不想让他终止，请不要关闭该 shell。 8.4.6 命令扩展 把命令输出结果作为另外一条命令的参数，也是常用的一项功能，可以用美元符号$和斜点（键盘左上角～键）`，$(command) 和 `command`。 $ vim -p $(find ~ | grep deepin-bible.tex) 解释 find ~查找主目录所有文件，grep deepin-bible.tex 从前者找到文件名包含deepin-bible.tex的所有文件，vim 把找到的所有文件打开。 8.4.7 简单数值计算 使用$[math expression]的方式计算。 $ echo &quot;我今年$[`date +%Y` - 1987]岁了。&quot; 我今年31岁了。 解释 `date +%Y`输出今年年数2018，$[2018 - 1987]输出岁数。 8.4.8 输出变量值 一些变量的数值，可以通过$Var输出。 $ echo $PATH 8.5 Shell 变量（Variables） 参考网页： https://blog.csdn.net/apollon_krj/article/details/70148022 变量分为全局变量(环境变量)和局部变量(本地变量) 。环境变量可以在定义它们的shell及其派生出来的任意子进程的shell中使用。局部变量只能在定义它们的函数/脚本中使用。还有一些变量是用户创建的，其他的则是专用的shell变量，比如系统变量$0等。 全局变量(环境变量) 环境变量可用于定义shell的运行环境，环境变量可以在配置文件中定义与修改，也可以在命令行中设置，但是命令行中的修改操作在终端重启时就会丢失，因此最好在配置文件中修改（用户家目录的“.bash_profile“文件或者全局配置“/etc/profile”、“/etc/bashrc”文件或者“/etc/profile.d”文件中定义。）将环境变量放在profile文件中，每次用户登录时这些变量值将被初始化。比如HOME、USER、SHELL、UID等再用户登录之前就已经被/bin/login程序设置好了。 摘自《Linux Bible》 常见环境变量表 变量 解释 BASH bash 命令的全路径地址，通常为 /bin/bash。 BASH_VERSION bash 版本号。 EUID 这是当前用户的有效用户ID号，Shell启动时分配，基于用户在 /etc/passwd 的分配。 FCEDIT 如果设置该变量，表示使用fc命令来编辑命令记录（history commands）；否则改用vi命令。 HISTFILE 命令记录文件，通常为 $HOME/.bash_history。 HISTFILESIZE 命令记录条数，当超过此数，循环记录，最久的记录被删除。默认值1000。 HISTCMD 返回当前命令处于命令记录的序号。 HOME 当前用户的主目录，也就是你登录后，或者输入cd回车跳到的文件夹。常用符号～表示主目录。 HOSTTYPE 当前计算机硬件体系，比如 Intel 兼容机，一般是 i386, i486, i586, i686, 或者 i386 等数值。对于AMD 64位机，一般是 x86_64。 MAIL 邮箱文件。深度普通用户一般都没有设置该变量，root用户一般为/var/mail/root。对于centos 系列一般为 /var/spool/mail/ OLDPWD 前一个工作目录。当你频繁在两个目录切换的时候，当前目录的前一个目录就存储在该变量。通常使用减号-表示。使用cd - 可以跳转到前一个目录。 OSTYPE 本机操作系统类型。比如linux或linux-gnu PATH 路径变量。一般为一长串字符，用英文冒号:拼接多个文件夹。Windows 系统也有该变量，只不过使用英文分号;拼接的。处于上述文件夹下的可执行文件，只需输入本文件名不用输入完整路径，即可被shell找到执行。shell是从前往后找的，重名可执行文件，需要注意执行的是不是自己的文件。不在PATH目录集合下的可执行文件，则需要输入绝对路径或者相对路径才可以执行。例如本机的root用户，PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin。 PPID 当前shell父进程ID号。 PROMPT_COMMAND 深度操作系统没有设置该变量。通常该变量为一条命令名称。在命令提示符（shell prompt）每次出现之前执行。 PS1 设置命令提示符。有时还会有PS2, PS3等。 PWD 当前工作目录。 RANDOM 返回 0 到 99999 的一个随机数。 SECONDS 返回当前shell启用了多少秒数。 SHLVL 这是与当前shell会话相关联的shell级别的数目。当您登录到shell时，SHLVL为1。每次你新开 bash，比如使用su或者键入bash，该数字都会加一。 TMOUT 深度操作系统没有设置该变量。设置一定秒数，如果 shell 在设定时间内没有输入，则退出。对于服务器来说，还是跟安全很相关的一个变量。 可以用echo来显示查看全局变量(eg：echo $HOME)。env(或printenv)、set也可以用来查看系统的环境变量，但不是单独查看。而用unset临时取消环境变量(eg:unset USER)，要永久生效还是要写到配置文件中 自定义环境变量(采用export)： export 变量名=value 变量名=value;export 变量名 declare -x 变量名=value 这里依旧是临时生效，在shell终端关闭后就消失了，写到配置文件中则永久生效(注意：写到配置文件中后需要运行一遍配置文件的脚本才可生效，否则等重启时生效) 命令行的三种方式测试如下： 关于环境变量PATH与export的更详细的内容，可参考： Linux环境变量与系统编程学习笔记 2、局部变量(本地变量)： 本地变量在用户当前的shell生存期的脚本中使用。在一个函数中将某个变量声明为local，则该变量就是一个局部变量，只在本函数中有效。 定义： 变量名=value 变量名=’value’ 变量名=”value” shell中变量名的要求：一般遵循字母、数字、下滑线组成，不能以数字开头 8.5.1 别名的创建和使用 为了方便，常会配置一些别名。 $ alias l=&#39;ls -CF&#39; $ alias la=&#39;ls -A&#39; $ alias rm=&#39;rm -i $ alias $ \\ls $ unalias la $ alias 解释 第1-3行，定义了三个别名。这些别名相当于后面的那个命令。 第4行，查看当前所有别名。 第5行，使用\\command表示，使用最原始的命令，非别名。 第6-7行，暂时取消别名la，然后查看当前所有的别名。这个unalias只可以在当前shell取消别名。 8.5.2 退出 shell 可以使用快捷键Ctrl+D，或者输入exit，或者直接点击窗口的关闭按钮。 8.6 定制 shell 环境 bash 的配置文件，一般如下表所示， Bash 配置文件说明 文件 解释 /etc/profile 影响所有用户，首次登录时执行。通常在此配置PATH，MAIL，HISTFILESIZE等。最后，该文件会读取/etc/profile.d 文件夹下其他 shell 配置文件。 /etc/bashrc 影响所有 bash 用户，每次打开 bash 都会执行。通常在此配置提示（prompt） PS1和一些别名。变量设置会被用户自己的 ～/.bashrc覆盖。 ~/.bash_profile 只影响该用户，首次登录时执行。一般存放环境变量，并会调用～/.bashrc文件，特别适合放置环境变量。 ~/.bashrc 只影响该用户，每次打开 bash 都会执行。存放一些自己的配置，特别适合放置别名。 ~/.bash_logout 只影响该用户，每次注销（退出最后一个shell时）执行。通常只有清屏功能。 一般，修改/etc/profile,/etc/bashrc需要root权限，而且影响所有用户。后面三个文件，只影响本用户。 编辑好这些文件，需要执行才可以生效。 $ gedit $HOME/.bashrc #编辑文件 $ source $HOME/.bashrc #执行生效 8.6.1 配置提示（prompt） 参考网页： https://www.cnblogs.com/lienhua34/p/5018119.html http://billie66.github.io/TLCL/book/chap14.html Linux系统终端提示符,就是在前面8.2提到的$或者#之前的文字。是通过环境变量PS1，PS2，PS3，PS4配置的。一般都是配置系统环境变量PS1（是prompt string one的简写）定义。通过命令echo $PS1查看当前设置。 $ echo $PS1 \\[\\e]0;\\u@\\h: \\w\\a\\]${debian_chroot:+($debian_chroot)}\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w\\[\\033[00m\\]$\\setminus\\$$ 1、基本转义字符 PS1的值由一系列静态文本或\\和转义字符序列组成。示例， $ PS1=&quot;\\u@\\H \\w$ &quot; Shell 提示符中用到的转义字符 序列 显示值 \\a 以 ASCII 格式编码的铃声。当遇到这个转义序列时，计算机会发出嗡嗡的响声。 \\d 以日，月，天格式来表示当前日期。例如，“Mon May 26” \\h 本地机的主机名，但不带末尾的域名。 \\H 完整的主机名。 \\j 运行在当前 shell 会话中的工作数。 \\l 当前终端设备名。 \\n 一个换行符。 \\r 一个回车符。 \\s shell 程序名。 \\t 以24小时制，hours:minutes:seconds 的格式表示当前时间。 \\T 以12小时制表示当前时间。 \\@ 以12小时制，AM/PM 格式来表示当前时间，例如“10:51 PM”。 \\A 以24小时制，hours:minutes 格式表示当前时间。 \\u 当前用户名。 \\v shell 程序的版本号，例如4.3。 \\V shell 程序的版本号，例如4.3.11。 \\w 当前工作目录名。 \\W 当前工作目录名的最后部分。 \\! 当前命令的历史号。 \\# 当前 shell 会话中的命令数。 \\$ 这会显示一个$字符，除非你拥有超级用户权限。在那种情况下， 它会显示一个#字符。 \\[ 标志着一系列一个或多个非打印字符的开始。这被用来嵌入非打印的控制字符，这些字符以某种方式来操作终端仿真器，比方说移动光标或者是更改文本颜色。 \\] 标志着非打印字符序列结束。 2、字体颜色 上面能够满足我们的效果了，但是相对于LinuxMint原始的提示符，缺少了颜色，不太美观。下面我们来学习如何添加颜色。大多数终端仿真器程序支持一定的非打印字符序列来控制，比方说字符属性（像颜色，黑体和可怕的闪烁） 和光标位置。 字体颜色是由一个ANSI 转义编码来控制的。该控制编码会嵌入字符流中并发送给终端仿真器。但是，该控制编码不会被“打印”到屏幕上，而是会被终端解释为一个指令。正如我们在上表看到的字符序列，这个\\[和\\]序列被用来封装这些非打印字符。一个 ANSI 转义编码以一个八进制033（这个编码是由退出按键产生的）开头，其后跟着一个可选的字符属性（0：正常、1：黑体、4：下划线、5：闪烁、7：反向（前景色和背景色反转）），在之后是一个指令。 用转义序列来设置文本颜色 序列 文本颜色 序列 文本颜色 \\033[0;30m 黑色 \\033[1;30m 深灰色 \\033[0;31m 红色 \\033[1;31m 浅红色 \\033[0;32m 绿色 \\033[1;32m 浅绿色 \\033[0;33m 棕色 \\033[1;33m 黄色 \\033[0;34m 蓝色 \\033[1;34m 浅蓝色 \\033[0;35m 粉红 \\033[1;35m 浅粉色 \\033[0;36m 青色 \\033[1;36m 浅青色 \\033[0;37m 浅灰色 \\033[1;37m 白色 例如我们来设置一个同LinuxMint默认的绿色提示符， $ PS1=&quot;\\[\\033[01;32m\\]\\u@\\W$\\setminus\\$$\\[\\033[00m\\] &quot; 于是，我们便有了下面的效果。 上面跟设置的提示符格式中的最后那个”\\[\\033[00m\\]”是用于将后续的字符颜色还原回原来的颜色。如果没有没有加最后这个转义码，则会出现下面结果（我们自己手工输入的命令也都将是绿色的）。 3、背景颜色 除了字体颜色，我们也可以设置字体的背景颜色。同样是通过转义的控制编码来实现，下表是背景颜色的控制编码。 用转义序列来设置背景颜色 序列 文本颜色 序列 文本颜色 \\033[0;40m 黑色 \\033[1;44m 蓝色 \\033[0;41m 红色 \\033[1;45m 粉红 \\033[0;42m 绿色 \\033[1;46m 青色 \\033[0;43m 棕色 \\033[1;47m 浅灰色 4、移动光标 转义编码也可以用来定位光标。这些编码通常被用来，每次当提示符出现的时候，会在屏幕的不同位置，比如说上面一个角落，显示一个时钟或者其它一些信息。下表是一系列用来定位光标的转义编码： 光标移动转义序列 转义编码 行动 \\033[l;cH 把光标移到第 l 行，第 c 列。 \\033[nA 把光标向上移动 n 行。 \\033[nB 把光标向下移动 n 行。 \\033[nC 把光标向前移动 n 个字符。 \\033[nD 把光标向后移动 n 个字符。 \\033[2J 清空屏幕，把光标移到左上角（第零行，第零列）。 \\033[K 清空从光标位置到当前行末的内容。 \\033[s 存储当前光标位置。 \\033[u 唤醒之前存储的光标位置。 有兴趣的可以试着配置一下，建议先备份，在配置到上面提到的配置文件里。 8.7 命令帮助 https://www.cnblogs.com/anliven/p/6030074.html Manual Page Chapter List 所有用户可以操作的指令或可执行文件 系统核心调用的函数与工具 子调用，常用的函数与函数库 设备，硬件文件说明，通常是/dev/的文件 文件格式，配置文件或者是某些档案的格式 游戏相关 杂项，例如linux文件系统、网络协议、ASCIIcode等说明 系统管理员可用的命令 跟kernel有关的文件 8.8 总结 本章整理了 shell 的一些基础知识，后面需要继续修改。 "],
["chap-filesystem.html", "9 文件系统 9.1 树形结构 9.2 文件系统常用命令 9.3 元字符和操作符 9.4 几个常用的目录 9.5 文件（夹）的权限和归属 9.6 文件（夹）的创建、查看、移动、复制和删除 9.7 总结", " 9 文件系统 通过阅读本章，你将会了解到以下几项内容。 了解文件系统 查看文件（夹）及属性 创建文件（夹） 查看设置文件（夹）权限和归属 文件（夹）的剪切复制粘贴删除和重命名 9.1 树形结构 参考网页： https://blog.csdn.net/mzl87/article/details/79673012 https://www.cnblogs.com/CoderJYF/p/6092604.html https://blog.csdn.net/fan0220/article/details/53079618 Linux系统目录结构图 常用文件夹说明。 / —— 根目录，一般根目录下只存放目录，不要存放文件。/etc、/bin、/dev、/lib、/sbin应该和根目录放置在一个分区中。 /bin —— 存放系统中最常用的二进制可执行文件（二进制文件）。基础系统所需要的那些命令位于此目录，也是最小系统所需要的命令；例如ls、cp、mkdir等命令。功能和/usr/bin类似，这个目录中的文件都是可执行的，普通用户都可以使用命令 /boot —— 存放Linux内核和系统启动文件，包括Grub、lilo启动程序 /dev —— 存放所有设备文件，包括硬盘、分区、键盘、鼠标、USB等 /etc —— 存放系统所有配置文件，例如passwd存放用户账户信息，hostname存放主机名等。/etc/fstab是开机自动挂载一些分区的，在里面写入一些分区信息，就能实现开机挂载分区 /home —— 用户目录的默认位置 /initrd —— 存放启动时挂载initrd.img映像文件的目录，以及载入所需设备模块的目录 /lib —— 存放共享的库文件，包含许多被/bin和/sbin中程序使用的库文件 /lost+found —— 在ext2或者ext3文件系统中，当系统意外崩溃或者计算机意外关机，而产生一些文件碎片存放在这里。当系统启动的过程中fsck工具会检查这里，并修复已经损坏的文件系统。有时系统发生问题，有很多的文件被移动到这个目录中，可能会用手工的方式来修复或移动到文件的原位置上 /media —— 即插即用型设备的挂载点自动在这个目录下创建。例如USB自动挂载后会在这个目录下产生一个目录；CDROM/DVD自动挂载后，也会在这个目录中创建一个目录，存放临时读入的文件 /mnt —— 此目录通常用于作为被挂载的文件系统的挂载点 /proc —— 存放所有标志为文件的进程，它们是通过进程号或其他的系统动态信息进行标识。例如CPU、硬盘分区、内存信息等存放在这里 /opt —— 作为可选文件和程序的存放目录。有些软件包也会被安装在这里，也就是自定义软件包；有些用户自己编译的软件包，就可以安装在这个目录中 /root —— 根用户（超级用户）的主目录 /sbin —— 大多是涉及系统管理的命令的存放地，也是超级权限用户root的可执行命令存放地。普通用户无权限执行这个目录下的命令，这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin目录是相似的。注意，凡是目录sbin中包含的都是root权限才能执行的 /srv —— 存放系统所提供的服务数据 /sys —— 该目录用于将系统设备组织或层次结构，并向用户提供详细的内核数据信息 /tmp —— 临时文件目录，有时用户运行程序的时候，会产生临时文件。/var/tmp目录和这个目录相似 /usr —— 用于存放与系统用户直接有关的文件和目录，如应用程序及支出系统的库文件 /usr/X11R6 —— X Window系统 /usr/bin —— 用户管理员的标准命令 /usr/include —— C/C++等开发工具语言环境的标准include文件 /usr/lib —— 应用程序及程序报的链接库 /usr/local —— 系统管理员安装的应用程序 /usr/local/share —— 系统管理员安装的共享文件 /usr/sbin —— 用户和管理员的标准命令 /usr/share —— 存放使用手册等共享文件的地方 /usr/share/dict —— 存放词表的目录 /usr/share/man —— 系统使用手册 /usr/share/misc —— 一般数据 /usr/share/sgml —— SGML数据 /usr/share/xml —— XML数据 /var —— 通常用于存放长度可变的文件，例如日志文件和打印机文件 /var/cache —— 应用程序缓存目录 /var/crash —— 系统错误信息 /var/games —— 游戏数据 /var/lib —— 各种状态数据 /var/lock —— 文件锁定记录 /var/log —— 日志记录 /var/mail —— 电子邮件 /var/opt —— /opt目录的变量数据 /var/run —— 进程的标示数据 /var/spool —— 存放电子邮件，打印任务等的队列目录 /var/tmp —— 临时文件目录 9.2 文件系统常用命令 文件系统常用命令 命令 解释 cd 改变目录 pwd 显示当前目录 mkdir 创建文件夹 chmod 修改文件（夹）权限 ls 列出文件夹内容 下面给出几个简单例子。 $ cd $ cd ~ $ cd /usr/local/bin $ cd - $ cd .. $ pwd 解释 cd 输入不带参数，默认是回到自己的主目录，也即~目录，第一行第二行效果是一样的。 cd 输入带一个目录，则跳转到该目录，如果你没有权限，则跳转失败。 -短横线表示上一个目录，也就是旧目录，方便你在两个目录之间切换。 cd 输入的目录支持相对路径和绝对路径。..表示上级目录或者叫父目录，.表示当前目录，对于/根目录，其父目录就是他本身。 pwd打印当前目录。 $ cd $ mkdir dir1 $ mkdir -p dir2/dir22 $ ls -ld dir1 drwxr-xr-x 2 litianci litianci 4096 10月 31 22:24 dir1 $ chmod o-rx dir1 $ touch dir1 $ ls -ld dir1 drwxr-x--- 2 litianci litianci 4096 10月 31 23:22 dir1 解释 cd 到主目录。使用mkdir新建一个文件夹。如果你想创建嵌套的文件夹，或者多层文件夹，可以使用mkdir -p选项，这样就可以建立多层文件夹。 ls -ld dir1，-d选项，表示只显示文件夹本身，-l是列出详细信息。drwxr-xr-x表示：d该文件是个文件夹，rwxr-xr-x是该文件夹的权限。见后面详述。2表示其内部有2个子文件（夹），从上面的命令可以知道其实dir1是一个空文件夹，怎么会有两个子文件（夹）呢，其实是隐藏的..和.文件夹。你可以使用 ls -la dir1看到这连个文件夹。后面依次为本文件（夹）的用户、用户组、文件大小，修改日期和时间。最后是本文件名称。 使用chmod命令，去除其他用户的读和执行权限（-rx） 使用touch命令，修改dir1的修改日期。 再次使用ls -ld dir1命令，会发现相关的数值发生了变化。 9.3 元字符和操作符 古人云物以类聚，人以群分。我们操作文件（夹）的时候，可能就需要批量操作。这个时候我们就可以这些文件（夹）归类，其实就是使用元字符表示某一类文件（夹）。这样操作起来更方便。 如果说元字符是对文件夹分类，那么操作符就是对操作按照一定的规则拼接。 9.3.1 元字符 常用的元字符有如下三种方式。 * 匹配任意数目的字符，跟正则表达式的*有所区别。 ? 匹配一个字符，一个汉字也是作为一个字符。 [...] 匹配[]内的任意一个字符，支持短横线-表示连续的字符。一个汉字也是作为一个字符。 看下面例子， $ mkdir test $ cd test $ touch huawei huashuo 华为 华硕 深度 深不可测 $ ls h* huashuo huawei $ ls 华* 华硕 华为 $ ls 深*测 深不可测 解释 第1-3行，创建空的文件夹test，并转到该文件夹，创建了huawei等六个文件。 第4、6、8行，使用元字符*表示任意数目的字符，分别显示了匹配相关”分类“的文件。 下面紧接着上面的shell环境，继续例子， $ ls h????? huawei $ ls 华? 华硕 华为 $ ls 深? 深度 解释 第1行，可以看出每个?代表一个字符。 第3、5行，可以看出一个汉字算作一个字符。 下面我们看看[...]相关的例子， $ touch auawei buawei cuawei duawei $ ls [ah]uawei auawei huawei $ ls [a-dh]uawei auawei buawei cuawei duawei huawei $ ls [a-dh]u* auawei buawei cuawei duawei huashuo huawei 解释 第1行，为了方便演示，我新建了四个文件。 第2行，[ah]uawei表示，a和h任选一个，后面紧挨着uawei。匹配的字符见第3行显示结果。 第4行，我们可以看出短横线-的意思，表示一个序列。也支持数字的连续显示，但是只支持个位数，是否如此请核实。 第6行，其实这些元字符可以配合使用。 9.3.2 操作符 本节内容见第8.4.2小节。本节从略。 9.3.3 花括号{} 第@ref(filesystem:metachar)小节提到的均为归类，前提是筛选，选择已经存在的事物，对已有的事情分类（是否如此请核实）。如果你想创建一个集合，可以选择花括号{}的方式，列出所有相关的元素。 $ touch deepin{1,2,3,4} $ ls deepin* deepin1 deepin2 deepin3 deepin4 $ rm ./* $ touch {deepin,深度}-{5,6,7,8} $ ls deepin-5 deepin-6 deepin-7 deepin-8 深度-5 深度-6 深度-7 深度-8 $ rm {deepin,深度}-{5,6,7,8} $ ls $ touch {a..e}{1..3} $ ls a1 a2 a3 b1 b2 b3 c1 c2 c3 d1 d2 d3 e1 e2 e3 $ rm ./* $ touch {A..a} touch: 无法创建&#39;&#39;: 没有那个文件或目录 $ ls &#39;`&#39; _ ] A C E G I K M O Q S U W Y &#39;^&#39; &#39;[&#39; a B D F H J L N P R T V X Z $ rm ./* $ touch {aa..ac} $ ls {aa..ac} $ rm ./* $ touch {11..21} $ ls 11 12 13 14 15 16 17 18 19 20 21 $ rm ./* $ touch {33..22} $ touch {z..b} 解释 第1行，创建了deepin开头，以后面集合元素结尾的文件。 第5行，集合拼接在一起，类似于笛卡尔积的形式组合起来。 第10行，对于单字母支持序列功能，多字母则不支持。对于数字支持序列功能。按照ASCII码排序，从A到a包含不显示的字符，影响最终的显示。 最后两行，没有显示结果，有兴趣的读者可以使用ls看看结果。 9.4 几个常用的目录 $HOME 主目录 ~ 波浪线，位于键盘左上角第二行开头的那个键（按下的时候需要按shift键），也是表示主目录，为了跳转到其他人的主目录，也可用使用~&lt;username&gt;的方式。比如跳转到litianci的主目录，cd ~litianci - 或者 $OLDPWD,表示上一个目录，这个是短横线，不是减号。如果你在两个目录之间切换的话，cd -方便你跳转，如果你还没有切换目录，跳转到旧目录则会报错。-还有其他的功能，比如放权当前环境切换到新用户，sudo su -，这个命令就是不管你现在处于什么目录，切换到root根用户，且工作目录为root根用户的主目录。 . 或 $PWD 当前工作目录。这两者是否有区别，待查。 .. 上级目录，也即父目录。对于/根目录而言，..和.都表示本级目录。 9.5 文件（夹）的权限和归属 Linux 是多用户的系统，为了在一定程度上保护数据隐私，对文件（夹）进行简单的权限控制。这也是你输入命令或者做其他事情的时候会遇到的没有权限问题的根源，甚至部分用户喜欢用root根用户操作，也是因为权限控制造成的某些不方便。为了更好的用权，也为了数据的安全，还请能用普通用户的情况下，尽量少用root根用户操作。下面对权限进行简要介绍。 对于一个文件（夹）来说，他一定归属于某个用户，且归属于某个用户组。也一定有其他不属于前两者的用户，简称其他用户，有时候也想访问该文件（夹）。那么这个权限就是针对这三类人来设定的。当然，由于某些用户（组）被删除等，造成文件（夹）归属的用户（组）不存在了，这些就是无主文件（夹），这也是存在安全隐患的。在下章内容会讲述通过find命令查找此类无主文件（夹）的方法，可以采用相关方法，重新赋予其归属用户（组）或者删除等，这里就不叙述了。 9.5.1 权限简介 参考网页： https://blog.csdn.net/zhao12795969/article/details/53448039 针对这三类用户，权限又可以分为读（Read）、写（Write）和执行（eXecute）三类。 r(Read，读取)：对文件而言，具有读取文件内容的权限；对目录来说，具有浏览目录的权限。 w(Write,写入)：对文件而言，具有新增,修改,删除文件内容的权限；对目录来说，具有新建，删除，修改，移动目录内文件的权限。 x(eXecute，执行)：对文件而言，具有执行文件的权限；对目录了来说该用户具有进入目录的权限。 注意 目录的只读访问不允许使用cd进入目录，必须要有执行的权限才能进入。 只有执行权限只能进入目录，不能看到目录下的内容，要想看到目录下的文件名和目录名，需要可读权限。 一个文件能不能被删除，主要看该文件所在的目录对用户是否具有写权限，如果目录对用户没有写权限，则该目录下的所有文件都不能被删除，文件所有者除外。 目录的w位不设置，即使你拥有目录中某文件的w权限也不能写该文件。 以上仅限于 ext3/4等文件系统的文件。对于安装windows10双系统的电脑，还需要注意是否windows10开启电源保护模式，哪怕你是ext4格式，依旧为只读，无法更改文件。 每个文件属于一个用户和一个组。命令ls -l可以查看用户和组，比如， $ ls -l /bin/bash -rwxr-xr-x 1 root root 1111240 5月 13 2018 /bin/bash 第二行为输出结果，表明 /bin/bash 属于 root 用户， root 组。ls -l 命令的第一个字段 -rwxr-xr-x 包含/bin/bash的权限的符号表示。该字段中的首字符（-）指定该文件的类型，本例中它是一个常规文件。可能的首字符如下： - 普通文件 d 目录 l 符号链接 c 字符专门设备文件 b 块专门设备文件 p 先进先出 s 套接字 首字符后紧接着三个三元组rwx，r-x，r-x，第一个三元字符组代表文件所有者的权限，第二个代表文件的所属组的权限，第三个代表其他用户的权限。但是 root 用户，往往会被跳过这些权限检查（待核实）。 9.5.2 权限更改chmod chmod 用于更改 rwx 权限，带有两个或多个参数：mode，描述怎样改变权限，后面跟将会受到影响的文件或文件列表： $ chmod +x bashscript 上例+x表示对bashscript的三类人员（拥有者、拥有组和其他人）均增加可执行权限。如果我们想要除去一个文件的所有执行权限， $ chmod -x bashscript 为了更精细的控制权限，比如只修改部分人员权限，需要在+-符号前加上这部分人员的代号。a表示所有人员，u表示拥有者，g表示拥有组，o表示其他人员。这些代号可以合用。比如下面这行命令表示组和其他人员去除读写权限增加执行权限。 $ chmod go-rw+x bashscript 对于权限，除了+-外，还可以使用等号=，表示只保留这些权限，未涉及的权限全部取消，有例外，见下文。 $ chmod =rx bashscript 注意 使用+-=改变权限的时候，最好在前面加上相关人员的代号，比如a,u，g,o的组合，否则，可能跟你预期的结果不一样。 $ chmod a-rwx bashscript $ chmod +rwx bashscript # + 不一定跟你期望的一样 $ ls -l bashscript # rwxr-xr-x $ chmod a-rwx bashscript $ chmod a+rwx bashscript $ ls -l bashscript # rwxrwxrwx $ chmod -rwx bashscript # - 不一定跟你期望的一样 $ ls -l bashscript # ----w--w- $ chmod a-rwx bashscript $ ls -l bashscript # --------- $ chmod =rwx bashscript $ ls -l bashscript # rwxr-xr-x 以上是因为存在权限掩码umask这个参数，在终端输入umask回车，输出本机umask=0022,怎么是数字呢？这是因为权限也可用用数字表示，关于权限掩码umask在后面详述。 数字形式的权限，使用4位八进制数，每一位代表一个权限三元组。例如，在 1777 中，777 设置本章我们所讨论的owner、group和other标志。1 用来设置专门的权限位，稍后再讲。这个图表说明了怎样解释第二到 ： 字符形式权限和数字形式权限对照表 字符 数字 字符 数字 字符 数字 字符 数字 rwx 7 rw- 6 r-x 5 r-- 4 -wx 3 -w- 2 --x 1 --- 0 采用数字形式的权限管理方法，比如， $ chmod 0755 bashscript $ ls -l bashscript -rwxr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript 就实现跟字符形式等同的权限设置。 9.5.3 权限掩码umask 当进程创建了新文件时，它指定新文件应该具有的权限。通常，所请求的模式是 0666（每个人可读和可写），它比我们希望的具有更多的权限。幸运的是，不管什么时候创建了新文件，Linux 将参考叫做权限掩码umask的东西。系统用umask值来将初始指定的权限降低为更合理、更安全的权限。您可以通过在命令行中输入umask来查看您当前的umask设置， $ umask 0022 Linux 系统上，umask 的缺省值一般为 0022，它允许其他人读您的新文件（如果他们可以得到它们），但是不能进行修改。为了在缺省的情况下使新文件更安全，您可以改变 umask 设置， $ umask 0077 $ touch newfile # 新建一个文件 $ ls -l newfile -rw------- 1 litianci litianci 0 11月 21 18:39 newfile umask 将确保组和其他用户对于新创建的文件绝对没有任何权限。参阅上方的《字符形式权限和数字形式权限对照表》，当umask=0077时，对应字符形式权限为 ---rwxrwx。而新建文件的请求权限为0666（rw-rw-rw-），禁用掉0077后，就剩上方显示的rw-------权限了。 9.5.3.1 suid 和 sgid 当您最初登录时，将启动一个新的 shell 进程。这个新的 shell 进程（通常是 bash）使用您的用户标识运行，可以访问所有属于您的文件（夹）。您启动的程序继承了您的用户标识，因此它们不能访问任何不允许您访问的文件系统对象。例如，一般用户不能直接修改 /etc/passwd 文件，因为write标志已经对除root 用户以外的每个用户关闭， $ ls -l /etc/passwd -rw-r--r-- 1 root root 2438 11月 21 15:54 /etc/passwd 但是，一般用户确实需要在他们需要改变其密码的任何时候，能够修改 /etc/passwd（至少间接地）。但是，如果用户不能修改该文件，究竟怎样完成这个工作呢？ 幸好，Linux 权限模型有两个专门的位，叫做suid和sgid。当设置了一个可执行程序的suid这一位时，它将代表可执行文件的所有者运行，而不是代表启动程序的人运行。现在回到上面这个问题。查看 /usr/bin/passwd 可执行文件， $ ls -l /usr/bin/passwd -rwsr-xr-x 1 root root 59640 9月 28 2017 /usr/bin/passwd 您还将注意到，这里有一个 s 取替了用户权限三元组中的一个 x。这表明，对于这个特殊程序，设置了 suid 和可执行位。由于这个原因，当 /usr/bin/passwd 运行时，它将代表 root 用户执行（具有完全超级用户访问权），而不是代表运行它的用户运行。又因为 /usr/bin/passwd 以 root 用户访问权运行，所以能够修改 /etc/passwd 文件，而没有什么问题。 我们看到了 suid 怎样工作，sgid 以同样的方式工作。它允许程序继承程序的组所有权，而不是当前用户的组所有权。 这里有一些关于 suid 和 sgid 的其它的但是很重要的信息。 首先，suid 和 sgid 分别占据与 ls -l 清单中用户u和用户组g的执行x位。如果设置了 x 位为可执行，则相应的位表示为 s（小写）否则为 S（大写）。 其次，在许多环境中，suid 和 sgid 很管用，但是不恰当地使用这些位可能使系统的安全遭到破坏。最好尽可能地少用suid程序。/usr/bin/passwd 命令是为数不多的必须使用suid的命令之一。 设置和除去 suid 与 sgid 位相当简单。这里，我们设置 suid 位： $ ls -l bashscript -rwxr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript $ chmod u+s bashscript $ ls -l bashscript -rwsr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript $ chmod u-x bashscript $ ls -l bashscript -rwSr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript $ chmod g+s bashscript $ ls -l bashscript -rwSr-sr-x 1 litianci litianci 119 11月 17 22:32 bashscript $ chmod g-s bashscript $ ls -l bashscript -rwSr-xr-x 1 litianci litianci 119 11月 17 22:32 bashscript 权限和目到此为止，我们从常规文件的角度来看权限。当从目录的角度看权限时，情况有一点不同。目录使用同样的权限标志，但是它们被解释为表示略微不同的含义。 对于一个目录，如果设置了read标志，您可以列出目录的内容；write表示您可以在目录中创建文件，execute表示您可以进入该目录并访问内部的任何子目录。没有execute标志，目录内的文件系统对象是不可访问的。没有read标志，目录内的文件系统对象是不可查看的，但是只要有人知道磁盘上对象的完整路径，就仍然可以访问目录内的对象。 如果启用了目录的sgid标志，在目录内创建的任何文件系统对象将继承目录的组。当您需要创建一个属于同一组的一组人使用的目录树时，这种特殊的功能很管用。只需要这样做， $ mkdir -p /media/litianci/data/groupspace $ sudo chgrp mygroup /media/litianci/data/groupspace $ chmod g+s /media/litianci/data/groupspace 现在，mygroup 组中的所有用户都可以在 /media/litianci/data/groupspace 内创建文件或目录，同样，他们也将自动地分配到 mygroup 的组所有权。根据用户的 umask 设置，新文件系统对象对于 mygroup 组的其他成员来说，可以或不可以是可读、可写或可执行的。 9.5.3.2 目录和删除 缺省情况下，Linux 目录以一种不是在所有情况下都很理想的方式表现。一般来说，只要对一个目录有写访问权，任何人都可以重命名或删除该目录中的文件。对于个别用户使用的目录，这种行为是很合理的。 但是，对于很多用户使用的目录来说，尤其是 /tmp 和 /var/tmp，这种行为可能会产生麻烦。因为任何人都可以写这些目录，任何人都可以删除或重命名任何其他人的文件——即使是不属于他们的！显然，当任何其他用户在任何时候都可以输入rm -rf /tmp/*并损坏每个人的文件时，很难在 /tmp 存放任何有意义的文件。 所幸，Linux 提供了粘滞位（sticky bit）的东西。当给 /tmp 设置了粘滞位（用chmod +t），唯一能够删除或重命名 /tmp 中文件的是该目录的所有者（通常是 root 用户）、文件的所有者或 root 用户。事实上，所有 Linux 分发包都缺省地启用了 /tmp 的粘滞位，而您还可以发现粘滞位在其它情况下也很管用。很显然，粘滞位是属于其他类型人员的权限，跟suid,sgid一样，占据的也是权限三元组的x位，小写是设置了执行权限，大写是禁用了执行权限。所不同的是他们分别占据u,g，o的x位。 $ ls -dl /tmp drwxrwxrwt 15 root root 4096 11月 22 10:19 /tmp $ sudo chmod o-x /tmp $ ls -dl /tmp drwxrwxrwT 16 root root 4096 11月 22 10:25 /tmp 9.5.3.3 数字形式权限的第一位数字 现在我们回过头来看数字权限的第一位数字的意思，这也是一个八进制数字，0-7，转化为三位的二进制数，从高位到低位，分别表示suid,sgid,sticky。当设置该权限时为1，禁用该权限时为0。比如，3就表示，禁用suid,启用sgid,sticky。看下面例子。 $ chmod 1777 bashscript $ ls -l bashscript -rwxrwxrwt 1 litianci litianci 119 11月 17 22:32 bashscript $ chmod 2777 bashscript $ ls -l bashscript -rwxrwsrwx 1 litianci litianci 119 11月 17 22:32 bashscript $ chmod 4777 bashscript $ ls -l bashscript -rwsrwxrwx 1 litianci litianci 119 11月 17 22:32 bashscript 9.5.4 归属 参考网页： https://www.cnblogs.com/DawaTech/p/7249734.html 语法结构如下， chgrp 组名 文件（夹） -R chown 用户名 文件（夹） -R 其中chgrp表示改变组名；chown表示改变用户名；-R表示递归目录下所有文件，可略。更改所属用户和所属组常常需要根用户权限。 9.5.4.1 修改文件所属组群chgrp chgrp，就是change group的缩写（我们可以利用这些来记忆命令）。看例子， [litianci]$ sudo groupadd groupa # 增加组 groupa [litianci]$ sudo groupadd groupb # 增加组 groupb [litianci]$ sudo useradd -g groupa deepin -m # 新增用户 deepin，默认组 groupa,自带主目录 [litianci]$ sudo su - deepin # 切换到 deepin 用户，- 表示不保存当前任何环境变量 [deepin]$ touch filea fileb # 创建两个文件 [deepin]$ ls -l -rw-r--r-- 1 deepin groupa 0 11月 21 15:55 filea -rw-r--r-- 1 deepin groupa 0 11月 21 15:55 fileb [deepin]$ exit [litianci]$ sudo chgrp groupb ~deepin/filea # 改变filea所属群组 [litianci]$ sudo ls -l ~deepin/ -rw-r--r-- 1 deepin groupb 0 11月 21 15:55 filea -rw-r--r-- 1 deepin groupa 0 11月 21 15:55 fileb 由于新增用户权限的问题，后面使用其他用户（ls -l）访问文件的属性。执行命令的用户放在每行命令的开头了。 9.5.4.2 修改文件拥有者chown chown，即change owner改变归属用户。chown功能很多，不仅仅能更改文件拥有者，还可以修改文件所属组群。如果需要将某一目录下的所有文件都改变其拥有者，可以使用-R参数。 语法结构如下， chown [-R] 账号名称 文件/目录 chown [-R] 账号名称:组群 文件/目录 下面简单示例， $ touch demo $ ls -l demo -rw-r--r-- 1 litianci litianci 0 11月 21 16:13 demo $ sudo chown deepin demo # 修改文件 demo 的拥有者为 deepin $ ls -l demo -rw-r--r-- 1 deepin litianci 0 11月 21 16:13 demo $ sudo chown deepin:groupa demo # 修改 demo 的拥有者为 deepin，拥有组 groupa -rw-r--r-- 1 deepin groupa 0 11月 21 16:13 demo 9.6 文件（夹）的创建、查看、移动、复制和删除 有点类似数据库的增删改查（CRUD,Create,Read,Update,Delete），这里只提到了文件（夹）的创建、查看、移动（包括重命名）、复制和删除。修改涉及到文件的权限以及日期等等内容，这里略过不提。 9.6.1 文件（夹）的创建 对于文件夹的创建，常用mkdir这个命令。具体方法，前面已经讲解了。对于文件的创建，通常使用touch创建文件，通过man touch可以看出，一般情况，touch只是对访问和更改的时间戳重置为当前时间戳，创建文件只是附带功能。另外一般的编辑器，还有其他文件都有新建保存功能，这样也可用创建文件。这里就不详细介绍了。 9.6.2 文件（夹）的查看 对于文件的内容查看，可以通过各种阅读器或者编辑器等，根据文件的类型做出不同选择。因为Unix哲学奉行一切皆文件，编辑器是一种比较常见的查看方式，这个见第10章。 文件（夹）的查看，通常采用深度文件管理器。对于其属性，可以通过深度文件管理器右击找到属性来查看。当然在命令行下ls也是一个非常强大的存在。看下面的例子。 $ ls $ ls -la $ ls -lR 解释 ls的选项-a表示把当前包含隐藏文件（夹）在内的所有文件（夹）显示出来。 -R选项是递归显示，可以把各个子文件夹的内容也显示出来。-l的显示内容，见上面章节说明。更多内容，可以查看man ls。 ### 文件（夹）的移动及重命名 文件（夹）的移动和重命名是通过mv命令实现的。 $ mv litianci deepin $ mv deepin ~ $ mv test1 test2 test3 ~ $ mv ~/deepin-bible/ ~/test/ $ mv ~/Desktop/* ~/test/ 解释 第1行，对文件litianci重命名为 deepin。mv重命名时，不区分文件夹或文件。 第2行，把文件 deepin移动到~文件夹。 第3行，mv支持多个文件同时移动到最后面一个文件夹。请注意，当多个文件（夹）同时移动时，最后一个必须是文件夹或指向文件夹的链接。 第4行，把文件夹deepin-bible文件夹，包括文件夹的内容（含隐藏内容），移动到~/test/文件夹。 第5行，只是把文件夹Desktop内的非隐藏内容，移动到~/test/文件夹。 注意，默认的mv，对于重名冲突是直接覆盖的。如果想不被覆盖，建议在~/.bashrc内加上alias mv='mv -i'，遇到这类的问题的时候，就会征询你的意见再决定要不要覆盖。 9.6.3 文件（夹）的复制 $ cp litianci deepin $ cp deepin ~ $ cp test1 test2 test3 ~ $ cp -r ~/deepin-bible/ ~/test/ $ cp -ra ~/Desktop/* ~/test/ 解释 第1-3行，类似mv命令，实现对文件的复制，不含文件夹的复制。 第4行，对于文件夹的复制，需要带-r选项，递归（recursive）的意思。 第5行，复制-a选项，表示复制后的文件（夹）各时间戳和权限跟原文件（夹）一样。 9.6.4 文件（夹）的删除 $ rm deepin $ rm ./- $ rm * $ rmdir /home/joe/nothing/ $ rm -r /home/joe/bigdir/ $ rm -rf /home/joe/hugedir/ $ sudo rm -rf / #千万不要试运行 解释 第1行，普通文件可以直接删除。不支持文件夹直接删除。如果要删除文件夹见第4-6行。 第2行，对于特殊文件，比如-，一般写绝对路径。 第3行，*一般代表的都是非隐藏文件（夹）。没有-r递归选项，也可用删除当前文件夹下的所有非隐藏内容。 第4行，删除文件夹的命令rmdir，删除了nothing文件夹及其内容。 第5-6行，-r表示递归，可以使用rm删除文件夹。-f是强制删除，实际是不用询问直接删除，对于没有权限删除的，依旧无法删除。 第7行，千万不要试运行。但是有时候为了删除本文件夹下的内容，往往错输。 我的建议是alias rm='trash-put'，把删除改为放置到回收站。具体做法见附录E。 9.7 总结 本章介绍了Linux操作系统的文件结构，并对文件的权限和归属情况进行了介绍，最后对文件的改动复制等作了简要介绍。 "],
["chap-vim-find.html", "10 文件编辑与查找 10.1 字符集和字符编码 10.2 编辑器 10.3 文件查找 10.4 总结", " 10 文件编辑与查找 通过阅读本章，你将会了解到以下几项内容。 字符集和字符编码 编辑器简介 文件查找 10.1 字符集和字符编码 参考网页： https://baike.baidu.com/item/%E5%AD%97%E7%AC%A6%E9%9B%86/946585?fr=aladdin https://www.cnblogs.com/happyday56/p/4135845.html https://linux.cn/article-7959-1.html 提到文本文件，不得不说文件的字符集，对于英文世界，ASCII码足够他们玩耍的了，但是对于中文，我们还需要中文字符集，不然就会显示很多框框或者乱码等。 字符(Character)是各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等。字符集(Character set)是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：ASCII字符集、GB2312字符集、BIG5字符集、 GB18030字符集、Unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。中文文字数目大，而且还分为简体中文和繁体中文两种不同书写规则的文字，而计算机最初是按英语单字节字符设计的，因此，对中文字符进行编码，是中文信息交流的技术基础。 10.1.1 ASCII ASCII（American Standard Code for Information Interchange，美国信息互换标准编码）是基于罗马字母表的一套电脑编码系统。 特点 它主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO 646。 包含内容 控制字符：回车键、退格、换行键等。 可显示字符：英文大小写字符、阿拉伯数字和西文符号。 技术特征 7位（bits）表示一个字符，共128字符，字符值从0到127，其中32到126是可打印字符。 扩展字符集 7位编码的字符集只能支持128个字符，为了表示更多的欧洲常用字符对ASCII进行了扩展，ASCII扩展字符集使用8位（bits）表示一个字符，共256字符，增加了表格符号、计算符号、希腊字母和特殊的拉丁符号。 10.1.2 GB2312 GB2312又称为GB2312-80字符集，全称为《信息交换用汉字编码字符集·基本集》，由原中国国家标准总局发布，1981年5月1日实施,是中国国家标准的简体中文字符集。 它所收录的汉字已经覆盖99.75%的使用频率，基本满足了汉字的计算机处理需要。在中国大陆和新加坡获广泛使用。 包含内容 GB2312收录简化汉字及一般符号、序号、数字、拉丁字母、日文假名、希腊字母、俄文字母、汉语拼音符号、汉语注音字母，共 7445 个图形字符。其中包括6763个汉字，其中一级汉字3755个，二级汉字3008个；包括拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母在内的682个全角字符。 技术特征 （1）分区表示： GB2312中对所收汉字进行了分区处理，每区含有94个汉字/符号。这种表示方式也称为区位码。 各区包含的字符如下：01-09区为特殊符号；16-55区为一级汉字，按拼音排序；56-87区为二级汉字，按部首/笔画排序；10-15区及88-94区则未有编码。 （2）双字节表示 两个字节中前面的字节为第一字节，后面的字节为第二字节。习惯上称第一字节为高字节，而称第二字节为低字节。 高位字节使用了0xA1-0xF7(把01-87区的区号加上0xA0)，低位字节使用了0xA1-0xFE(把01-94加上0xA0)。 以GB2312字符集的第一个汉字啊字为例，它的区号16，位号01，则区位码是1601，在大多数计算机程序中，高字节和低字节分别加0xA0得到程序的汉字处理编码0xB0A1。计算公式是：0xB0=0xA0+16, 0xA1=0xA0+1。 10.1.3 GBK字符集 GBK编码(Chinese Internal Code Specification)是中国大陆制订的、等同于UCS的新的中文编码扩展国家标准。gbk编码能够用来同时表示繁体字和简体字，而gb2312只 能表示简体字，gbk是兼容gb2312编码的。GBK工作小组于1995年10月，同年12月完成GBK规范。该编码标准兼容GB2312，共收录汉字 21003个、符号883个，并提供1894个造字码位，简、繁体字融于一库。Windows95/98简体中文版的字库表层编码就采用的是GBK，通过 GBK与UCS之间一一对应的码表与底层字库联系。 英文名：Chinese Internal Code Specification 中文名：汉字内码扩展规范1.0版 双字节编码，GB2312-80的扩充，在码位上和GB2312-80兼容 范围：8140~FEFE（剔除xx7F）共23940个码位。包含21003个汉字，包含了ISO/IEC 10646-1中的全部中日韩汉字。 作用：它是GB2312的扩展，加入对繁体字的支持，兼容GB2312。 位数：使用2个字节表示，可表示21886个字符。 范围：高字节从81到FE，低字节从40到FE。 10.1.4 BIG5 大五码或五大码，1984年由台湾财团法人信息工业策进会和五家软件公司宏碁 (Acer)、神通 (MiTAC)、佳佳、零壹 (Zero One)、大众 (FIC)创立，故称大五码。 Big5码的产生，是因为当时台湾不同厂商各自推出不同的编码，如倚天码、IBM PS55、王安码等，彼此不能兼容；另一方面，台湾政府当时尚未推出官方的汉字编码，而中国大陆的GB2312编码亦未有收录繁体中文字。 Big5字符集共收录13,053个中文字，该字符集在中国台湾使用。耐人寻味的是该字符集重复地收录了两个相同的字：兀(0xA461及0xC94A)、嗀(0xDCD1及0xDDFC)。 编码方法 Big5码使用了双字节储存方法，以两个字节来编码一个字。第一个字节称为高位字节，第二个字节称为低位字节。高位字节的编码范围0xA1-0xF9，低位字节的编码范围0x40-0x7E及0xA1-0xFE。 各编码范围对应的字符类型如下：0xA140-0xA3BF为标点符号、希腊字母及特殊符号，另外于0xA259-0xA261，存放了双音节度量衡单位用字：兙兛兞兝兡兣嗧瓩糎；0xA440-0xC67E为常用汉字，先按笔划再按部首排序；0xC940-0xF9D5为次常用汉字，亦是先按笔划再按部首排序。 局限性 尽管Big5码内包含一万多个字符，但是没有考虑社会上流通的人名、地名用字、方言用字、化学及生物科等用字，没有包含日文平假名及片假名字母。 例如台湾视着为著的异体字，故没有收录着字。康熙字典中的一些部首用字(如亠、疒、辵、癶等)、常见的人名用字(如堃、煊、栢、喆等) 也没有收录到Big5之中。 10.1.5 GB18030 GB18030的全称是GB18030-2000《信息交换用汉字编码字符集基本集的扩充》，是我国政府于2000年3月17日发布的新的汉字编码国家标准，2001年8月31日后在中国市场上发布的软件必须符合本标准。 该标准解决汉字、日文假名、朝鲜语和中国少数民族文字组成的大字符集计算机编码问题。该标准的字符总编码空间超过150万个编码位，收录了27484个汉字，覆盖中文、日文、朝鲜语和中国少数民族文字。满足中国大陆、香港、台湾、日本和韩国等东亚地区信息交换多文种、大字量、多用途、统一编码格式的要求。并且与Unicode 3.0版本兼容，填补Unicode扩展字符字汇统一汉字扩展A的内容。并且与以前的国家字符编码标准（GB2312，GB13000.1）兼容。 编码方法 GB18030标准采用单字节、双字节和四字节三种方式对字符编码。单字节部分使用0×00至0×7F码(对应于ASCII码的相应码)。双字节部分，首字节码从0×81至0×FE，尾字节码位分别是0×40至0×7E和0×80至0×FE。四字节部分采用GB/T 11383未采用的0×30到0×39作为对双字节编码扩充的后缀，这样扩充的四字节编码，其范围为0×81308130到0×FE39FE39。其中第一、三个字节编码码位均为0×81至0×FE，第二、四个字节编码码位均为0×30至0×39。 包含内容 双字节部分收录内容主要包括GB13000.1全部CJK汉字20902个、有关标点符号、表意文字描述符13个、增补的汉字和部首/构件80个、双字节编码的欧元符号等。四字节部分收录了上述双字节字符之外的，包括CJK统一汉字扩充A在内的GB 13000.1中的全部字符。 10.1.6 Unicode字符集 Unicode字符集（简称为UCS）,国际标准组织于1984年4月成立ISO/IEC JTC1/SC2/WG2工作组，针对各国文字、符号进行统一性编码。1991年美国跨国公司成立Unicode Consortium，并于1991年10月与WG2达成协议，采用同一编码字集。目前Unicode是采用16位编码体系，其字符集内容与 ISO10646的BMP（Basic Multilingual Plane）相同。Unicode于1992年6月通过DIS（Draf International Standard），目前版本V2.0于1996公布，内容包含符号6811个，汉字20902个，韩文拼音11172个，造字区6400个，保留 20249个，共计65534个。Unicode编码后的大小是一样的.例如一个英文字母 “a” 和 一个汉字 “好”，编码后都是占用的空间大小是一样的，都是两个字节！ Unicode可以用来表示所有语言的字符，而且是定长双字节（也有四字节的）编码，包括英文字母在内。所以可以说它是不兼容iso8859-1编码的， 也不兼容任何编码。不过，相对于iso8859-1编码来说，uniocode编码只是在前面增加了一个0字节，比如字母’a’为“00 61”。 需要说明的是，定长编码便于计算机处理（注意GB2312/GBK不是定长编码），而unicode又可以用来表示所有字符，所以在很多软件内部是使用unicode编码来处理的，比如java。 UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16，UTF-32和UTF-7编码。 10.1.6.1 UTF-8 UTF:UCS Transformation Format.考虑到unicode编码不兼容iso8859-1编码，而且容易占用更多的空间：因为对于英文字母，unicode也需要两个字节来表 示。所以unicode不便于传输和存储。因此而产生了utf编码，utf编码兼容iso8859-1编码，同时也可以用来表示所有语言的字符，不 过，utf编码是不定长编码，每一个字符的长度从1-6个字节不等。另外，utf编码自带简单的校验功能。一般来讲，英文字母都是用一个字节表示，而汉字 使用三个字节。 注意，虽然说utf是为了使用更少的空间而使用的，但那只是相对于unicode编码来说，如果已经知道是汉字，则使用GB2312/GBK无疑是 最节省的。不过另一方面，值得说明的是，虽然utf编码对汉字使用3个字节，但即使对于汉字网页，utf编码也会比unicode编码节省，因为网页中包 含了很多的英文字符。 UTF8编码后的大小是不一定,例如一个英文字母a和一个汉字好，编码后占用的空间大小就不样了，前者是一个字节，后者是三个字节！编码的方法是从低位到高位。黄色为标志位其它着色为了显示其，编码后的位置。 10.1.6.2 UTF-16 采用2 字节，Unicode中不同部分的字符都同样基于现有的标准。这是为了便于转换。从 0x0000到0x007F是ASCII字符，从0x0080到0x00FF是ISO-8859-1对ASCII的扩展。希腊字母表使用从0x0370到 0x03FF 的代码，斯拉夫语使用从0x0400到0x04FF的代码，美国使用从0x0530到0x058F的代码，希伯来语使用从0x0590到0x05FF的代 码。中国、日本和韩国的象形文字（总称为CJK）占用了从0x3000到0x9FFF的代码； 由于0x00在c语言及操作系统文件名等中有特殊意义，故很多情况下需要UTF-8编码保存文本，去掉这个0x00。举例如下： UTF-16: 0x0080 = 0000 0000 1000 0000 UTF-8: 0xC280 = 1100 0010 1000 0000 10.1.6.3 UTF-32 采用4字节。 10.1.6.4 UTF-7 A Mail-Safe Transformation Format of Unicode(RFC1642)。这是一种使用 7 位 ASCII 码对 Unicode 码进行转换的编码。它的设计目的仍然是为了在只能传递 7 为编码的邮件网关中传递信息。 UTF-7 对英语字母、数字和常见符号直接显示，而对其他符号用修正的 Base64 编码。符号 + 和 - 号控制编码过程的开始和暂停。所以乱码中如果夹有英文单词，并且相伴有 + 号和 - 号，这就有可能是 UTF-7 编码。 作用：为世界650种语言进行统一编码，兼容ISO-8859-1。 位数：UNICODE字符集有多个编码方式，分别是UTF-8，UTF-16和UTF-32。 10.1.7 编码的常用命令 在 Linux 下通常使用 UTF-8 编码。如果你需要对用户姓名排序的话，建议使用 GB18030 编码，以便直接排序。各种编码也是可以相互转换的。 如果我们想查看某个文件的编码方式，可以使用file -i命令。 $ file -i test.md test.md: text/plain; charset=utf-8 这样就可以看到test.md文件的属性普通文本文件text/plain以及编码方式为UTF-8，charset=utf-8。 一般的编辑器都是支持编码方式转换的，如果你想改变某个文件的编码方式，可以使用iconv工具。 iconv 工具的使用方法如下： $ iconv option $ iconv options -f from-encoding -t to-encoding inputfile(s) -o outputfile 在这里，-f 或 --from-code 表明了输入编码，而 -t 或 --to-encoding 指定了输出编码。 为了列出所有已有编码的字符集，你可以使用以下命令： $ iconv -l 以下的列表包含所有已知的编码字符集，但这不代表所有的字符名称组合皆可用于 命令行的 &quot;来源&quot; 以及 &quot;目的&quot; 参数。一个编码字符集可以用几个不同的名称 来表示 (即 &quot;别名&quot;)。 437, 500, 500V1, 850, 851, 852, 855, 856, 857, 858, 860, 861, 862, 863, 864, 865, 866, 866NAV, 869, 874, 904, 1026, 1046, 1047, 8859_1, 8859_2, 8859_3, 8859_4, 8859_5, 8859_6, 8859_7, 8859_8, 8859_9, 10646-1:1993, 10646-1:1993/UCS4, ANSI_X3.4-1968, ANSI_X3.4-1986, ANSI_X3.4, 下面举个小例子。其中test.md文件是包含中英文的。 在运行 iconv 命令之后，我们可以像下面这样检查输出文件的内容，和它使用的字符编码。 $ file -i test.md test.md: text/plain; charset=utf-8 $ cat test.md : Shell 提示符中用到的转义字符 $ iconv -f utf-8 -t GB18030 test.md -o out.md $ cat out.md : Shell ��ʾ�����õ���ת���ַ� $ file -i out.md out.md: text/plain; charset=iso-8859-1 你会发现转换后，电脑没有正确识别出out.md文件的编码，如果你使用文本编辑器gedit打开out.md文件，还是可以正常打开的。 10.2 编辑器 办公常接触的文档，一般是有格式的文件，比如 xls, doc 等，他们常常需要相应的办公软件，比如金山公司的 WPS。本章提到的文字编辑，是指文本文件的编辑。讲到的编辑器有 vim,gedit,nano,vscode等。 本人常用vim写代码，也自嗨的分享了自己的使用经验教训，但是编写书籍的话，我还是喜欢用vscode。各有所长吧。大家可以根据需要搜索相关入门教程。 10.3 文件查找 文件查找用得好，绝对是一件利器。有人推荐locate命令，本人感觉不太好用，就不介绍了。下面介绍find和grep这两个命令，其中find负责查找文件的信息，grep负责查找文件内的信息。当然提到搜索不得不提正则表达式，适当了解一些正则表达式，对于我们搜索文件还是很有帮助的，且find，grep以及一些编辑器是支持正则表达式搜索的。 10.3.1 find 查找文件 参考网页： http://www.runoob.com/linux/linux-comm-find.html Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。前提是你必须对这个文件（夹）有相关权限。 find path -option [ -print ] [ -exec -ok command ] {} \\; 解释 find 根据下列规则判断目录 path 和表达式 expression，在命令列上第一个 - ( ) , ! 之前的部份为目录 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。 expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。 -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件 -amin n : 在过去 n 分钟内被读取过 -anewer file : 比文件 file 更晚被读取过的文件 -atime n : 在过去n天内被读取过的文件 -cmin n : 在过去 n 分钟内被修改过 -cnewer file :比文件 file 更新的文件 -ctime n : 在过去n天内被修改过的文件 -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写 -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写 -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。 -type c : 文件类型是 c 的文件。其中有如下可选变量。 d: 目录 c: 字型装置文件 b: 区块装置文件 p: 具名贮列 f: 一般文件 l: 符号连结（） s: socket -pid n : process id 是 n 的文件 下面介绍几个例子。 10.3.1.1 根据文件名查找文件 $ find . -name test.md $ find . -name &#39;test.md&#39; $ find . -name &quot;*.Rmd&quot; $ find . -name &quot;*.rmd&quot; $ find . -iname &quot;*.rmd&quot; $ find . -iname &#39;????.rmd&#39; $ find . -ls $ find /root -ls 解释 第1、2行，加不加单双引号',&quot;效果一样的。直接搜索当前目录下，名字是test.md的文件。 第3行，find支持星*（任意多字符）和英文问号?（单个字符）的通配搜索的。注意要用单（双）引号括起来。本行就是查找所有以.Rmd结尾的文件。 第4行，find是区分大小写的，本行命令跟上行命令结果是不一样的。 第5行，-iname表示不区分大小写的搜索。 第6行，是?的一个例子，查找所有四个字母后缀不区分大小写.rmd的文件。 第7行，-ls选项，搜索结果是类似ls -l命令的显示样式。 第8行，因为你没有权限，会报错。 10.3.1.2 根据文件大小、用户名、权限、日期等查找文件 将目前目录其其下子目录中所有一般文件列出 $ find . -type f $ find ./deepin-bible -size +10M $ find /mostlybig -size -1M $ find /bigdata -size +500M -size -5G -exec du -sh {} \\; $ find /home -user litianci -ls $ sudo find /home -user litianci -or -user joe -ls $ sudo find /etc -group ntp -ls $ sudo find /var/spool -not -user root -ls $ find /bin -perm 755 -ls $ find /home/chris/ -perm -222 -type d -ls $ find /myreadonly -perm /222 -type f $ find . -perm -002 -type f -ls $ sudo find /etc/ -mmin -10 $ sudo find /bin /usr/bin /sbin /usr/sbin -ctime -3 $ find /var/ftp /var/www -atime +300 解释 第1行，-type f，查找当前目录下的所有普通文件，f代表普通文件的意思，详情见上面说明。 第2-4行，根据文件大小查找文件，+10M是大于10MB的意思，-1M是小于5MB的意思。单位大小还支持k,M,G，c,b,w。其中M表示MB大小，G表示GB大小，b 代表 512 位元组的区块，c 表示字元数，k 表示kB，w 是二个位元组。第2行的意思就是查找大于10MB的文件，读者不难理解第3行命令的意思吧。第4行，是查找大于500MB，小于5G的文件(夹)，然后对每个文件执行命令du -sh {找到的文件（夹）}显示文件大小。方便处理一些过大文件。-exec的用法后面讲解。 第5-8行，根据文件的用户搜索文件。其中用到了联合查找-or关键词，表示或的意思。也可以根据组用户查找文件。第8行，查找非root用户的文件。 第9-12行，根据文件权限搜索文件。前面以及介绍了数字表示权限的方法。第9行，实现对权限的精确匹配。第10-12行，是对符合一定规则权限的文件进行搜索。其中-perm +222也即-perm +mode，已经不推荐使用了，深度操作系统自带bash已经报错了，建议用-perm /222。-perm -mode表示所有为1的权限都必须匹配才可以，示例中-perm -222也即u,g,o的写权限都具备才可以。-perm /mode表示u,g,o只要有一个具备即可。-perm /mode对于查找那些非法权限的文件特别有效。 第13-15,行，是根据文件修改、创建和访问时间搜索文件的。mtime,ctime,atime的单位是天，mmin,cmin,amin的单位是分钟。mtime,mmin表示文件内容修改的日期时间，ctime,cmin表示文件权限归属等属性信息修改的日期时间，atime,amin表示文件被访问的时间。上述三个例子，分别查找10分钟之内修改的/etc配置文件；3天内是否有黑客更改我系统可执行文件的属性信息；ftp服务器上查找300天以上都没有访问的文件。 使用man find可以看到更多例子。 10.3.1.3 联合若干条件查找文件 操作符 (优先级递减；未做任何指定时默认使用 -and): ( EXPR ) ! EXPR -not EXPR EXPR1 -a EXPR2 EXPR1 -and EXPR2 EXPR1 -o EXPR2 EXPR1 -or EXPR2 EXPR1 , EXPR2 下面举几个例子。 $ find /var/all \\( -user litianci -o -user xampp \\) -ls $ find /var/all/ -user litianci -not -group litianci -ls $ find /var/all/ -user litianci -and -size +1M -ls 解释 这些例子不难理解，需要注意的是，与或非的位置，要位于这些条件的外面。括号要用\\表示，不然就歧义了。 10.3.1.4 找到文件后的动作 找到文件后只是列出来，有时不太满足我们的需求。强大的find给我们提供了找到后就操作的功能。语法如下， $ find [options] -exec command {} \\; $ find [options] -ok command {} \\; 解释 find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为command' { } \\;，注意{ }和\\；之间的空格。 -ok和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 下面给出几个例子。 $ find deepin-bible/ -iname &quot;*.Rmd&quot; -exec echo &quot;我找到了{}&quot; \\; $ find /usr/share -size +5M -exec du {} \\; | sort -nr $ sudo find /opt/lampp/ -user litianci -ok mv {} /tmp/litianci/ \\; 解释 第1行，找所有的文件，然后换种样式显示出来。 第2行，搜索/usr/share文件夹下所有大于5MB的文件，显示他们的大小，并排序。对于命令du和sort -nr，读者可以试着用前文提到的方法，查找他们的功能。 第3行，搜/opt/lampp/ 下我的文件，每个文件均需我同意，才可以放到/tmp/litianci/目录下。大家可以理解{}就是代表搜索到文件（夹）了吧。 10.3.2 grep 查找文件内部信息 有时候你想找某个文件或者某个目录下的一段话，grep就能过来帮忙啦。但是对于中文，还是存在编码问题，grep默认文件为utf8编码（这句话对吗？需要核实。至少ASCII的，或者其他编码的文件，搜英文字母还是都可以搜得到的）。对于非UTF8文件，建议先转化为UFT8格式的临时文件，再查找。 $ cat test.md : Shell 提示符中用到的转义字符 $ grep 转义字符 test.md : Shell 提示符中用到的转义字符 $ grep 转义字符 -rn . grep 转义字符 -rn . ./test.md:1:: Shell 提示符中用到的转义字符 $ grep 转义 -rln . ./test.md $ grep s test.md $ grep s -i test.md : Shell 提示符中用到的转义字符 $ grep s -v test.md : Shell 提示符中用到的转义字符 $ grep -i --color shell test.md : Shell 提示符中用到的转义字符 $ grep Shell -rn {test.md,xxx.md} 解释 第1行，用于显示test.md文件的内容。 第3行，在test.md文件内搜索“转义字符”。grep的命令格式，就是先写待搜索字段，后写搜索的范围，比如某个文件或者文件夹。 第4行，显示搜索结果，显示含有搜索词的那些行数。 第5行，grep的选项-rn分别表示递归以及搜索结果显示文件所在行数。从第6行，我们可以看到，搜索当前目录.，./test.md文件的第1行，包含该搜索词，该行内容紧接着显示出来了。 第7行，grep的选项-l表示，只显示包含搜索词的文件，不显示文件夹。 第9、10行，grep搜索是区分大小写的。选项-i也即--ignore-case，是忽略大小写的意思，表示在忽略大小写的情况下搜索。 第12行，选项-v，--invert-match表示显示不匹配的行数，也即搜索不包含搜索词的那些文件或者行数等。 第14行，--color表示搜索结果中高亮匹配词。 第16行，{}表示集合，该语句实现了对集合内所有文件进行内部查找Shell的功能。 如果有兴趣，可以使用 grep --help 或者其他命令，查看更多grep相关的用法。另外还有类似的rgrep等命令，这里就不介绍了。 10.3.3 其他检索工具 除了这些命令行工具外，深度系统的深度文件管理器支持在相关的文件夹内搜索对应的文件，一些编辑器，比如某些配置的vim，支持文件及文件夹内搜索词汇，比如 VSCode 也支持。前面介绍的ANGRYsearch，大家也可看看。 10.3.4 正则表达式 说到正则表达式，可能需要一本书来细细的讲，这里从略吧。简要介绍几个常用的内容。正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。 参考网页 http://www.runoob.com/regexp/regexp-syntax.html https://deerchao.net/tutorials/regex/regex.htm 例如： runoo+b，可以匹配 runoob、runooob、runoooooob 等，+ 号代表前面的字符必须至少出现一次（1次或多次）。 runoo*b，可以匹配 runob、runoob、runoooooob 等，* 号代表字符可以不出现，也可以出现一次或者多次（0次、或1次、或多次）。 colo?r 可以匹配 color 或者 colour，?问号代表前面的字符最多只可以出现一次（0次、或1次）(存疑，难道可以0次？)。 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为“元字符”）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。 10.3.4.1 普通字符 普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。 10.3.4.2 非打印字符 非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列： 非打印字符转义字符 变量 解释 \\cx 匹配由x指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。注意 Unicode 正则表达式会匹配全角空格符。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 10.3.4.3 特殊字符 所谓特殊字符，就是一些有特殊含义的字符，如上面说的 runoo*b 中的 *，简单的说就是表示任何字符串的意思。如果要查找字符串中的 * 符号，则需要对 * 进行转义，即在其前加一个 \\: runo\\*ob 匹配 runo*ob。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符“转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 变量 解释 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\(和 \\)。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 \\. 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 \\[。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '\\\\' 匹配 &quot;\\&quot;，而 '\\(' 则匹配 &quot;(&quot;。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^字符本身，请使用 \\^。 { 标记限定符表达式的开始。要匹配 {，请使用 \\{。 | 指明两项之间的一个选择。要匹配 |，请使用 \\|。 10.3.4.4 限定符 限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符 变量 解释 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 &quot;zoo&quot;。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，&quot;do(es)?&quot; 可以匹配 &quot;do&quot; 、 &quot;does&quot; 中的 &quot;does&quot; 、 &quot;doxy&quot; 中的 &quot;do&quot; 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 &quot;Bob&quot; 中的 'o'，但是能匹配 &quot;food&quot; 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 &quot;Bob&quot; 中的 'o'，但能匹配 &quot;foooood&quot; 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，&quot;o{1,3}&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。 由于章节编号在大的输入文档中会很可能超过九，所以您需要一种方式来处理两位或三位章节编号。限定符给您这种能力。下面的正则表达式匹配编号为任何位数的章节标题： /Chapter [1-9][0-9]*/ 请注意，限定符出现在范围表达式之后。因此，它应用于整个范围表达式，在本例中，只指定从 0 到 9 的数字（包括 0 和 9）。 这里不使用 + 限定符，因为在第二个位置或后面的位置不一定需要有一个数字。也不使用 ? 字符，因为使用 ? 会将章节编号限制到只有两位数。您需要至少匹配 Chapter 和空格字符后面的一个数字。 如果您知道章节编号被限制为只有 99 章，可以使用下面的表达式来至少指定一位但至多两位数字。 /Chapter [0-9]{1,2}/ 上面的表达式的缺点是，大于 99 的章节编号仍只匹配开头两位数字。另一个缺点是 Chapter 0 也将匹配。只匹配两位数字的更好的表达式如下： /Chapter [1-9][0-9]?/ 或 /Chapter [1-9][0-9]{0,1}/ *、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 例如，您可能搜索 HTML 文档，以查找括在 H1 标记内的章节标题。该文本在您的文档中如下： &lt;H1&gt;Chapter 1 - 介绍正则表达式&lt;/H1&gt; 贪婪：下面的表达式匹配从开始小于符号 (&lt;) 到关闭 H1 标记的大于符号 (&gt;) 之间的所有内容。 /&lt;.*&gt;/ 非贪婪：如果您只需要匹配开始和结束 H1 标签，下面的非贪婪表达式只匹配 。 /&lt;.*?&gt;/ 如果只想匹配开始的 H1 标签，表达式则是： /&lt;\\w+?&gt;/ 通过在 *、+ 或 ? 限定符之后放置 ?，该表达式从“贪心”表达式转换为“非贪心”表达式或者最小匹配。 10.3.4.5 定位符 定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符 变量 解释 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注意：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 若要匹配一行文本开始处的文本，请在正则表达式的开始使用 ^ 字符。不要将 ^ 的这种用法与中括号表达式内的用法混淆。 若要匹配一行文本的结束处的文本，请在正则表达式的结束处使用 $ 字符。 若要在搜索章节标题时使用定位点，下面的正则表达式匹配一个章节标题，该标题只包含两个尾随数字，并且出现在行首： /^Chapter [1-9][0-9]{0,1}/ 真正的章节标题不仅出现行的开始处，而且它还是该行中仅有的文本。它即出现在行首又出现在同一行的结尾。下面的表达式能确保指定的匹配只匹配章节而不匹配交叉引用。通过创建只匹配一行文本的开始和结尾的正则表达式，就可做到这一点。 /^Chapter [1-9][0-9]{0,1}$/ 匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面： /\\bCha/ \\b 字符的位置是非常重要的。如果它位于要匹配的字符串的开始，它在单词的开始处查找匹配项。如果它位于字符串的结尾，它在单词的结尾处查找匹配项。例如，下面的表达式匹配单词 Chapter 中的字符串 ter，因为它出现在单词边界的前面： /ter\\b/ 下面的表达式匹配 Chapter 中的字符串 apt，但不匹配 aptitude 中的字符串 apt： /\\Bapt/ 字符串 apt 出现在单词 Chapter 中的非单词边界处，但出现在单词 aptitude 中的单词边界处。对于 \\B 非单词边界运算符，位置并不重要，因为匹配不关心究竟是单词的开头还是结尾。 10.3.4.6 选择 用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 10.3.4.7 反向引用 对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。以下面的句子为例： Is is the cost of of gasoline going up up? 上面的句子很显然有多个重复的单词。如果能设计一种方法定位该句子，而不必查找每个单词的重复出现，那该有多好。下面的正则表达式使用单个子表达式来实现这一点： 实例 查找重复的单词： var str = &quot;Is is the cost of of gasoline going up up&quot;; var patt1 = /\\b([a-z]+) \\1\\b/ig; document.write(str.match(patt1)); 捕获的表达式，正如 [a-z]+ 指定的，包括一个或多个字母。正则表达式的第二部分是对以前捕获的子匹配项的引用，即，单词的第二个匹配项正好由括号表达式匹配。\\1 指定第一个子匹配项。 单词边界元字符确保只检测整个单词。否则，诸如 &quot;is issued&quot; 或 &quot;this is&quot;之类的词组将不能正确地被此表达式识别。 正则表达式后面的全局标记 g 指定将该表达式应用到输入字符串中能够查找到的尽可能多的匹配。 表达式的结尾处的不区分大小写 i 标记指定不区分大小写。 多行标记指定换行符的两边可能出现潜在的匹配。 反向引用还可以将通用资源指示符 (URI) 分解为其组件。假定您想将下面的 URI 分解为协议（ftp、http 等等）、域地址和页/路径： http://www.runoob.com:80/html/html-tutorial.html 下面的正则表达式提供该功能： 输出所有匹配的数据： var str = &quot;http://www.runoob.com:80/html/html-tutorial.html&quot;; var patt1 = /(\\w+):\\/\\/([^/:]+)(:\\d*)?([^# ]*)/; arr = str.match(patt1); for (var i = 0; i &lt; arr.length ; i++) { document.write(arr[i]); document.write(&quot;&lt;br&gt;&quot;); } 第三行代码 str.match(patt1) 返回一个数组，实例中的数组包含 5 个元素，索引 0 对应的是整个字符串，索引 1 对应第一个匹配符（括号内），以此类推。 第一个括号子表达式捕获 Web 地址的协议部分。该子表达式匹配在冒号和两个正斜杠前面的任何单词。 第二个括号子表达式捕获地址的域地址部分。子表达式匹配 : 和 / 之后的一个或多个字符。 第三个括号子表达式捕获端口号（如果指定了的话）。该子表达式匹配冒号后面的零个或多个数字。只能重复一次该子表达式。 最后，第四个括号子表达式捕获 Web 地址指定的路径和 / 或页信息。该子表达式能匹配不包括# 或空格字符的任何字符序列。 将正则表达式应用到上面的 URI，各子匹配项包含下面的内容： 第一个括号子表达式包含 http 第二个括号子表达式包含 www.runoob.com 第三个括号子表达式包含 :80 第四个括号子表达式包含 /html/html-tutorial.html . 特殊字符在中括号表达式时 如 [.] 只会匹配 .字符，等价于 \\.，而非匹配除换行符 \\n 外的所有字符。 var str = &quot;runoob.com&quot;; var patt1 = /[.]/; document.write(str.match(patt1)); ^ 和 [^指定字符串] 之间的区别: ^ 指的是匹配字符串开始的位置 [^指定字符串] 指的是除指定字符串以外的其他字符串 (^[0-9])+ //匹配有一至多个数字的字符串组合 [^[0-9]]+ // 匹配有一至多个不含数字的字符串组合 10.4 总结 本章介绍了字符集编码知识，以及文件的查找文件内的查找命令。 "],
["chap-manager-process.html", "11 进程管理 11.1 何谓进程 11.2 深度系统监视器管理进程 11.3 命令方式查看进程 11.4 进程的分类 11.5 进程的终结与调整优先级（Killing and Renicing） 11.6 通过cgroups限制进程 11.7 进程的状态 11.8 总结", " 11 进程管理 通过阅读本章，你将会了解到以下几项内容。 显示进程 进程前后台切换 对进程的生杀予夺 11.1 何谓进程 参考网页： http://www.cnblogs.com/xiaojiang1025/p/6021049.html https://www.cnblogs.com/vinozly/p/5585683.html https://blog.csdn.net/hq_buddhist/article/details/51233808 https://linux.cn/article-8451-1.html Linux 是一个多用户多任务的操作系统。多用户是指多个用户可以在同一时间使用计算机系统；多任务是指Linux可以同时执行几个任务，它可以在还未执行完一个任务时又执行另一项任务。 进程是指正在执行的程序；是程序正在运行的一个实例。它由程序指令，和从文件、其它程序中读取的数据或系统用户的输入组成。进程的一个比较正式的定义是∶在自身的虚拟地址空间运行的一个单独的程序。进程与程序是有区别的，进程不是程序，虽然它由程序产生。程序只是一个静态的指令集合，不占系统的运行资源；而进程是一个随时都可能发生变化的、动态的、使用系统运行资源的程序。而且一个程序可以启动多个进程。 系统运行时，会为每个进程分配当前唯一的数字标识，PID（Process ID），其他进程在该进程存活期间是无法抢占该PID的，当然，该进程结束了，系统会回收该PID的。 除了PID号外，进程还会与特定的用户帐户和组帐户相关联。这些账户信息有助于确定进程可以访问的系统资源。例如，进程运行时，root 根用户进程比普通用户进程在访问系统文件和资源方面有更多的权限。 有效管理进程，有助于我们更好的控制电脑。进程的信息一般存储与 /proc 文件夹，每个进程将其信息存储在/proc的子目录中，以进程 PID 命名。你可以使用 cat,less 以及其他编辑器查看这些文件。 11.2 深度系统监视器管理进程 深度系统监视器 深度系统监视器是深度科技团队打造一款直观易用的系统监视器应用，它可以实时监控处理器状态、内存占用率、网络上传下载速度；还可以管理您的系统进程和应用进程，支持搜索进程和强制结束进程。 标签显示，快速定位 通过标签分类的方式显示：应用程序进程、我的进程和所有进程，快速切换自己想要的进程显示；同时应用程序进程名称国际化处理，进程名称一目了然。当需要快速定位到某个进程时，可以快速搜索定位。 标签显示，快速定位 列表展示，高效右键 系统的进程采用列表方式展示，可以自定义处理器、内存、磁盘写入、磁盘读取、下载、上传、进程号是否显示，还可以根据列表排序显示；同时对进程还可以右键菜单快速操作。 列表展示，高效右键 捕捉窗口，即点即“杀” 当在使用系统的过程，不知道进程的ID或者想直接结束某个应用进程，只需点击菜单中强制结束进程选项，自动采用红色透明遮框捕捉窗口，点击即可结束进程。 捕捉窗口，即点即“杀” 大家可以通过更新系统以获取深度系统监视器V1.0，或者直接在深度商店搜索下载。也可以采用命令行安装。 $ sudo apt-get install deepin-system-monitor -y 11.3 命令方式查看进程 参考网页： https://www.cnblogs.com/w10234/p/5642552.html 要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而ps命令（Process Status）就是最基本同时也是非常强大的进程查看命令。使用该命令，可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等。 ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的； 如果想对进程时间监控并进行操作，应该用 top 工具。 如果直接用ps命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。grep命令已经在前面第10章介绍过了。 11.3.1 ps 命令基本用法 按照man ps的说法， This version of ps accepts several kinds of options: UNIX options, which may be grouped and must be preceded by a dash. BSD options, which may be grouped and must not be used with a dash. GNU long options, which are preceded by two dashes. ps的选项支持三种方式， UNIX 风格选项，可以组合且必须以短横线-开头，类似第8章介绍的。 BSD 风格选项，可以组合且不可使用短横线。 GNU 长风格选项，也即第8章提到的双短横线--开头的选项。 不同风格的选项可以混用，但是部分选项可能会相互冲突，比如ps aux跟ps -aux并不完全一样，详情请参考man ps，这里不转载他们的内容了。下面介绍常用的几个例子。下面例子未经上机测试。特殊字符$,&amp;在代码中由于是mathtype=true，需要特别关注。 $ # To see every process on the system using standard syntax: $ ps -e $ ps -ef $ ps -eF $ ps -ely $ # To see every process on the system using BSD syntax: $ ps ax $ ps axu $ # 查找包含php的进程 $ ps aux|grep php $ # To print a process tree: $ ps -ejH $ ps axjf $ # To get info about threads: $ ps -eLf $ ps axms $ # To get security info: $ ps -eo euser,ruser,suser,fuser,f,comm,label $ ps axZ $ ps -eM $ # To see every process running as root (real \\&amp; effective ID) in user format: $ ps -U root -u root u $ # To see every process with a user-defined format: $ ps -eo pid,tid,class,rtprio,ni,pri,psr,pcpu,stat,wchan:14,comm $ ps axo stat,euid,ruid,tty,tpgid,sess,pgrp,ppid,pid,pcpu,comm $ ps -Ao pid,tt,user,fname,tmout,f,wchan $ # --sort=-rss是输出结果安装 rss从大到小排序，rss前正负号是否倒序。 $ ps -eo pid,user,group,gid,vsz,rss,comm --sort=-rss | less $ # Print only the process IDs of syslogd: $ ps -C syslogd -o pid= $ # Print only the name of PID 42: $ ps -q 42 -o comm= 对各个选项的简单解释如下，摘自：https://www.cnblogs.com/w10234/p/5642552.html ps a 显示现行终端机下的所有程序，包括其他用户的程序。 ps -A 显示所有程序。 ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。 ps -e 此参数的效果和指定“A”参数相同。 ps e 列出程序时，显示每个程序所使用的环境变量。 ps f 用ASCII字符显示树状结构，表达程序间的相互关系。 ps -H 显示树状结构，表示程序间的相互关系。 ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。 ps s 采用程序信号的格式显示程序状况。 ps S 列出程序时，包括已中断的子程序资料。 ps -t&lt;终端机编号&gt; 指定终端机编号，并列出属于该终端机的程序的状况。 ps u 以用户为主的格式来显示程序状况。 ps x 显示所有程序，不以终端机来区分。 11.3.2 top 命令基本用法 top动态实时的显示当前资源占用情况，如图11.1，并允许你对进程操作。如果你需要对所有的进程都能够生杀予夺，可能你需要root根权限。 \\begin{figure} {\\includegraphics[width=100%]{images/top-showing} } \\end{figure} 解释 图中红色矩形框圈出的，表示当前时间22:19:51，已经开机运行了多长时间13min(分钟)，当前有1个用户，当前CPU负载。 图中手划线的分别表示进程统计信息Tasks、CPU及Ni等的信息%Cpu(s)、内存占用情况(单位:MiB)MiB Mem、交换空间占用情况(单位:MiB)MiB Swap。对于MiB以及MB单位的区别， 按下h键，会弹出帮助信息。如图11.2所示。按下q或者esc键，返回到top命令界面。想看更多信息，可以man top或者必应百度一下。 按下M或P，分别表示安装内存和CPU排序，数字1显示更多CPU，R表示正倒序切换。 按下u，紧接着输入用户名回车，查看特定用户的进程。直接回车查看所有用户的进程。 \\begin{figure} {\\includegraphics[width=100%]{images/top-help} } \\end{figure} 众所周知，在计算机中是采用二进制，在电脑世界里，以2的次方数为“批量”处理Byte会方便一些，整齐一些。每1024Byte为1KB，每1024KB为1MB，每1024MB为1GB，每1024GB为1TB，而在国际单位制中TB、GB、MB、KB是“1000进制”的数，为此国际电工协会（IEC）拟定了“KiB”、“MiB”、“GiB”的二进制单位，专用来标示“1024进位”的数据大小；而硬盘厂商在计算容量方面是以每1000为一进制的，每1000字节为1KB，每1000KB为1MB，每1000MB为1GB，每1000GB为1TB 参考网页： https://blog.csdn.net/u012256258/article/details/52565500 调整进程 通常我们使用top是电脑太卡了，想要看看哪些进程占用CPU或者内存过多。上面提到的按键M和P分别实现内存和CPU占用的排序，就非常有用，按R实现正倒序的切换。非常方便。接下来就需要对相关进程动手啦。 降低权重，减小优先级。其实就是图11.1中NI和PR那两栏。关于优先级的内容，详情见下文。在top下可以按r（表示renice调整好感值）键，接着输入你想提高好感（NI）的进程PID，回车后再给他一个好感值。一般情况，对于普通用户只能提高进程的好感值，无权降低。好感值（NI）越高，占用资源的权限就越低，详细内容后面再说。 干掉进程。当你知道某个进程PID，就可以按下k（表示kill干掉键，接着输入该PID，最后输入kill命令的选项值，比如15清屏或者绝情些用9。 11.4 进程的分类 当你使用Putty远程连接服务器时，只有一个终端，你想后台跑一个程序，但是在此同时还想干其他事情，怎么办呢？那就用上后台程序啦。 在 Linux 中主要有两种类型的进程： 前台进程（也称为交互式进程） - 这些进程由终端会话初始化和控制。换句话说，需要有一个连接到系统中的用户来启动这样的进程；它们不是作为系统功能/服务的一部分自动启动。 后台进程（也称为非交互式/自动进程） - 这些进程没有连接到终端；它们不需要任何用户输入。 什么是守护进程 这是后台进程的特殊类型，它们在系统启动时启动，并作为服务一直运行；它们不会死亡。它们自发地作为系统任务启动（作为服务运行）。但是，它们能被用户通过 init 进程控制。 11.4.1 怎么生成后台进程呢？ 我感觉我的理解可能有误，比如我知道evince PDF阅读器不锁定文件的修改，当你修改了PDF文件，可以从evince上直接看到变化。这对于编写本书反复编译太有帮助了。但是编译本书要运行make命令，我习惯只打开一个终端，我就可以让evince程序运行于后台。有这么几种方法， 在命令行末尾加&amp;。 使用at命令（没有例子）。 $ evince _book/deepin-bible.pdf &amp; [1] 19589 解释 [1]表示，后台进程序号。19589是进程号PID。 如果想查看当前有多少后台进程。使用命令jobs $ jobs [1] 运行中 evince _book/deepin-bible.pdf &amp; [2]- 已停止 man top [3]+ 已停止 vim ~/test.md 解释 使用jobs会弹出当前正在运行的后台程序。还会显示他们的状态，比如运行中、已停止等。 [3]+，的+，-号，表示最新和次新加入后台的进程。就是最后两个加入后台的进程。但是这个貌似不是非常准确。man top不是最新加入后台的进程，但是却被标注为最新加入的。好在这个不怎么影响，后面再去找资料核实。 有时还需要把这些后台再拉回前台来，fg表示foreground的意思，就可以派上用场了。先看看fg的用法。貌似，不带%也不影响结果。需要核实。 $ fg % # 把最新的进程，也就是带`+`的进程放到前台。 $ fg %n # n表示`jobs`命令中[n] $ fg %string # string 表示命令，比如 `vim`，前提是不混淆。 $ fg %?string # ?string表示 string 在任意位置。 $ fg %-- # 倒数第二个已停止的进程拉回前台。 当然，我试过fg n直接输入jobs命令出来的那些后台序号[n]，可以直接把他们拉回前台。另外还有bg命令，用于唤醒已停止的后台命令。 11.5 进程的终结与调整优先级（Killing and Renicing） 有些进程太耗资源，我们需要关闭它，可以使用kill和killall命令，分别是通过进程号PID终结某个进程和通过进程名称终结某类进程。在终结进程的时候，还需要传递系统信号。具体用法可以通过man kill等查看。先来常用的几个例子吧， $ kill -l # 列出所有可用信号，见下面信号表 $ kill 999 # 使用默认系统信号杀死PID=999的进程 $ kill -15 999 # 默认系统信号也就是15号 $ kill -SIGKILL 999 # 默认系统信号常量为 SIGKILL，跟上面一致。 $ kill -9 999 # 对于顽固分子，电脑卡住的，往往用 -9 KILL 信号 $ killall -9 workrave # killall 使用的信号类似 kill，只不过用的是命令名称进行终结 参考网页： http://www.cnblogs.com/taobataoma/archive/2007/08/30/875743.html 信号对应的数值及意义 信号 数值 意义 SIGHUP 1 Hang-up detected on controlling terminal or death of controlling process. SIGINT 2 Interrupt from keyboard. SIGQUIT 3 Quit from keyboard. SIGABRT 6 Abort signal from abort(3). SIGKILL 9 Kill signal. SIGTERM 15 Termination signal. SIGCONT 19,18,25 Continue if stopped. SIGSTOP 17,19,23 Stop process. 参考网页： https://blog.csdn.net/longdel/article/details/7317511 用top或者ps命令会输出PRI/PR、NI、%ni/%nice这三种指标值，这些到底是什么东西？先给出大概的解释如下： PRI ：进程优先权，代表这个进程可被执行的优先级，其值越小，优先级就越高，越早被执行。 NI ：进程nice值，代表这个进程的优先值。 %nice ：改变过优先级的进程占用CPU的百分比。 PRI是比较好理解的，即进程的优先级，或者通俗点说就是程序被CPU执行的先后顺序，此值越小进程的优先级别越高。那NI呢？就是我们所要说的nice值了，其表示进程可被执行的优先级的修正数值。如前面所说，PRI值越小越快被执行，那么加入nice值后，将会使得PRI变为：PRI(new)=PRI(old)+nice。由此看出，PRI是根据nice排序的，规则是nice越小PRI越前（小，优先权更大），即其优先级会变高，则其越快被执行。如果nice相同则进程uid是root的优先权更大。 在LINUX系统中，nice值的范围从-20到+19（不同系统的值范围是不一样的），正值表示低优先级，负值表示高优先级，值为零则表示不会调整该进程的优先级。具有最高优先级的程序，其nice值最低，所以在LINUX系统中，值-20使得一项任务变得非常重要；与之相反，如果任务的nice为+19，则表示它是一个高尚的、无私的任务，允许所有其他任务比自己享有宝贵的CPU时间的更大使用份额，这也就是nice的名称的来意。 进程在创建时被赋予不同的优先级值，而如前面所说，nice的值是表示进程优先级值可被修正数据值，因此，每个进程都在其计划执行时被赋予一个nice值，这样系统就可以根据系统的资源以及具体进程的各类资源消耗情况，主动干预进程的优先级值。在通常情况下，子进程会继承父进程的nice值，比如在系统启动的过程中，init进程会被赋予0，其他所有进程继承了这个nice值（因为其他进程都是init的子进程）。 对nice值一个形象比喻，假设在一个CPU轮转中，有2个runnable的进程A和B，如果他们的nice值都为0，假设内核会给他们每人分配1k个cpu时间片。但是假设进程A的为0，但是B的值为-10，那么此时CPU可能分别给A和B分配1k和1.5k的时间片。故可以形象的理解为，nice的值影响了内核分配给进程的cpu时间片的多少，时间片越多的进程，其优先级越高，其优先级值（PRI）越低。%nice，就是改变过优先级的进程的占用CPU的百分比，如上例中就是0.5k/2.5k=1/5=20%。 由此可见，进程nice值和进程优先级不是一个概念，但是进程nice值会影响到进程的优先级变化。 进程的nice值是可以被修改的，修改命令分别是nice和renice。 nice命令就是设置一个要执行command进程的nice值，其命令格式是 nice –n adjustment command command_option。如果这里不指定adjustment，则默认为10，非root用户，adjustment不可为负值。 renice命令就是设置一个已经在运行的进程的nice值，假设一运行进程本来nice值为0，renice为3后，则这个运行进程的nice值就为3了。 如果用户设置的nice值超过了nice的边界值（LINUX为-20到+19），系统就取nice的边界值作为进程的nice值。 对非root用户，只能将其底下的进程的nice值变大而不能变小。若想变小，得要有相应的权限。 $ nice 0 $ nice -n 3 ls -l bashscript -rwsrwxrwx 1 litianci litianci 119 11月 17 22:32 bashscript $ nice -n -2 ls -l bashscript nice: 无法设置优先级: 权限不够 -rwsrwxrwx 1 litianci litianci 119 11月 17 22:32 bashscript $ sudo nice -n -2 ls -l bashscript -rwsrwxrwx 1 litianci litianci 119 11月 17 22:32 bashscript 同样，renice与nice命令类似，但是需要输入已经运行的进程号PID。 $ evince _book/deepin-bible.pdf &amp; # 启动一个后台程序，显示了进程号 [1] 26159 $ renice -n 5 26159 # renice 该进程 26159 (process ID) old priority 0, new priority 5 11.6 通过cgroups限制进程 参考网页： http://www.cnblogs.com/lisperl/archive/2012/04/17/2453838.html 11.6.1 cgroups是什么？ cgroups是control groups的缩写，是Linux内核提供的一种可以限制、记录、隔离进程组（process groups）所使用的物理资源（如：cpu,memory,IO等等）的机制。最初由google的工程师提出，后来被整合进Linux内核。cgroups也是LXC为实现虚拟化所使用的资源管理手段，可以说没有cgroups就没有LXC。 11.6.2 cgroups可以做什么？ cgroups最初的目标是为资源管理提供的一个统一的框架，既整合现有的cpuset等子系统，也为未来开发新的子系统提供接口。现在的cgroups适用于多种应用场景，从单个进程的资源控制，到实现操作系统层次的虚拟化（OS Level Virtualization）。 cgroups提供了以下功能： 限制进程组可以使用的资源数量（Resource limiting ）。比如：memory子系统可以为进程组设定一个memory使用上限，一旦进程组使用的内存达到限额再申请内存，就会出发OOM（out of memory）。 进程组的优先级控制（Prioritization ）。比如：可以使用cpu子系统为某个进程组分配特定cpu share。 记录进程组使用的资源数量（Accounting ）。比如：可以使用cpuacct子系统记录某个进程组使用的cpu时间 进程组隔离（Isolation）。比如：使用ns子系统可以使不同的进程组使用不同的namespace，以达到隔离的目的，不同的进程组有各自的进程、网络、文件系统挂载空间。 进程组控制（Control）。比如：使用freezer子系统可以将进程组挂起和恢复。 11.6.3 cgroups相关概念及其关系 相关概念： 任务（task）。在cgroups中，任务就是系统的一个进程。 控制族群（control group）。控制族群就是一组按照某种标准划分的进程。cgroups中的资源控制都是以控制族群为单位实现。一个进程可以加入到某个控制族群，也从一个进程组迁移到另一个控制族群。一个进程组的进程可以使用cgroups以控制族群为单位分配的资源，同时受到cgroups以控制族群为单位设定的限制。 层级（hierarchy）。控制族群可以组织成hierarchical的形式，即一颗控制族群树。控制族群树上的子节点控制族群是父节点控制族群的孩子，继承父控制族群的特定的属性。 子系统（subsytem）。一个子系统就是一个资源控制器，比如cpu子系统就是控制cpu时间分配的一个控制器。子系统必须附加（attach）到一个层级上才能起作用，一个子系统附加到某个层级以后，这个层级上的所有控制族群都受到这个子系统的控制。 相互关系： 每次在系统中创建新层级时，该系统中的所有任务都是那个层级的默认 cgroup（我们称之为 root cgroup ，此cgroup在创建层级时自动创建，后面在该层级中创建的cgroup都是此cgroup的后代）的初始成员。 一个子系统最多只能附加到一个层级。 一个层级可以附加多个子系统 一个任务可以是多个cgroup的成员，但是这些cgroup必须在不同的层级。 系统中的进程（任务）创建子进程（任务）时，该子任务自动成为其父进程所在 cgroup 的成员。然后可根据需要将该子任务移动到不同的 cgroup 中，但开始时它总是继承其父任务的cgroup。 11.6.4 cgroups子系统介绍 blkio – 这个子系统为块设备设定输入/输出限制，比如物理设备（磁盘，固态硬盘，USB 等等）。 cpu – 这个子系统使用调度程序提供对 CPU 的 cgroup 任务访问。 cpuacct – 这个子系统自动生成 cgroup 中任务所使用的 CPU 报告。 cpuset – 这个子系统为 cgroup 中的任务分配独立 CPU（在多核系统）和内存节点。 devices – 这个子系统可允许或者拒绝 cgroup 中的任务访问设备。 freezer – 这个子系统挂起或者恢复 cgroup 中的任务。 memory – 这个子系统设定 cgroup 中任务使用的内存限制，并自动生成由那些任务使用的内存资源报告。 net_cls – 这个子系统使用等级识别符（classid）标记网络数据包，可允许 Linux 流量控制程序（tc）识别从具体 cgroup 中生成的数据包。 ns – 名称空间子系统。 关于cgroups的更多介绍，请参考相关书籍。 11.7 进程的状态 参考网页： https://blog.csdn.net/shenwansangz/article/details/51981459 Linux是一个多用户，多任务的系统，可以同时运行多个用户的多个程序，就必然会产生很多的进程，而每个进程会有不同的状态。 11.7.1 Linux进程状态：R (TASK_RUNNING)，可执行状态。 只有在该状态的进程才可能在CPU上运行。而同一时刻可能有多个进程处于可执行状态，这些进程的task_struct结构（进程控制块）被放入对应CPU的可执行队列中（一个进程最多只能出现在一个CPU的可执行队列中）。进程调度器的任务就是从各个CPU的可执行队列中分别选择一个进程在该CPU上运行。 很多操作系统教科书将正在CPU上执行的进程定义为RUNNING状态、而将可执行但是尚未被调度执行的进程定义为READY状态，这两种状态在linux下统一为 TASK_RUNNING状态。 11.7.2 Linux进程状态：S (TASK_INTERRUPTIBLE)，可中断的睡眠状态。 处于这个状态的进程因为等待某某事件的发生（比如等待socket连接、等待信号量），而被挂起。这些进程的task_struct结构被放入对应事件的等待队列中。当这些事件发生时（由外部中断触发、或由其他进程触发），对应的等待队列中的一个或多个进程将被唤醒。 通过ps命令我们会看到，一般情况下，进程列表中的绝大多数进程都处于TASK_INTERRUPTIBLE状态（除非机器的负载很高）。毕竟CPU就这么一两个，进程动辄几十上百个，如果不是绝大多数进程都在睡眠，CPU又怎么响应得过来。 11.7.3 Linux进程状态：D (TASK_UNINTERRUPTIBLE)，不可中断的睡眠状态。 与TASK_INTERRUPTIBLE状态类似，进程处于睡眠状态，但是此刻进程是不可中断的。不可中断，指的并不是CPU不响应外部硬件的中断，而是指进程不响应异步信号。 绝大多数情况下，进程处在睡眠状态时，总是应该能够响应异步信号的。否则你将惊奇的发现，kill -9竟然杀不死一个正在睡眠的进程了！于是我们也很好理解，为什么ps命令看到的进程几乎不会出现TASK_UNINTERRUPTIBLE状态，而总是TASK_INTERRUPTIBLE状态。 而TASK_UNINTERRUPTIBLE状态存在的意义就在于，内核的某些处理流程是不能被打断的。如果响应异步信号，程序的执行流程中就会被插入一段用于处理异步信号的流程（这个插入的流程可能只存在于内核态，也可能延伸到用户态），于是原有的流程就被中断了。（参见《linux内核异步中断浅析》） 在进程对某些硬件进行操作时（比如进程调用read系统调用对某个设备文件进行读操作，而read系统调用最终执行到对应设备驱动的代码，并与对应的物理设备进行交互），可能需要使用TASK_UNINTERRUPTIBLE状态对进程进行保护，以避免进程与设备交互的过程被打断，造成设备陷入不可控的状态。这种情况下的TASK_UNINTERRUPTIBLE状态总是非常短暂的，通过ps命令基本上不可能捕捉到。 11.7.4 Linux进程状态：T (TASK_STOPPED or TASK_TRACED)，暂停状态或跟踪状态。 向进程发送一个SIGSTOP信号，它就会因响应该信号而进入TASK_STOPPED状态（除非该进程本身处于TASK_UNINTERRUPTIBLE状态而不响应信号）。（SIGSTOP与SIGKILL信号一样，是非常强制的。不允许用户进程通过signal系列的系统调用重新设置对应的信号处理函数。） 向进程发送一个SIGCONT信号，可以让其从TASK_STOPPED状态恢复到TASK_RUNNING状态。 当进程正在被跟踪时，它处于TASK_TRACED这个特殊的状态。“正在被跟踪”指的是进程暂停下来，等待跟踪它的进程对它进行操作。比如在gdb中对被跟踪的进程下一个断点，进程在断点处停下来的时候就处于TASK_TRACED状态。而在其他时候，被跟踪的进程还是处于前面提到的那些状态。 对于进程本身来说，TASK_STOPPED和TASK_TRACED状态很类似，都是表示进程暂停下来。而TASK_TRACED状态相当于在TASK_STOPPED之上多了一层保护，处于TASK_TRACED状态的进程不能响应SIGCONT信号而被唤醒。只能等到调试进程通过ptrace系统调用执行PTRACE_CONT、PTRACE_DETACH等操作（通过ptrace系统调用的参数指定操作），或调试进程退出，被调试的进程才能恢复TASK_RUNNING状态。 11.7.5 Linux进程状态：Z (TASK_DEAD - EXIT_ZOMBIE)，退出状态，进程成为僵尸进程。 进程在退出的过程中，处于TASK_DEAD状态。 在这个退出过程中，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外。于是进程就只剩下task_struct这么个空壳，故称为僵尸。 之所以保留task_struct，是因为task_struct里面保存了进程的退出码、以及一些统计信息。而其父进程很可能会关心这些信息。比如在shell中，$?变量就保存了最后一个退出的前台进程的退出码，而这个退出码往往被作为if语句的判断条件。 当然，内核也可以将这些信息保存在别的地方，而将task_struct结构释放掉，以节省一些空间。但是使用task_struct结构更为方便，因为在内核中已经建立了从pid到task_struct查找关系，还有进程间的父子关系。释放掉task_struct，则需要建立一些新的数据结构，以便让父进程找到它的子进程的退出信息。 父进程可以通过wait系列的系统调用（如wait4、waitid）来等待某个或某些子进程的退出，并获取它的退出信息。然后wait系列的系统调用会顺便将子进程的尸体（task_struct）也释放掉。 子进程在退出的过程中，内核会给其父进程发送一个信号，通知父进程来“收尸”。这个信号默认是SIGCHLD，但是在通过clone系统调用创建子进程时，可以设置这个信号。 只要父进程不退出，这个僵尸状态的子进程就一直存在。那么如果父进程退出了呢，谁又来给子进程“收尸”？ 当进程退出的时候，会将它的所有子进程都托管给别的进程（使之成为别的进程的子进程）。托管给谁呢？可能是退出进程所在进程组的下一个进程（如果存在的话），或者是1号进程。所以每个进程、每时每刻都有父进程存在。除非它是1号进程。 1号进程，pid为1的进程，又称init进程。 linux系统启动后，第一个被创建的用户态进程就是init进程。它有两项使命： 执行系统初始化脚本，创建一系列的进程（它们都是init进程的子孙）； 在一个死循环中等待其子进程的退出事件，并调用waitid系统调用来完成“收尸”工作； init进程不会被暂停、也不会被杀死（这是由内核来保证的）。它在等待子进程退出的过程中处于TASK_INTERRUPTIBLE状态，“收尸”过程中则处于TASK_RUNNING状态。 11.7.6 Linux进程状态：X (TASK_DEAD - EXIT_DEAD)，退出状态，进程即将被销毁。 而进程在退出过程中也可能不会保留它的task_struct。比如这个进程是多线程程序中被detach过的进程（进程？线程？参见《linux线程浅析》）。或者父进程通过设置SIGCHLD信号的handler为SIG_IGN，显式的忽略了SIGCHLD信号。（这是posix的规定，尽管子进程的退出信号可以被设置为SIGCHLD以外的其他信号。） 此时，进程将被置于EXIT_DEAD退出状态，这意味着接下来的代码立即就会将该进程彻底释放。所以EXIT_DEAD状态是非常短暂的，几乎不可能通过ps命令捕捉到。 11.7.7 进程的初始状态 进程是通过fork系列的系统调用（fork、clone、vfork）来创建的，内核（或内核模块）也可以通过kernel_thread函数创建内核进程。这些创建子进程的函数本质上都完成了相同的功能——将调用进程复制一份，得到子进程。（可以通过选项参数来决定各种资源是共享、还是私有。） 那么既然调用进程处于TASK_RUNNING状态（否则，它若不是正在运行，又怎么进行调用？），则子进程默认也处于TASK_RUNNING状态。 另外，在系统调用调用clone和内核函数kernel_thread也接受CLONE_STOPPED选项，从而将子进程的初始状态置为 TASK_STOPPED。 11.7.8 进程状态变迁 进程自创建以后，状态可能发生一系列的变化，直到进程退出。而尽管进程状态有好几种，但是进程状态的变迁却只有两个方向——从TASK_RUNNING状态变为非TASK_RUNNING状态、或者从非TASK_RUNNING状态变为TASK_RUNNING状态。 也就是说，如果给一个TASK_INTERRUPTIBLE状态的进程发送SIGKILL信号，这个进程将先被唤醒（进入TASK_RUNNING状态），然后再响应SIGKILL信号而退出（变为TASK_DEAD状态）。并不会从TASK_INTERRUPTIBLE状态直接退出。 进程从非TASK_RUNNING状态变为TASK_RUNNING状态，是由别的进程（也可能是中断处理程序）执行唤醒操作来实现的。执行唤醒的进程设置被唤醒进程的状态为TASK_RUNNING，然后将其task_struct结构加入到某个CPU的可执行队列中。于是被唤醒的进程将有机会被调度执行。 而进程从TASK_RUNNING状态变为非TASK_RUNNING状态，则有两种途径： 响应信号而进入TASK_STOPED状态、或TASK_DEAD状态； 执行系统调用主动进入TASK_INTERRUPTIBLE状态（如nanosleep系统调用）、或TASK_DEAD状态（如exit系统调用）；或由于执行系统调用需要的资源得不到满足，而进入TASK_INTERRUPTIBLE状态或TASK_UNINTERRUPTIBLE状态（如select系统调用）。 显然，这两种情况都只能发生在进程正在CPU上执行的情况下。 11.8 总结 本章简要介绍了进程概念，如何查看进程，并对进程进行操作控制。本书不会太详细的介绍某个命令，如果需要深入了解，请用man &lt;command&gt;查找，或者网上搜索相关资料。 "],
["chap-simple-bash-scripts.html", "12 简单bash脚本 12.1 何谓 shell 脚本 12.2 shell 脚本的三大结构 12.3 流编辑器sed 12.4 shell脚本例子：转换 UC 缓存视频 12.5 总结", " 12 简单bash脚本 通过阅读本章，你将会了解到以下几项内容。 理解脚本的概念 bash进行判断和简单数学计算 bash 的流程结构 实现把UC视频缓存变为普通视频文件的脚本 12.1 何谓 shell 脚本 我认为就是最初的程序员一条条命令写得太累了，能不能把每行命令都放在一个文本文件里，让shell自己来读取呢，这样脚本就诞生了。囊括了命令、函数、变量等内容，实现一条命令完成众多工作的功能，可以复杂到启动系统，也可用简单到只有一条命令，类似 Windows 下的批处理文件。 12.1.1 执行和调试 由于 shell 脚本都是文本，可以用任意编辑器打开，可当做bash或zsh等 shell 的参数来逐行直接执行，比如我们新建一个文本文件，内写上， uname -a，保存为myscript。可以通过如下方式执行， $\\$$ echo &#39;uname -a&#39; &gt; myscript $\\$$ bash myscript Linux litianci-PC 4.15.0-29deepin-generic $\\#$31 SMP Fri Jul 27 07:12:08 UTC 2018 x86_64 GNU/Linux 解释 第1行，创建myscript文件。 第2行，执行该脚本文件 第3行，输出结果。 另外，也可用给脚本加上可执行权限，直接运行。通常在脚本第一行#!/bin/bash告诉 shell 使用 /bin/bash 执行该脚本。对于使用Python或者R语言等执行的脚本，相应的把/bin/bash换成相应的脚本解释器Python或者RScript等。 在 shell 脚本中，使用 # 表示单行注释，也就是从 # 到行尾的内容为注释内容。当然，有些#属于字符串的内容或者其他语法格式，不表示单行注释。如果你使用vim等编辑器打开脚本的时候，会发现注释的颜色是跟其他部分不一样的。通常在脚本第二行开始该脚本的功能注释，也可以添加作者、编辑信息等，然后另起一行注释该脚本的名称。空一行，开始脚本正文内容。如下面所示， #!/bin/bash # 本脚本实现 UC 浏览器视频缓存内容转换为一个完整的 MP4 文件 # ucvideo if [! -e $2] echo &quot;请按照如下格式调用该脚本&quot; fi 写完脚本，保存后，一般使用chmod u+x ucvideo的方式，给该脚本添加可执行权限。这样，可以像普通命令那样直接调用该脚本了。 $ ./ucvideo 当然，跟其他程序类似，脚本不可避免的要调试纠错，下面几种方法可能有用， 注释掉某些内容，方法就是在行首加#； 使用 echo输出相关参数信息或者其他需要显示的内容。 使用bash -x myscript，会输出每行命令及执行结果，对于循环或者分支判断语句，可以告诉你具体执行了那些内容。 当然，最主要的还是要做到代码整洁，及时给自己的代码注释，避免后面自己都忘记咋回事了。 12.1.2 shell 变量 为了存储一些输出结果，或者一些参数等，需要用到变量存储，方便脚本书写。对于内容偏大的临时结果，也可用使用文件存储。通常采用如下方式， NAME=value 变量名NAME类似C语言的变量名规则，只可数字字母下划线，数字不可开头，区分大小写，中文不能出现在变量名中。对于变量值value则没有太多要求。通常是字符串、数字等，可以包含中文。比如， HOME=&quot;中国&quot; e=2.7 对于命令的输出结果，通常采用$(command)和`command`的方式实现。比如， MACHINE=`uname -n` TODAY=$(date) 如果想获取变量的数值，可以使用$NAME的方法。 echo $MACHINE 第8章，简要介绍了$,`,*,!等特殊字符。在脚本中有时需要他们的特殊功能，有时候需要他们保持原样，该怎么做呢，通常使用双引号&quot;&quot;，单引号''，以及反斜杠\\，看下面例子。 $ echo $HOME /home/litianci $ echo &quot;$HOME , today is `date`&quot; /home/litianci,today is 2018年 11月 16日 星期五 21:25:46 CST $ echo &#39;$HOME , today is `date`&#39; $HOME , today is `date` $ echo \\$HOME \\`date\\` $HOME `date` 特殊字符可以使用\\转义为本来样子，直接输出即可。如果作为字符串，使用单引号'则保持原样不变，使用双引号&quot;则实现转义。这在其他语言中也有类似做法。 12.1.3 特殊变量 作为脚本，作为命令来用时，不可避免的要传入参数，在脚本中，通常使用$0,$1,...,$n的方式来获取这些参数值。其中 $0,表示本脚本；$n，表示第n个输入参数。不管是bash myscript还是./myscript方式执行脚本，上述$n(\\(n!=0\\))都是一样的。另外$#表示共有多少个参数，$@保存着正行的输入。$?显示上一个命令的返回状态，一般返回0表示正常，其他数值表示异常或错误。看下面例子，脚本myscript的内容为。 #!/bin/bash # 测试这些特使变量 # myscript echo &quot;第一个参数为： $\\$$1, 第二个参数为 $\\$$2.&quot; echo &quot;共有 $\\$$$\\#$ 个参数&quot; echo &quot;这些参数是 $\\$$@&quot; echo &quot;该脚本名称为： $\\$$0.&quot; 分别执行bash myscript first second和./myscript first second，结果如下， $ bash myscript first second 第一个参数为： first, 第二个参数为 second. 共有 2 个参数 这些参数是 first second 该脚本名称为： myscript. $ chmod u+x myscript # 设置文件执行属性 $ ./myscript first second 第一个参数为： first, 第二个参数为 second. 共有 2 个参数 这些参数是 first second 该脚本名称为： ./myscript. $ echo $? 0 12.1.4 执行时输入参数 $n(n&gt;0)一般都是执行前输入的参数，有时候还需要在执行中跟用户交互，那就用到read命令了。新建脚本readscript内容如下， #!/bin/bash # 测试交互信息 # readscript read -p &quot;你叫啥名字，几岁啦？（两个答案请用空格隔开）&quot; name age echo &quot;我知道啦，你叫 $name, $age 岁了。&quot; 执行该脚本， $ bash readscript 你叫啥名字，几岁啦？（两个答案请用空格隔开）深度易经 3 我知道啦，你叫 深度易经, 3 岁了。 关于read命令的更多内容，比如输入密码，或者其他信息，请read --help查看。 12.1.5 其他需求的参数 有些脚本，输入的参数可能有默认值，使用var1=${var2:-defaultvalue}的方式，意思是变量var2如果存在赋值给var1，否则，把defaultvalue赋值给var1。 $ Birthday=&quot;2018-11-11&quot; $ Birthday=${Birthday:-`date`} $ echo $Birthday 2018-11-11 $ Birthday=${DefaultDate:-`date`} $ echo $Birthday echo $Birthday 2018年 11月 19日 星期一 21:48:35 CST $ Name=${Name:-&#39;尚未设置&#39;} $ echo $Name 尚未设置 有时，我们需要对参数再处理，比如对于路径的不同取舍，对某些合并参数等的提取，可能使用其他正则表达式截取部分字符串更合适，不过 Shell 还是提供了一些简单的截取功能。 ${var#pattern}：从头删除满足匹配模式pattern的最短子字符串。 ${var##pattern}：从头删除满足匹配模式pattern的最长子字符串。 ${var%pattern}：从尾删除满足匹配模式pattern的最短子字符串。 ${var%%pattern}：从尾删除满足匹配模式pattern的最长子字符串。 $\\$$ readme=/home/litianci/deepin-bible/Readme.md $\\$$ file=$\\$${readme$\\#$$\\#$*/} $\\$$ echo $\\$$file Readme.md $\\$$ dir=$\\$${readme%/*} $\\$$ echo $\\$$dir /home/litianci/deepin-bible $\\$$ stringchar=&quot;--folder=ucvideo&quot; $\\$$ option=$\\$${stringchar%=*} $\\$$ echo $\\$$option --folder $\\$$ value=$\\$${stringchar$\\#$*=} $\\$$ echo $\\$$value ucvideo 12.1.6 简单计算 bash 认为所有的输入都是字符串或者文本，如果你想让bash理解为数字，貌似只可以整数，就得声明，比如使用let,expr,bc等方式。 Total=1024 let div=$Total/8 # let表达式中间不可以有空格，所有参数必须为整数 div=`echo &quot;$Total / 8&quot; | bc` # bc对空格不敏感，可以有小数，但是结果还是取整 div=`echo &quot;$Total / 9.8 &quot; | bc` div=`echo &quot;$Total/9.8&quot; | bc` div=`expr $Total / 8` # expr 必须有空格，所有参数必须为整数 echo $RANDOM # random 生成随机数 同时使用((statement))也可用实现简单的数学语句， i=0 ((i++)) echo $i echo $((i++)) echo $((++i)) ((i=i+10)) echo $i 其中i++跟++i实现i数值加一，这两者区别类似C语言的规定，i++是先使用后递增一，++i是先递增一再使用。 12.2 shell 脚本的三大结构 学过编程语言的，应当多多少少都知道结构化编程语言的三大结构：顺序、分支和循环。shell 脚本支持这三种结构的。顺序执行就是逐行执行的命令，这里略过，下面介绍分支结构的语法。 12.2.1 分支结构的语法 12.2.1.1 if then 语句 语法结构如下， if [ condition1 ] ; then statement1 elif [ condition2 ] ; then statement2 else statement3 fi 解释 [ condition1 ]这里是测试语句，用于测试条件是否满足，满足则执行statement1语句。 elif 是else if的意思，用于多个测试条件。 其中elif和else部分可以不要。 fi其实是if的倒序写法。后面的case的结尾语句esac是同样的处理方式。 touch emptyfile if [ ! -s dsffyfile ] ; then echo &quot;emptyfile 是一个空文件&quot; fi 解释 [ ! -s emptyfile ]中-s判断一个文件存在且非空是为真，!是逻辑运算取反的意思。 测试条件，需要注意[]以及各个选项、运算符、参数均用空格隔开。 关于测试条件的更多信息，可以使用help test命令查看。 常见测试语句含义（help test截取） 测试语句 解释 -a FILE True if file exists. -b FILE True if file is block special. -c FILE True if file is character special. -d FILE True if file is a directory. -e FILE True if file exists. -f FILE True if file exists and is a regular file. -g FILE True if file is set-group-id. -h FILE True if file is a symbolic link. -L FILE True if file is a symbolic link. -k FILE True if file has its `sticky’ bit set. -p FILE True if file is a named pipe. -r FILE True if file is readable by you. -s FILE True if file exists and is not empty. -S FILE True if file is a socket. -t FD True if FD is opened on a terminal. -u FILE True if the file is set-user-id. -w FILE True if the file is writable by you. -x FILE True if the file is executable by you. -O FILE True if the file is effectively owned by you. -G FILE True if the file is effectively owned by your group. -N FILE True if the file has been modified since it was last read. FILE1 -nt FILE2 True if file1 is newer than file2 (according to modification date). FILE1 -ot FILE2 True if file1 is older than file2. FILE1 -ef FILE2 True if file1 is a hard link to file2. -z STRING True if string is empty. -n STRING True if string is not empty. STRING True if string is not empty. STRING1 = STRING2 True if the strings are equal. STRING1 != STRING2 True if the strings are not equal. STRING1 &lt; STRING2 True if STRING1 sorts before STRING2 lexicographically. STRING1 &gt; STRING2 True if STRING1 sorts after STRING2 lexicographically. -o OPTION True if the shell option OPTION is enabled. -v VAR True if the shell variable VAR is set. -R VAR True if the shell variable VAR is set and is a name reference. ! EXPR True if expr is false. EXPR1 -a EXPR2 True if both expr1 AND expr2 are true. EXPR1 -o EXPR2 True if either expr1 OR expr2 is true. arg1 OP arg2 Arithmetic tests. OP is one of -eq, -ne, -lt, -le, -gt, or -ge. 12.2.1.2 &amp;&amp; || 条件语句 该条件语句，是if..then单条语句的简写，语法结构如下， [ condition ] &amp;&amp; statement1 || statement2 其中[ condition ]跟if后的判断条件一致，&amp;&amp;后的语句 statement1是条件满足的执行语句，||后的语句statement2是条件不满足执行的语句。且&amp;&amp;和||可以根据需要略掉。 [ -s emptyfile ] || echo &quot;emptyfile 不存在或者是空文件&quot; [ -e ucdir ] &amp;&amp; echo &quot;可以继续执行&quot; || echo &quot;不存在该文件夹，请核实后继续&quot; 12.2.1.3 case 条件语句 类似C语言的switch分支语句，语法结构如下， case $var in &#39;value1&#39;) { statement1 } ;; &#39;value2&#39;) { statement2 } ;; *) { statement3 } ;; esac 解释 $var表示输入的某个变量，或者一个运行结果， *表示其他都不满足的执行语句。 case $destination in &#39;Shanghai&#39;) echo &quot;你想去上海啊！那边风景不错。&quot; ;; &#39;北京&#39;) echo &quot;北京天气不好，雾霾多！&quot; ;; *) echo &quot;不允许去其他地方！&quot; ;; esac 上面语句实现了对目的地的简单判断，支持汉字输入。 12.2.1.4 for...do 循环语句 类似C语言的for循环，语法结构如下， for i in array ; do statement done 实现使用参数i遍历数组array的所有子元素，并对每个i执行statement语句。看下面例子， for i in {1..5} ; do echo $i done 会输出如下结果， 1 2 3 4 5 再看几个例子， for file in `ls` ; do echo $file done for destination in 成都 上海 北京 广州 徐州 ; do echo 我很想去$destination done 对于循环，除了使用{m..n}列出从m到n的数字外，还可以用下面这种方式，关于(())作为数学计算的介绍，上面已经提及，这里不再赘述。 for ((i=1; i &lt;= 5 ; i++)) ; do echo $i done 12.2.1.5 while..do和until..do循环语句 可能我们更熟悉while语句，跟其他C系列的语言相似，语法结构如下， while condition ; do statement done 比如下面这段代码，实现了按序输出i i=0 while ((i&lt;5)) ; do echo $((++i)) done until的语法跟while类似，语法结构如下， until condition ; do statement done 只不过until条件是不满足才循环，相当于while的条件condition取反。不再举例子了。 12.3 流编辑器sed 流编辑器sed还算常用，操作方式跟vim有相似之处，下面摘抄几个例子，详细内容请参考man sed或者网上搜索vim sed相关资料。 sed &#39;s/Windows/Linux/g&#39; deepin.txt &gt; ok\\_deepin.txt 如果你常用vim会发现，当光标在某一行，在正常模式下输入:s/Windows/Linux/g实现该行所有的Windows被Linux替代。而sed命令会逐行执行，也就实现了对全文的替换。 12.4 shell脚本例子：转换 UC 缓存视频 阿里宝卡正当时，UC 看视频免流量是个多么大的诱惑。当然一些缓存视频，也是相当不错的。一般都会存在于 ./UCDownloads/videodata 文件夹下。文件一般是从0开始排序，顺序增加，可达几百个文件。另外还有一个index.m3u8文件。但是，因为网络协议对视频文件的第一要求是及时传达，而不是完整传达，导致部分视频文件丢失，甚至为空，所以需要妥善处理这些文件。 首先，我们需要知道如何把若干个视频文件转化为一个完整的视频文件，参阅网页，我们得知， 如果存在文件file.txt，其内容为 file &#39;1&#39; file &#39;2&#39; 则， ffmpeg -f concat -i input.txt -c copy output.mp4 即可把这些文件给转换为 MP4 格式的单个文件。 12.4.1 生成 file.txt文件 因为缓存文件都是数字，且文件夹内还有其他文件，包括 index.m3u8 的文件。 $ ls -1v +([0-9]) &gt; file.txt 解释 ls -1v中v表示按照把文件按照数字的大小排序，1表示按行显示。 +([0-9])只选择纯数字的文件。 对file.txt文件再处理，生成每行类似file '1'的样式。 $ sed &quot;s/.*/file &#39;&amp;&#39;/&quot; file.txt &gt; file2.txt $ mv file2.txt file.txt 解释 第一行实现对每一行行首行尾分别添加file '和'内容。 第二行，重命名，替换掉中间文件。 参考网页： https://unix.stackexchange.com/questions/33909/list-files-sorted-numerically https://superuser.com/questions/716001/how-can-i-get-files-with-numeric-names-using-ls-command https://www.shellhacks.com/sed-awk-add-end-beginning-line/ 12.4.2 生成 MP4 文件 前提需要你安装ffmpeg软件，如果没有，命令行sudo apt-get install ffmpeg安装。 $ ffmpeg -f concat -i file.txt -c copy film.mp4 12.4.3 做成一个 bash 脚本 下面是完整的代码 #!/bin/bash # 本脚本实现 UC 浏览器视频缓存内容转换为一个完整的 MP4 文件 # ucvideo echo &quot;语法: $0 &lt;UC浏览器视频缓存文件夹&gt; &lt;输出文件&gt;&quot; output=&#39;ucvideo.mp4&#39; output=${2:-$output} # 读第二个参数作为输出文件 if [ -e $output ] then echo &quot;已经存在 $output 文件，请更改输出文件名字！&quot; exit 1 fi ucdir=${1:-&#39;.&#39;} # 第一个参数作为缓存文件夹，默认为当前文件夹 if [ ! -d $ucdir ] then echo &quot;$ucdir 文件夹不存在！&quot; exit 2 fi cd $ucdir find ./ -size -1b -exec rm {} \\; # 删除空文件 ls -1v | grep -E &#39;^[0-9]+$&#39;| sed &quot;s/.*/file &#39;&amp;&#39;/&quot; &gt; file.txt # 把数字文件按序，并加上行首行尾，写入file.txt ffmpeg -f concat -i file.txt -c copy $output if [ ! $ucdir -ef $OLDPWD ];then mv $output $OLDPWD fi 当然为了方便直接使用，把他放在/usr/local/bin/ucvideo。 并为之添加执行权限 $ chmod u+x /usr/local/bin/ucvideo 当你从手机上复制缓存文件夹过来，就可以 $ ucvideo /&lt;指向缓存文件夹&gt;/ &lt;电影名称&gt;.mp4 期间发生了一个小问题，bash命令在脚本和终端下运行不一致。比如ls -1v +([0-9])可以在终端下运行，但是在脚本里就会报错。 bash &lt;&lt;&lt;'ls -1v +([0-9])'是无法运行的。所以上面解决方案就出现了部分调整。 也就是说一般在 deepin 下，sh或者/bin/sh指向/bin/dash，可以通过sudo dpkg-reconfigure dash关闭dash，改为默认的/bin/bash。其中dash跟bash还是存在一些小差异。 不过，通过echo $SHELL和查看/etc/passwd文件，看当前用户的shell，均为bash。但是在终端默认的shell可以执行ls -1v +([0-9])，在脚本里使用/bin/bash执行/bin/bash &lt;&lt;&lt;'ls -1v +([0-9])'执行就是报错。原因待查。 后来无意间在unixstackexchange发现，是没有启用glob扩展，在该行代码前一行加上shopt -s extglob即可。 关于glob的更多介绍， https://en.wikipedia.org/wiki/Glob_%28programming%29 http://www.tldp.org/LDP/abs/html/globbingref.html http://www.mamicode.com/info-detail-1227028.html 12.5 总结 本章简要介绍了bash的若干语法结构，并给出了一个小例子。 "],
["section.html", "13 ", " 13 workrave "],
["deepin-install.html", "14 深度系统安装 14.1 UEFI 和 legacy BIOS 区别和联系 14.2 优盘安装 14.3 安装遇到的问题", " 14 深度系统安装 本章讲介绍如何从优盘、光盘和硬盘安装深度操作系统，以及 LiveCD 模式简介。 参考网页： https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=135051 https://wiki.deepin.org/index.php?title=%E5%8E%9F%E7%94%9F%E5%AE%89%E8%A3%85 对以上作者表示感谢。 14.1 UEFI 和 legacy BIOS 区别和联系 参考网页： https://baike.baidu.com/item/UEFI/3556240?fr=aladdin 有些电脑过于老旧，不支持 UEFI 模式，或者没能设置启动（boot）为 UEFI 模式，导致安装失败。 14.2 优盘安装 一般电脑都是可以安装的，当然也存在安装失败的情况，对于遇到困难的用户，可以百度或者谷歌怎么解决。这里只叙述需要注意的问题。现在的电脑一般都带 USB 接口，支持优盘安装的。USB 接口，现有 1.0,2.0,3.0 等各种版本，更多了解可以参考百度百科。在采用优盘安装的时候，需要事先检查你电脑的 USB 接口是否工作正常，之前帮一同事安装系统，折腾了一上午才发现 USB 接口是坏的。更有甚者，部分电脑的 USB 3.0 的接口，可能不支持优盘安装，这个都是需要特别注意的。 接下来是制作优盘。你可以采用 windows 或者已经安装的深度操作系统制作优盘，当然对优盘大小等还是有限制的，一般大于 8G 为宜。 14.2.1 第一步下载并校验 deepin.iso 文件 本节转载自深度维基百科，有改动。对前人的辛勤工作，表示感谢。 官方镜像 访问 deepin 社区下载页面 ，下载深度操作系统系统最新版本的镜像文件（以便您能够体验到最新特性）。（据我本人的经验，如果你没有百度 VIP 账号，不建议从百度网盘下载。国内从官网或者 sourceforge相对快一点，也不是绝对的，可以根据实际情况选用不同的下载点）注意：为了更加专注系统的发展，deepin 15.4及后续版本将不再提供32位官方iso镜像，如需获取和技术支持，请发送邮件到support@deepin.org。 MD5校验 下载深度操作系统镜像完成后，需要对其进行校验，非官方或不完整的镜像将不能用于深度操作系统的安装： Windows系统：下载Hash软件 ，校验您下载的镜像的MD5值与下载页面 提供的 MD5 值是否一致。( MD5 值在立即下载按钮下方) Linux系统：在对应的镜像文件下，打开深度终端，执行md5sum deepin-xxx.iso命令，请确认下载的镜像的 MD5 值与下载页面提供的 MD5 值是否一致。( MD5 值在立即下载按钮下方)。说明：deepin-xxx.iso即为下载的系统镜像文件名，可使用 Tab 键自动补全文件名。 14.3 安装遇到的问题 参考网页： https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=146222 https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=146224 基本全文转载，有改动。已获许可。 "],
["software-install.html", "15 软件安装 15.1 npm 软件的安装 15.2 veil 软件安装 15.3 dpkg 安装 15.4 其他安装方式 15.5 you-get 软件的安装 15.6 字体的安装 15.7 输入法的安装", " 15 软件安装 这里会介绍如下几种安装方式， 直接双击安装 apt 安装 dpkg 安装 .run 类型的文件安装 其他软件安装，比如 you-get 的安装 字体的安装 源码安装 输入法的安装 iso 文件安装 pandoc 安装 15.1 npm 软件的安装 这里以 you-get 软件为例，介绍 npm 软件的安装方式。 15.2 veil 软件安装 其他发行版可以直接用 apt-get 直接安装的，比如 veil, $ sudo apt-get install veil 在 Kali Linux 就可以直接运行，但是在深度操作系统下就无法下载，这个时候不妨网上搜索一下，加入私有源。当然最好的是搜到这个软件的官网，比如 veil 的官网：https://github.com/Veil-Framework/Veil，按照原作者的方法安装，也是不错的。 $ sudo apt-get -y install git $ git clone https://github.com/Veil-Framework/Veil.git $ cd Veil/ $ cd setup $ sudo ./setup.sh -c 这样一路点击确认下来，慢慢等待，就可以成功安装 veil 了，当然还需要对 setup.sh 文件检测操作系统的代码改一改，让他支持 deepin。详情见pull request。用方法有所变样。 也可以到 debian 软件包库去搜索，相关的软件包，选择合适的版本安装。不过 veil 没有对应的 deb 包。这是一个比较庞大的软件，估计也不会有一个小的包。 15.3 dpkg 安装 15.4 其他安装方式 很多软件，由于依赖或者其他原因，安装起来特别费劲，对于初学者，不啻于一场灾难。有好事者，就提供了各种一键安装包。下面介绍两个，限于本人水平，也就只知道这俩，有同仁知道更多的谢谢发表评论。 15.4.1 bitnami 官网：https://bitnami.com/stacks 提供一键安装软件包，或者虚拟机级别文件等。有需要的可以去查询，肯定有你所需要的。比如 gitlab，OwnCloud 等等 15.4.2 turnkeylinux 官网：https://www.turnkeylinux.org/ 对于常见的 gitlab,lampp等提供虚拟机安装包，可以尽情享受快捷。 另外，我常用的 xampp 一键安装包，却是从其他网站上下载的。如果你安装一个软件特别费劲，（不包含无法破解软件的哦）不妨试试搜索一下 “xxx 一键安装包”,看看有没有其他人已经帮你解决这个问题了。 15.5 you-get 软件的安装 参考网页： https://github.com/soimort/you-get 根据 you-get 源码网站的提示，在 deepin 下，用如下命令安装，较为合适。 $ sudo pip3 install you-get 但是，你可能会发现，自己的电脑没有安装 pip3 软件。试着 sudo apt-get install pip3 也不存在这个软件包啊。接着百度 how to install pip3，找到一大堆页码。参考这个，如下命令安装。 $ sudo apt-get install python3-pip python3-dev build-essential 这样就安装好了 pip3，我的理解，pip3 就是 python3-pip 的意思，不知此解对不对。那么接下来安装 you-get 就容易多啦。 $ sudo pip3 install you-get 如果需要更新 you-get，可以如下。 $ sudo pip3 install --upgrade you-get 对于 you-get 如何使用，这里就不赘述啦。详见官网说明。 15.6 字体的安装 有些书籍的制作需要特殊的字体，在 Windows、Mac 下安装字体比较简单，在 Deepin 下安装字体同样很简单。参考这里， 下载需要的字体，下面以安装交大论文需要的字体为例，网上下好需要的字体，解压缩后，双击安装即可，也可以仿照上面网页提供的方式安装。 $ mkdir ~/.fonts $ cp *.ttf ~/.fonts # 当前用户可用新字体 $ sudo cp *.ttf /usr/share/fonts/local/ # 所有用户可以使用新字体 $ sudo fc-cache -f 解释 - cp *.ttf ~/.fonts 的 *.tff 表示你下载的那些字体，需要你修改为对应字体的路径。 15.7 输入法的安装 这里以搜狗输入法为例，讲解怎么在没有安装搜狗输入法的 Linux 桌面发行版上安装 搜狗输入法，其实深度操作系统自带搜狗输入法的。当然第一步百度搜索了，搜索到搜狗输入法的 Linux 专用版网站，上面网址如果不对，请继续搜索，毕竟某搜索网址广告比较厉害，不一定就第一时间提供有用的答案。进入官网，下载对应 *.deb 文件，使用命令 $ sudo dpkg -i /path/to/***.deb 就可以安装了。本来这个输入法安装应该放在上面的，但是考虑到很多人找不到怎么安装，特来说一下。深度操作系统下，可以直接双击下载的 **.deb 安装包的，一会就会自动安装完。不过汉语简体版的深度操作系统已经自带了该输入法。 "],
["manager-user.html", "16 管理账户 16.1 引言 16.2 创建账户", " 16 管理账户 16.1 引言 本章会涉及到 账户(user account)管理 账户组管理 其他方式的账户管理 深度操作系统安装过程中，会引导你设置一个普通账户，非根账户，也就是没有最高权限的普通账户。当有家人、朋友或者同事要使用我们的电脑的时候，可能要涉及到账户的添加和权限管理。这就是本章要讨论的内容。为了更方便的管理多个具有相同权限的账户，还会涉及到账户组的设置等。接下来会讲到怎么使用 useradd,usermod 等命令，配置自家目录、默认的 shell、分组、以及账户和组编号等。 16.2 创建账户 为了更好的分配资源权限，保护信息安全，为某些使用者创建新的账户还是很有必要的。下面介绍，在深度操作系统下，两种创建账户的方式：图像方式（GUI），命令方式（Shell）。 16.2.1 图形方式 如下图所示，创建账户是非常简单的，打开设置侧栏，找到账户相关的那一部分，点击创建账户，进入到下图，填上用户名和密码等需要的数据，就可以了。 图形方式创建账户 如果需要更改头像、设置全名、更改密码、设置是否自动登录免密码登录，可以选中需要修改的账户，点击进去就可以啦。 图形方式配置账户 图形方式配置账户 图形方式默认创建的账户是普通账户，比如是 phptester 账户，在 /etc/passwd,/etc/group 会出现 phptester 相关的信息。有兴趣的读者，可以先去看看上述俩文件，后面还会对这俩文件作进一步的讲解。 16.2.2 命令方式 "],
["chap-server-intro.html", "17 服务器简介", " 17 服务器简介 通过阅读本章，你将会了解到以下几项内容。 管理 Linux 服务器 访问远程或局域网服务器 服务器的本地或远程日志记录 监控服务器 服务器的开启终止与状态查询 深度操作系统不仅仅是桌面办公的操作系统，还可以作为服务器使用。当然，也可根据自己的需要，用把深度桌面操作系统作为办公环境，另外安装个redhat/centos或者debian的服务器，以求更稳定的服务器。 "],
["web-server-.html", "18 Web Server 的搭建与运行 18.1 面向开发的一键安装类型 18.2 关注效率稳定的搭建方法", " 18 Web Server 的搭建与运行 随着互联网技术的发展，网络开发越来越普及，越来越多的内容以网页的形式呈现。掌握一些网站服务器知识还是挺实用的。 18.1 面向开发的一键安装类型 前面我们提到了几个教学软件， 18.2 关注效率稳定的搭建方法 "],
["-windows-samba-.html", "19 与 Windows 共享文件打印机的 samba 服务 19.1 Samba 文件传输服务简介 19.2 深度自带 samba 的使用 19.3 关于 samba 的配置 19.4 例：借助安卓软件 U-File 实现手机电脑互传", " 19 与 Windows 共享文件打印机的 samba 服务 通过阅读本章，你将会了解到以下几项内容。 深度系统如何跟Windows系统共享文件、打印机； bash进行判断和简单数学计算 bash 的流程结构 实现把UC视频缓存变为普通视频文件的脚本 Windows 局域网中，为了方便互传文件或者打印，常常开启文件夹共享。在网上邻居里，能够看到其他人共享的文件夹，方便下载甚至上传。当前Windows局域网的通信工具也有一些，基本都支持文件互传，比如飞鸽传书（跨平台支持苹果、Linux和安卓）、imo内网通、RTX腾讯通（貌似停更在2015版）、飞秋（貌似停更在2013版）、微软LYNC（貌似停更在2013版）等。对于互联网，除了FTP、SCP和SSH外，QQ（深度系统自带），安司密信、钉钉（暂时不支持Linux平台）等也是不错的选择。 但是，对于局域网的Deepin深度用户来讲，除了iptux信使（只支持Linux、Mac，号称GNU/Linux版飞鸽传书）、飞鸽传书（最新版跨平台支持Linux）外，还可以安装samba 文件传输服务器。 19.1 Samba 文件传输服务简介 参考网页： https://docs.microsoft.com/en-us/windows/desktop/FileIO/microsoft-smb-protocol-and-cifs-protocol-overview https://www.cnblogs.com/LittleHann/p/6916326.html Samba 是一种网络文件共享的应用程序，基于微软制定的SMB（Server Message Block）通信协议，被很多种操作系统，比如Windows、OS2、Linux等，作为CS（Client-Server客户端服务器端）的网络架构。通过基于SMB的samba，Linux系统就可以愉快的跟Windows系统共享文件和打印机。 在Samba的帮助下，Windows看Linux电脑的文件和打印机，仿佛就是自家的，反过来亦然。 19.2 深度自带 samba 的使用 参考网页： https://wiki.deepin.org/wiki/%E6%B7%B1%E5%BA%A6%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%99%A8 其实 samba 已经被深度文件管理器集成了。通过搜索深度文件管理的源码，会发现很多samba 相关的代码。也就是说，作为用户，我们不需要再单独安装samba服务了。 19.2.1 共享本地文件 在文件管理器界面上，右键单击文件夹。 选择 共享文件夹。 勾选 共享此文件夹。 根据需要设置 共享名、权限 、匿名访问 后关闭标签。 在文件管理器界面上，点击 Icon_menu 。 选择 设置共享密码。 输入共享密码。 点击 确定。 注意： 取消勾选 共享此文件夹 可以取消文件共享，也可以右键单击文件，选择 取消共享。 有可能部分文件夹由于缺乏相应权限无法共享，请安装前面章节介绍更改权限的方法重新进行共享设置。 19.2.2 访问共享文件 局域网中其他用户共享的文件一般都可以在网络邻居中找到，您也可以通过网络邻居访问共享文件。 输入局域网用户的共享地址，按下键盘上的 Enter 键。（如：smb://xxx.xxx.xxx.xxx/share） 输入用户名密码或者匿名访问。 未加密的网络文件可以匿名访问，不需要输入用户名和密码。 加密的网络文件会弹出登陆框，输入账号和密码之后才能访问。如果在用户名密码提示框中勾选 记住密码 ，再次访问不再需要密码。 点击 连接。 19.2.3 我的共享 当您设置了共享文件时，我的共享图标将会出现在导航栏上，当所有共享文件都取消共享后，我的共享图标自动从侧边栏中移除。 19.2.4 可能存在的小问题 共享失败，显示缺乏权限。 如果文件夹不是自己的，设置为共享会弹出如下的问题框，采用管理员权限打开文件夹，成功共享。当然也可以跟根据异常提示，修改或添加/etc/samba/smb.conf的usershare owner only=false。 共享文件夹出现的问题 由于权限的问题，取消共享也会出现类似问题，也请采用管理员权限或者修改配置文件的方法取消共享。 取消共享出现的问题 19.3 关于 samba 的配置 19.3.1 手动安装 如果你的操作系统不是 deepin，或者尚未自带 samba 服务，则需要先安装 samba 才可以使用其功能。安装方法很简单， # 如果您的操作系统是 centos 或者 Fedora，redhat 等。 $ sudo yum install samba -y # 如果你的操作系统是 debian 系列，比如 ubuntu 等。 $ sudo apt-get install samba -y # 其他版本的操作系统略。 19.3.2 启动与停止 因为深度采用的 systemctl控制服务，所以可以采用如下命令， $ sudo systemctl start smbd.service # 开启 $ sudo systemctl status smbd.service # 查看状态 $ systemctl status smbd # 查看状态不需要根权限 $ sudo systemctl stop smbd.service # 关闭 $ sudo systemctl restart smbd.service # 重启 其实smbd.service可以省略为smbd。当然，还可以用另外一种方式，直接调命令文件，启动这些命令。比如， $ sudo /etc/init.d/smbd start 这里是直接调用的smbd程序，最后的start可以换成stop,status和restart，效果跟上面systemctl的方式一致。对于status状态的查询，同样不需要root根权限。 对于redhat系列没有实测，查部分资料，把命令中smbd改为smb即可。 19.3.3 配置文件 Samba 的配置文件为/etc/samba/smb.conf。 vim 19.4 例：借助安卓软件 U-File 实现手机电脑互传 本例是建立在局域网上的手机和电脑的互传，先介绍局域网的两种建立方法。如果您已经配置好了局域网，请跳过这一步。 19.4.1 开启局域网 可以使用手机开热点或者电脑开热点的方法。 由于本人所处工作环境电脑接触互联网不太方便，常用手机开热点的方法蹭网。手机开好热点后，电脑连接到相关无线网，在电脑命令行输入hostname -I会显示电脑的IP地址，本机为192.168.43.45。也可用通过手机端查看已经连接到热点设备的IP地址。 深度操作系统支持开启无线网热点。控制中心-&gt;网络-&gt;热点-&gt;热点设置，即可进入无线网设置页面，如图??所示， 开启无线网热点 "],
["chap-network-security.html", "20 网络安全", " 20 网络安全 本章您可以了解到， 网络安全是啥 "],
["chap-yugong.html", "A 愚公移山", " A 愚公移山 徐悲鸿名画《愚公移山》 太行、 王屋二山， 方七百里， 高万仞， 本在冀州之南， 河阳之北。 北山愚公者， 年且九十， 面山而居。 惩山北之塞， 出入之迂也， 聚室而谋曰： 吾与汝毕力平险， 指通豫南， 达于汉阴， 可乎？杂然相许。 其妻献疑曰： 以君之力， 曾不能损魁父之丘， 如太行、 王屋何？ 且焉置土石？杂曰： 投诸渤海之尾， 隐土之北。遂率子孙荷担者三夫， 叩石垦壤， 箕畚运于渤海之尾。 邻人京城氏之孀妻有遗男， 始龀， 跳往助之。 寒暑易节， 始一返焉。 河曲智叟笑而止之曰： 甚矣， 汝之不惠！ 以残年余力， 曾不能毁山之一毛， 其如土石何？北山愚公长息曰： 汝心之固， 固不可彻， 曾不若孀妻弱子。 虽我之死， 有子存焉； 子又生孙， 孙又生子； 子又有子， 子又有孙； 子子孙孙无穷匮也， 而山不加增， 何苦而不平？河曲智叟亡以应。 操蛇之神闻之， 惧其不已也， 告之于帝。 帝感其诚， 命夸娥氏二子负二山， 一厝朔东， 一厝雍南。 自此， 冀之南， 汉之阴， 无陇断焉。 "],
["chap-makebook.html", "B 如何制作本书 B.1 准备工作 B.2 编译模板 B.3 文件布局 B.4 主要文件介绍", " B 如何制作本书 B.1 准备工作 本模板使用 bookdown 实现了由 R Markdown （Bookdown） -&gt; Markdown (Pandoc 标准) -&gt; -&gt; PDF 的一系列转换，其中用到的依赖有： R pandoc xetex 需要安装这些软件，才可以使用。 B.1.1 Linux 下使用 下面以深度操作系统15.5版本为例说明。安装过程中，请确保当前 rstudio 的版本高于 1.0.0, texlive 为2015年后的版本， pandoc 的版本高于 2.0.0。 $ sudo apt-get install r-base r-base-dev \\ rstudio texlive-full pandoc make 如果不能满足，请参考相关软件官网，下载最新版本。我的博客记录了如何安装最新版 texlive，有需要的可以去看看。pandoc官网有其安装教程。R 语言的安装方法官网镜像也可找到，这里就不赘述了，有问题可以邮件联系。 曾经在 Lubuntu 下试着安装过。一般先安装 make，运行命令，仍旧出错，提示没有RScript，接着安装r-base r-base-dev。再接着，sudo make还是出错。最后是pandoc版本问题了。由于 Lubuntu 版本太老，没能更新好。总结一下， $ sudo apt-get install make r-base r-base-dev -y $ sudo make 第一次编译，可能需要安装很多软件，请静静等待。后面，直接运行下面这条语句，实现编译。 $ make B.1.2 Windows 下使用 略 B.1.3 苹果操作系统下使用 略 B.2 编译模板 B.2.1 第一种编译方法 —— 命令行编译 模板默认使用GNUMake构建，后续如无特殊说明，默认执行命令的文件夹以及当前文件夹均为本模板的根目录。对于部分用户，第一次编译可能需要下载很多文件，最好联网编译，简言之首次编译请联网。如果第一次编译成功，后面再次编译则不需要联网。 $ make B.2.2 第二种编译方法 —— RStudio编译 在已经安装 RStudio 的前提下，也可手动编译。打开 RStudio 软件，在弹出的界面，左上角点击 File-&gt;Open Project，选中 ./deepin-bible.Rproj 文件打开，点击右上角靠下的一栏，有个 Build 格，会出现 Build Book 等按钮。 点击 Build Book 就会生成 PDF 书籍了，位于 ./_book/deepin-bible.pdf 。本质上讲，第二种编译方法是调用的第一种编译方法，只不过方便懒得写命令行的用户。 B.2.3 字数统计 如果需要统计字数，先生成文件，然后执行如下命令，特别提醒先编译书籍才可以统计字数。 $ make wordcount B.2.4 本书编译的 R 各包信息 ## R version 3.4.4 (2018-03-15) ## Platform: x86_64-pc-linux-gnu (64-bit) ## Running under: Deepin 15 ## ## Matrix products: default ## BLAS: /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.8.0 ## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.8.0 ## ## locale: ## [1] LC_CTYPE=zh_CN.UTF-8 ## [2] LC_NUMERIC=C ## [3] LC_TIME=en_US.UTF-8 ## [4] LC_COLLATE=zh_CN.UTF-8 ## [5] LC_MONETARY=zh_CN.UTF-8 ## [6] LC_MESSAGES=zh_CN.UTF-8 ## [7] LC_PAPER=zh_CN.UTF-8 ## [8] LC_NAME=C ## [9] LC_ADDRESS=C ## [10] LC_TELEPHONE=C ## [11] LC_MEASUREMENT=zh_CN.UTF-8 ## [12] LC_IDENTIFICATION=C ## ## attached base packages: ## [1] stats graphics grDevices utils datasets ## [6] base ## ## other attached packages: ## [1] knitr_1.20 ## ## loaded via a namespace (and not attached): ## [1] compiler_3.4.4 backports_1.1.2 magrittr_1.5 ## [4] bookdown_0.7.13 rprojroot_1.3-2 htmltools_0.3.6 ## [7] tools_3.4.4 rstudioapi_0.7 yaml_2.2.0 ## [10] Rcpp_0.12.18 stringi_1.2.4 rmarkdown_1.10 ## [13] methods_3.4.4 stringr_1.3.1 digest_0.6.17 ## [16] xfun_0.3 evaluate_0.11 B.3 文件布局 使用 tree 命令所得。为了篇幅，删除了部分文件名。 . ├── bib │   ├── book.bib │   └── packages.bib ├── bin │   ├── linux_x64 │   └── linux_x86 ├── _bookdown.yml ├── css │   └── style.css ├── deepin-bible.Rproj ├── images │   ├── about-us_img-2.jpg │   └── zhifubaozhifu.png ├── imakeidx.ist ├── index.Rmd ├── latex │   ├── content.tex │   └── template.tex ├── LICENSE ├── Makefile ├── _output.yml ├── README.md ├── _render.R ├── rmd │   ├── 000-intro.Rmd │   └── 899-appendix-history.Rmd ├── sjtuthesis.cfg └── sjtuthesis.cls B.4 主要文件介绍 B.4.1 模板文件 格式控制文件控制着论文的表现形式，包括 ./sjtuthesis.cfg 和 ./sjtuthesis.cls。 其中，cls控制论文主体格式，cfg为配置文件。上述文件全部来自最新（2018-12-12）上海交通大学学位论文 模板 B.4.2 各章源文件 主要位于 ./rmd/ 文件夹。另外目录和模板的内容以 形式存放在 ./latex/ 文件夹下。各文件的详细说明见第C章。 B.4.3 配置文件 主要为 ./index.Rmd 文件，另外两个配置文件(./_bookdown.yml、./_output.yml)没有特殊需求不需要更改。 对于 ./index.Rmd 文件，书名、作者等信息直接更改为自己的即可。由于本文采用的上海交大论文模板，一些配置不建议修改。如果想修改书籍字体，比如 classoption: [doctor, openright, twoside， fontset=adobe] ，就表示中文字体修改为 adobe 系列的字体。可供选择的中文字体：fandol(Fandol 开源字体)、windows(Windows 系统下的中文字体)、mac(macOS 系统下的华文字体)、ubuntu(Ubuntu 系统下的文泉驿和文鼎字体)、adobe(Adobe 公司的中文字体)、founder(方正公司的中文字体)，默认根据操作系统自动配置。 如果打算使用本文的英文模板，可采用如下方式，在classoption: [doctor, openright, twoside， fontset=adobe]添加 “english”，比如classoption: [doctor, openright, twoside， fontset=adobe, english]。 B.4.4 图片文件夹 images images 文件夹放置了需要插入文档中的图片文件(支持PNG/JPG/PDF/EPS格式的图片)，可以在按照章节划分子目录。 模板文件中使用\\graphicspath命令定义了图片存储的顶层目录，在插入图片时，顶层目录名images可省略。 B.4.5 参考文献数据库bib 目前参考文件数据库目录只存放一个参考文件数据库 ./bib/book.bib，而 ./bib/packages.bib 是书籍编译参考的包信息。 关于参考文献引用，可参考附录??中的例子。 B.4.6 辅助文件 ./deepin-bible.Rproj 项目文件，方便使用 rstudio 打开，如果仅使用 make，可以不要。 ./_render.R 渲染文件，复制自谢益辉Bookdown中文模板，致谢。 ./Makefile make 的文件，综合上海交通大学学位论文 模板和谢益辉Bookdown中文模板。 ./_book/ 最终生成文件所在文件夹。 ./_bookdown_files/ 过程中生成的文件所在文件夹。 ./bin/，./imakeidx.ist 是索引引擎及索引模板文件。 ./css/ 用于生成非 PDF 书籍的模板，编译本书暂时用不到。 "],
["chap-chapters.html", "C 各章格式说明 C.1 章：前言 C.2 前言后的部分章节 C.3 部分：第一部分简介 C.4 各部分内部的章 C.5 部分：附录及其他 C.6 附录内部各章 C.7 后缀部分", " C 各章格式说明 Bookdown 编译各 Rmd 文件时，是按照文件名的字母排序拼接在一起的，故而我们不需要专门写一个文件来组织各章节，但是为了更好的利用这一排序规则，需要对文件名稍作调整。本模板的文件名采用如下命名方式， xxx-name.Rmd。其中 xxx 表示从 000 到 999，第一位表示第几部分，后两位如果为 00 表示该部分的简介，如果是其他数字则表示章节。name 是对应章节的名字。一章一个文件。 由于自身水平所限，部分格式实现起来费劲，就采用直接书写 代码的形式实现了。 C.1 章：前言 前言作为一章，不属于书主体内容，位于本书开头，需要一些特殊设定。命名为./rmd/000-intro.Rmd。 样式如下， \\frontmatter \\pagestyle{main} # 前言 为什么要写这本书呢？起源于去武汉参观辛亥革命博物馆。 \\include{latex/content} 解释 第1、2行，表示下面属于前言部分，采用罗马数字对前言编号，页面格式属于正文格式。 第4、6行，表示前言内容。 第8行，表示接下来为目录部分。 为了减少文件个数，把文件格式以及目录也放在该文件了，但也造成了文件不专用的问题。请根据爱好，自行斟酌。 C.2 前言后的部分章节 前言后的部分章节，属于标准的 Markdown 文件，框架示例如代码所示。 # 作者简介 {#author} 这将是是一群深度操作系统爱好者的杰作！！！ 解释 第1行，标准 Markdown 语句，表示这是一章。 第3行，该章的具体内容，可以使用 或 Markdown 格式书写。 C.3 部分：第一部分简介 \\mainmatter \\pagestyle{main} \\partquote{合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。}{老 \\quad 子} \\partintro{ \\quad\\quad “话说天下大势，分久必合，合久必分”。 } # (PART) Linux 及 Deepin 入门 {#part:intro -} 解释 第1、2行，表示下面属于本文正文部分，采用阿拉伯数字对正文编号，页面格式属于正文格式。 第4行，用于添加第一部分简介的名言警句。 第6-8行，表示第一部分简介的具体内容。 第10行，表示第一部分名称为Linux 及 Deepin 入门，标签为 part:intro。 C.4 各部分内部的章 框架格式类似前言后的文件，如代码所示，略。 C.5 部分：附录及其他 \\partquote{这只是万里长征走完了第一步，以后的路程更长，工作更伟大，更艰苦。务必使同志们继续地保持谦虚、谨慎、不骄不躁的作风，务必使同志们继续地保持艰苦奋斗的作风。}{毛泽东} \\partintro{ \\quad\\quad 附录及其他部分，首先引用了中国的一篇古文《愚公移山》，目的是告诉自己要坚持坚持再坚持；其次讲述了本书的制作步骤，方便后来人对模板进行改编和再创作；再次介绍了本书的大致框架设计，提醒需要注意的问题；再次列举了写作中常见的 \\LaTeX 和 Bookdown 编写的示例；最后是常见问题解答以及本书的大事记。 } # (PART) 附录及其他 {#part:others -} # (APPENDIX) 附录 {#chap:appendix -} 解释 第1-5行，同框架示例 的介绍。 第7行，表示下面属于论文附录部分，采用天干顺序对附录编号。 C.6 附录内部各章 框架格式类似前言后的文件，如代码所示，略。 C.7 后缀部分 相关代码为 形式，包括索引和参考文献等，由模板自动生成，不用关心。 本章完全照抄交大论文模板的 排版例子，除了动了标题和多了这行话，运行良好，但是部分地方会多出括号来，请对照原文删除。 以下是一个无序列表的例子，列表的每个条目单独分段。 使用环境可以创建行内无序列表。 行内无序列表条目不单独分段，所有内容直接插入在原文的段落中。 使用环境和创建有序列表, 使用方法无序列表类似。 使用环境可以创建行内有序列表。 行内有序列表条目不单独分段，所有内容直接插入在原文的段落中。 使用环境可创建带有主题词的列表，条目语法是。 可以使用参数控制列表的样式， 详细可以参考WikiBooks。 比如一个自定义样式的行内有序列表 这里有举一个长公式排版的例子，来自： 使用宏包可以方便地输入SI单位制单位，例如可以得到。 这是全文唯一的一个四级标题。在这部分中将演示了mathtools宏包中可伸长符号（箭头、等号的例子）的例子。 \\[\\begin{eqnarray} f(x) &amp; \\xleftrightarrow[]{A=B} &amp; B \\\\ &amp; \\xleftharpoondown[below]{above} &amp; B \\nonumber \\\\ &amp; \\xLeftrightarrow[below]{above} &amp; B \\end{eqnarray}\\] 又如： \\[\\begin{align} \\label{eq:none} &amp; I(X_3;X_4)-I(X_3;X_4\\mid{}X_1)-I(X_3;X_4\\mid{}X_2) \\nonumber \\\\ = &amp; [I(X_3;X_4)-I(X_3;X_4\\mid{}X_1)]-I(X_3;X_4\\mid{}\\tilde{X}_2) \\\\ = &amp; I(X_1;X_3;X_4)-I(X_3;X_4\\mid{}\\tilde{X}_2) \\end{align}\\] 模板中定义了丰富的定理环境 algo(算法)，thm(定理)，lem(引理)，prop(命题)，cor(推论)，defn(定义)，conj(猜想)，exmp(例)，rem(注)，case(情形)， bthm(断言定理)，blem(断言引理)，bprop(断言命题)，bcor(断言推论)。 amsmath还提供了一个proof(证明)的环境。 这里举一个定理和证明的例子。 上面的公式例子中，有一些细节希望大家注意。微分号d应该使用直立体也就是用mathrm包围起来。 并且，微分号和被积函数之间应该有一段小间隔，可以插入得到。 斜体的\\(d\\)通常只作为一般变量。 i,j作为虚数单位时，也应该使用直立体为了明显，还加上了粗体，例如。斜体\\(i,j\\)通常用作表示序号。 其他字母在表示常量时，也推荐使用直立体譬如，圆周率\\(\\uppi\\)（需要upgreek宏包），自然对数的底\\(\\mathrm{e}\\)。 不过，我个人觉得斜体的\\(e\\)和\\(\\pi\\)很潇洒，在不至于引起混淆的情况下，我也用这两个字母的斜体表示对应的常量。 可以很方便地插入PDF、PNG、JPG格式的图片。 插入PNG/JPG的例子如所示。 这两个水平并列放置的图共享一个图标题(table caption)，没有各自的小标题。 这里还有插入EPS图像和PDF图像的例子，如图和图。这里将EPS和PDF图片作为子图插入，每个子图有自己的小标题。子图标题使用subcaption宏包添加。 更多关于 插图的例子可以参考。 图和图都有比较长图标题，通过对比发现，图的换行效果更好一些。 其中使用了minipage环境来限制整个浮动体的宽度。 当插图中组成部件由数字或字母等编号表示时，可在插图下方添加图注进行说明，如图所示。 图是一张流程图示意。使用tikz环境，搭配四种预定义节点（、、和），可以容易地绘制出流程图。 这一节给出的是一些表格的例子，如表所示。 下面一个是一个更复杂的表格，用threeparttable实现带有脚注的表格，如表。 具有将参考文献内容和表现形式分开管理的能力，涉及三个要素：参考文献数据库、参考文献引用格式、在正文中引用参考文献。 这样的流程需要多次编译： 参考文献数据库(thesis.bib)的条目，可以从Google Scholar搜索引擎、CiteSeerX搜索引擎中查找，文献管理软件Papers、Mendeley、JabRef也能够输出条目信息。 下面是在Google Scholar上搜索到的一条文献信息，格式是纯文本： 推荐修改后在bib文件中的内容为： 按照教务处的要求，参考文献外观应符合国标GBT7714的要求。 在模板中，表现形式的控制逻辑通过biblatex-gb7714-2015包实现，基于{Bib}管理文献。在目前的多数TeX发行版中，可能都没有默认包含biblatex-gb7714-2015，需要手动安装。 正文中引用参考文献时，用可以产生上标引用的参考文献， 如。 使用则可以产生水平引用的参考文献，例如。 请看下面的例子，将会穿插使用水平的和上标的参考文献：关于书的，关于期刊的， 会议论文， 硕士学位论文，博士学位论文，标准文件，技术报告，电子文献，用户手册。 总结一些注意事项： 原先ctexbook文档类和listings宏包配合使用时，代码在换页时会出现莫名其妙的错误，后来经高人指点，顺利解决了。 感兴趣的话，可以看看。 这里给使用listings宏包插入源代码的例子，这里是一段C代码。 另外，listings宏包真可谓博大精深，可以实现各种复杂、漂亮的效果，想要进一步学习的同学，可以参考 。 algorithmicx 比 algorithmic 增加了一些命令。 示例如算法和算法， 后者的代码来自。 algorithmicx的详细使用方法见。 使用算法宏包时，算法出现的位置很多时候不按照tex文件里的书写顺序, 需要强制定位时可以使用 这是写在算法前面的一段话，在生成的文件里它会出现在算法前面。 这是写在两个算法中间的一段话，当算法不使用时它也会出现在算法前面。 对于很长的算法，单一的算法块是不能自动跨页的 ， 会出现的情况有： 解决方法有： 这是写在算法后面的一段话， 但是当算法不使用时它会出现在算法 甚至算法前面。 对于算法的索引要注意和的位置, 必须是先再， 否则会出现生成的编号跟对应算法上显示不一致的问题。 根据Werner的回答 增加了和的支持，见算法。 "],
["chap-rmarkdown.html", "D RMarkdown/Bookdown 排版示例 D.1 Markdown syntax D.2 Markdown extensions by bookdown D.3 R code D.4 Figures D.5 Tables D.6 Cross-references D.7 Custom blocks D.8 Citations D.9 Index D.10 HTML widgets", " D RMarkdown/Bookdown 排版示例 本文无意全文翻译 RMarkdown/Bookdown 的使用方法，只是简单的复制，详细内容请参考页面： https://rmarkdown.rstudio.com/lesson-1.html https://bookdown.org/yihui/bookdown/ https://bookdown.org/yihui/bookdown/components.html http://pandoc.org/ 以下为全文复制 https://bookdown.org/yihui/bookdown/components.html ，有改动。 This chapter demonstrates the syntax of common components of a book written in bookdown, including code chunks, figures, tables, citations, math theorems, and equations. The approach is based on Pandoc, so we start with the syntax of Pandoc’s flavor of Markdown. D.1 Markdown syntax In this section, we give a very brief introduction to Pandoc’s Markdown. Readers who are familiar with Markdown can skip this section. The comprehensive syntax of Pandoc’s Markdown can be found on the Pandoc website http://pandoc.org. D.1.1 Inline formatting You can make text italic by surrounding it with underscores or asterisks, e.g., _text_ or *text*. For bold text, use two underscores (__text__) or asterisks (**text**). Text surrounded by ~ will be converted to a subscript (e.g., H~2~SO~4~ renders H2SO4), and similarly, two carets (^) produce a superscript (e.g., Fe^2+^ renders Fe2+). To mark text as inline code, use a pair of backticks, e.g., `code`.1 Small caps can be produced by the HTML tag span, e.g., &lt;span style=&quot;font-variant:small-caps;&quot;&gt;Small Caps&lt;/span&gt; renders Small Caps. Links are created using [text](link), e.g., [RStudio](https://www.rstudio.com), and the syntax for images is similar: just add an exclamation mark, e.g., ![alt text or image title](path/to/image). Footnotes are put inside the square brackets after a caret ^[], e.g., ^[This is a footnote.]. We will talk about citations in Section D.8. D.1.2 Block-level elements Section headers can be written after a number of pound signs, e.g., # First-level header ## Second-level header ### Third-level header If you do not want a certain heading to be numbered, you can add {-} after the heading, e.g., # Preface {-} Unordered list items start with *, -, or +, and you can nest one list within another list by indenting the sub-list by four spaces, e.g., - one item - one item - one item - one item - one item The output is: one item one item one item one item one item Ordered list items start with numbers (the rule for nested lists is the same as above), e.g., 1. the first item 2. the second item 3. the third item The output does not look too much different with the Markdown source: the first item the second item the third item Blockquotes are written after &gt;, e.g., &gt; &quot;I thoroughly disapprove of duels. If a man should challenge me, I would take him kindly and forgivingly by the hand and lead him to a quiet place and kill him.&quot; &gt; &gt; --- Mark Twain The actual output (we customized the style for blockquotes in this book): “I thoroughly disapprove of duels. If a man should challenge me, I would take him kindly and forgivingly by the hand and lead him to a quiet place and kill him.” — Mark Twain Plain code blocks can be written after three or more backticks, and you can also indent the blocks by four spaces, e.g., ``` This text is displayed verbatim / preformatted ``` Or indent by four spaces: This text is displayed verbatim / preformatted D.1.3 Math expressions Inline LaTeX equations can be written in a pair of dollar signs using the LaTeX syntax, e.g., $f(k) = {n \\choose k} p^{k} (1-p)^{n-k}$ (actual output: \\(f(k)={n \\choose k}p^{k}(1-p)^{n-k}\\)); math expressions of the display style can be written in a pair of double dollar signs, e.g., $$f(k) = {n \\choose k} p^{k} (1-p)^{n-k}$$, and the output looks like this: \\[f\\left(k\\right)=\\binom{n}{k}p^k\\left(1-p\\right)^{n-k}\\] You can also use math environments inside $ $ or $$ $$, e.g., $$\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}$$ \\[\\begin{array}{ccc} x_{11} &amp; x_{12} &amp; x_{13}\\\\ x_{21} &amp; x_{22} &amp; x_{23} \\end{array}\\] $$X = \\begin{bmatrix}1 &amp; x_{1}\\\\ 1 &amp; x_{2}\\\\ 1 &amp; x_{3} \\end{bmatrix}$$ \\[X = \\begin{bmatrix}1 &amp; x_{1}\\\\ 1 &amp; x_{2}\\\\ 1 &amp; x_{3} \\end{bmatrix}\\] $$\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}$$ \\[\\Theta = \\begin{pmatrix}\\alpha &amp; \\beta\\\\ \\gamma &amp; \\delta \\end{pmatrix}\\] $$\\begin{vmatrix}a &amp; b\\\\ c &amp; d \\end{vmatrix}=ad-bc$$ \\[\\begin{vmatrix}a &amp; b\\\\ c &amp; d \\end{vmatrix}=ad-bc\\] D.2 Markdown extensions by bookdown Although Pandoc’s Markdown is much richer than the original Markdown syntax, it still lacks a number of things that we may need for academic writing. For example, it supports math equations, but you cannot number and reference equations in multi-page HTML or EPUB output. We have provided a few Markdown extensions in bookdown to fill the gaps. D.2.1 Number and reference equations To number and refer to equations, put them in the equation environments and assign labels to them using the syntax (\\#eq:label), e.g., \\begin{equation} f\\left(k\\right) = \\binom{n}{k} p^k\\left(1-p\\right)^{n-k} (\\#eq:binom) \\end{equation} It renders the equation below: \\[\\begin{equation} f\\left(k\\right)=\\binom{n}{k}p^k\\left(1-p\\right)^{n-k} \\tag{D.1} \\end{equation}\\] You may refer to it using \\@ref(eq:binom), e.g., see Equation (D.1). Equation labels must start with the prefix eq: in bookdown. All labels in bookdown must only contain alphanumeric characters, :, -, and/or /. Equation references work best for LaTeX/PDF output, and they are not well supported in Word output or e-books. For HTML output, bookdown can only number the equations with labels. Please make sure equations without labels are not numbered by either using the equation* environment or adding \\nonumber or \\notag to your equations. The same rules apply to other math environments, such as eqnarray, gather, align, and so on (e.g., you can use the align* environment). We demonstrate a few more math equation environments below. Here is an unnumbered equation using the equation* environment: \\begin{equation*} \\frac{d}{dx}\\left( \\int_{a}^{x} f(u)\\,du\\right)=f(x) \\end{equation*} \\[\\begin{equation*} \\frac{d}{dx}\\left( \\int_{a}^{x} f(u)\\,du\\right)=f(x) \\end{equation*}\\] Below is an align environment (D.2): \\begin{align} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] (\\#eq:align) \\end{align} \\[\\begin{align} g(X_{n}) &amp;= g(\\theta)+g&#39;({\\tilde{\\theta}})(X_{n}-\\theta) \\notag \\\\ \\sqrt{n}[g(X_{n})-g(\\theta)] &amp;= g&#39;\\left({\\tilde{\\theta}}\\right) \\sqrt{n}[X_{n}-\\theta ] \\tag{D.2} \\end{align}\\] You can use the split environment inside equation so that all lines share the same number (D.3). By default, each line in the align environment will be assigned an equation number. We suppressed the number of the first line in the previous example using \\notag. In this example, the whole split environment was assigned a single number. \\begin{equation} \\begin{split} \\mathrm{Var}(\\hat{\\beta}) &amp; =\\mathrm{Var}((X&#39;X)^{-1}X&#39;y)\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)((X&#39;X)^{-1}X&#39;)&#39;\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)X(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\sigma^{2}IX(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}\\sigma^{2} \\end{split} (\\#eq:var-beta) \\end{equation} \\[\\begin{equation} \\begin{split} \\mathrm{Var}(\\hat{\\beta}) &amp; =\\mathrm{Var}((X&#39;X)^{-1}X&#39;y)\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)((X&#39;X)^{-1}X&#39;)&#39;\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\mathrm{Var}(y)X(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}X&#39;\\sigma^{2}IX(X&#39;X)^{-1}\\\\ &amp; =(X&#39;X)^{-1}\\sigma^{2} \\end{split} \\tag{D.3} \\end{equation}\\] D.2.2 Theorems and proofs Theorems and proofs are commonly used in articles and books in mathematics. However, please do not be misled by the names: a “theorem” is just a numbered/labeled environment, and it does not have to be a mathematical theorem (e.g., it can be an example irrelevant to mathematics). Similarly, a “proof” is an unnumbered environment. In this section, we always use the general meanings of a “theorem” and “proof” unless explicitly stated. In bookdown, the types of theorem environments supported are in Table D.1. To write a theorem, you can use the syntax below: ```{theorem} Here is my theorem. ``` Table D.1: Theorem environments in bookdown. Environment Printed Name Label Prefix theorem Theorem thm lemma Lemma lem corollary Corollary cor proposition Proposition prp conjecture Conjecture cnj definition Definition def example Example exm exercise Exercise exr To write other theorem environments, replace ```{theorem} with other environment names in Table D.1, e.g., ```{lemma}. A theorem can have a name option so its name will be printed, e.g., ```{theorem, name=&quot;Pythagorean theorem&quot;} For a right triangle, if $c$ denotes the length of the hypotenuse and $a$ and $b$ denote the lengths of the other two sides, we have $$a^2 + b^2 = c^2$$ ``` If you want to refer to a theorem, you should label it. The label can be written after ```{theorem, e.g., ```{theorem, label=&quot;foo&quot;} A labeled theorem here. ``` The label option can be implicit, e.g., the following theorem has the label bar: ```{theorem, bar} A labeled theorem here. ``` After you label a theorem, you can refer to it using the syntax \\@ref(prefix:label). See the column Label Prefix in Table D.1 for the value of prefix for each environment. For example, we have a labeled and named theorem below, and \\@ref(thm:pyth) gives us its theorem number D.1: ```{theorem, pyth, name=&quot;Pythagorean theorem&quot;} For a right triangle, if $c$ denotes the length of the hypotenuse and $a$ and $b$ denote the lengths of the other two sides, we have $$a^2 + b^2 = c^2$$ ``` Theorem D.1 (Pythagorean theorem) For a right triangle, if \\(c\\) denotes the length of the hypotenuse and \\(a\\) and \\(b\\) denote the lengths of the other two sides, we have \\[a^2 + b^2 = c^2\\] The proof environments currently supported are proof, remark, and solution. The syntax is similar to theorem environments, and proof environments can also be named. The only difference is that since they are unnumbered, you cannot reference them. We have tried to make all these theorem and proof environments work out of the box, no matter if your output is PDF, HTML, or EPUB. If you are a LaTeX or HTML expert, you may want to customize the style of these environments anyway (see Chapter ??). Customization in HTML is easy with CSS, and each environment is enclosed in &lt;div&gt;&lt;/div&gt; with the CSS class being the environment name, e.g., &lt;div class=&quot;lemma&quot;&gt;&lt;/div&gt;. For LaTeX output, we have predefined the style to be definition for environments definition, example, and exercise, and remark for environments proof and remark. All other environments use the plain style. The style definition is done through the \\theoremstyle{} command of the amsthm package. Theorems are numbered by chapters by default. If there are no chapters in your document, they are numbered by sections instead. If the whole document is unnumbered (the output format option number_sections = FALSE), all theorems are numbered sequentially from 1, 2, …, N. LaTeX supports numbering one theorem environment after another, e.g., let theorems and lemmas share the same counter. This is not supported for HTML/EPUB output in bookdown. You can change the numbering scheme in the LaTeX preamble by defining your own theorem environments, e.g., \\newtheorem{theorem}{Theorem} \\newtheorem{lemma}[theorem]{Lemma} When bookdown detects \\newtheorem{theorem} in your LaTeX preamble, it will not write out its default theorem definitions, which means you have to define all theorem environments by yourself. For the sake of simplicity and consistency, we do not recommend that you do this. It can be confusing when your Theorem 18 in PDF becomes Theorem 2.4 in HTML. Theorem and proof environments will be hidden if the chunk option echo is set to FALSE. To make sure they are always shown, you may add the chunk option echo=TRUE, e.g., ```{theorem, echo=TRUE} Here is my theorem. ``` Below we show more examples2 of the theorem and proof environments, so you can see the default styles in bookdown. Definition D.1 The characteristic function of a random variable \\(X\\) is defined by \\[\\varphi _{X}(t)=\\operatorname {E} \\left[e^{itX}\\right], \\; t\\in\\mathcal{R}\\] Example D.1 We derive the characteristic function of \\(X\\sim U(0,1)\\) with the probability density function \\(f(x)=\\mathbf{1}_{x \\in [0,1]}\\). \\[\\begin{equation*} \\begin{split} \\varphi _{X}(t) &amp;= \\operatorname {E} \\left[e^{itX}\\right]\\\\ &amp; =\\int e^{itx}f(x)dx\\\\ &amp; =\\int_{0}^{1}e^{itx}dx\\\\ &amp; =\\int_{0}^{1}\\left(\\cos(tx)+i\\sin(tx)\\right)dx\\\\ &amp; =\\left.\\left(\\frac{\\sin(tx)}{t}-i\\frac{\\cos(tx)}{t}\\right)\\right|_{0}^{1}\\\\ &amp; =\\frac{\\sin(t)}{t}-i\\left(\\frac{\\cos(t)-1}{t}\\right)\\\\ &amp; =\\frac{i\\sin(t)}{it}+\\frac{\\cos(t)-1}{it}\\\\ &amp; =\\frac{e^{it}-1}{it} \\end{split} \\end{equation*}\\] Note that we used the fact \\(e^{ix}=\\cos(x)+i\\sin(x)\\) twice. Lemma D.1 For any two random variables \\(X_1\\), \\(X_2\\), they both have the same probability distribution if and only if \\[\\varphi _{X_1}(t)=\\varphi _{X_2}(t)\\] Theorem D.2 If \\(X_1\\), …, \\(X_n\\) are independent random variables, and \\(a_1\\), …, \\(a_n\\) are some constants, then the characteristic function of the linear combination \\(S_n=\\sum_{i=1}^na_iX_i\\) is \\[\\varphi _{S_{n}}(t)=\\prod_{i=1}^n\\varphi _{X_i}(a_{i}t)=\\varphi _{X_{1}}(a_{1}t)\\cdots \\varphi _{X_{n}}(a_{n}t)\\] Proposition D.1 The distribution of the sum of independent Poisson random variables \\(X_i \\sim \\mathrm{Pois}(\\lambda_i),\\: i=1,2,\\cdots,n\\) is \\(\\mathrm{Pois}(\\sum_{i=1}^n\\lambda_i)\\). Proof. The characteristic function of \\(X\\sim\\mathrm{Pois}(\\lambda)\\) is \\(\\varphi _{X}(t)=e^{\\lambda (e^{it}-1)}\\). Let \\(P_n=\\sum_{i=1}^nX_i\\). We know from Theorem D.2 that \\[\\begin{equation*} \\begin{split} \\varphi _{P_{n}}(t) &amp; =\\prod_{i=1}^n\\varphi _{X_i}(t) \\\\ &amp; =\\prod_{i=1}^n e^{\\lambda_i (e^{it}-1)} \\\\ &amp; = e^{\\sum_{i=1}^n \\lambda_i (e^{it}-1)} \\end{split} \\end{equation*}\\] This is the characteristic function of a Poisson random variable with the parameter \\(\\lambda=\\sum_{i=1}^n \\lambda_i\\). From Lemma D.1, we know the distribution of \\(P_n\\) is \\(\\mathrm{Pois}(\\sum_{i=1}^n\\lambda_i)\\). Remark. In some cases, it is very convenient and easy to figure out the distribution of the sum of independent random variables using characteristic functions. Corollary D.1 The characteristic function of the sum of two independent random variables \\(X_1\\) and \\(X_2\\) is the product of characteristic functions of \\(X_1\\) and \\(X_2\\), i.e., \\[\\varphi _{X_1+X_2}(t)=\\varphi _{X_1}(t) \\varphi _{X_2}(t)\\] Exercise D.1 (Characteristic Function of the Sample Mean) Let \\(\\bar{X}=\\sum_{i=1}^n \\frac{1}{n} X_i\\) be the sample mean of \\(n\\) independent and identically distributed random variables, each with characteristic function \\(\\varphi _{X}\\). Compute the characteristic function of \\(\\bar{X}\\). Solution. Applying Theorem D.2, we have \\[\\varphi _{\\bar{X}}(t)=\\prod_{i=1}^n \\varphi _{X_i}\\left(\\frac{t}{n}\\right)=\\left[\\varphi _{X}\\left(\\frac{t}{n}\\right)\\right]^n.\\] D.2.3 Special headers There are a few special types of first-level headers that will be processed differently in bookdown. The first type is an unnumbered header that starts with the token (PART). This kind of headers are translated to part titles. If you are familiar with LaTeX, this basically means \\part{}. When your book has a large number of chapters, you may want to organize them into parts, e.g., # (PART) Part I {-} # Chapter One # Chapter Two # (PART) Part II {-} # Chapter Three A part title should be written right before the first chapter title in this part. You can use (PART\\*) (the backslash before * is required) instead of (PART) if a part title should not be numbered. The second type is an unnumbered header that starts with (APPENDIX), indicating that all chapters after this header are appendices, e.g., # Chapter One # Chapter Two # (APPENDIX) Appendix {-} # Appendix A # Appendix B The numbering style of appendices will be automatically changed in LaTeX/PDF and HTML output (usually in the form A, A.1, A.2, B, B.1, …). This feature is not available to e-books or Word output. D.2.4 Text references You can assign some text to a label and reference the text using the label elsewhere in your document. This can be particularly useful for long figure/table captions (Section D.4 and D.5), in which case you normally will have to write the whole character string in the chunk header (e.g., fig.cap = &quot;A long long figure caption.&quot;) or your R code (e.g., kable(caption = &quot;A long long table caption.&quot;)). It is also useful when these captions contain special HTML or LaTeX characters, e.g., if the figure caption contains an underscore, it works in the HTML output but may not work in LaTeX output because the underscore must be escaped in LaTeX. The syntax for a text reference is (ref:label) text, where label is a unique label3 throughout the document for text. It must be in a separate paragraph with empty lines above and below it. The paragraph must not be wrapped into multiple lines, and should not end with a white space. For example, $(ref:foo)$ Define a text reference **here**. Then you can use (ref:foo) in your figure/table captions. The text can contain anything that Markdown supports, as long as it is one single paragraph. Here is a complete example: A normal paragraph. $(ref:foo)$ A scatterplot of the data `cars` using **base** R graphics. ```{r foo, fig.cap=&#39;(ref:foo)&#39;} plot(cars) # a scatterplot ``` Text references can be used anywhere in the document (not limited to figure captions). It can also be useful if you want to reuse a fragment of text in multiple places. D.3 R code There are two types of R code in R Markdown/knitr documents: R code chunks, and inline R code. The syntax for the latter is `r R_CODE`, and it can be embedded inline with other document elements. R code chunks look like plain code blocks, but have {r} after the three backticks and (optionally) chunk options inside {}, e.g., ```{r chunk-label, echo = FALSE, fig.cap = &#39;A figure caption.&#39;} 1 + 1 rnorm(10) # 10 random numbers plot(dist ~ speed, cars) # a scatterplot ``` To learn more about knitr chunk options, see @xie2015 or the web page http://yihui.name/knitr/options. For books, additional R code can be executed before/after each chapter; see before_chapter_script and after_chapter_script in Section ??. D.4 Figures By default, figures have no captions in the output generated by knitr, which means they will be placed wherever they were generated in the R code. Below is such an example. par(mar = c(4, 4, .1, .1)) plot(pressure, pch = 19, type = &#39;b&#39;) \\includegraphics[width=70%]{deepin-bible_files/figure-html/no-caption-1} The disadvantage of typesetting figures in this way is that when there is not enough space on the current page to place a figure, it may either reach the bottom of the page (hence exceeds the page margin), or be pushed to the next page, leaving a large white margin at the bottom of the current page. That is basically why there are “floating environments” in LaTeX: elements that cannot be split over multiple pages (like figures) are put in floating environments, so they can float to a page that has enough space to hold them. There is also a disadvantage of floating things forward or backward, though. That is, readers may have to jump to a different page to find the figure mentioned on the current page. This is simply a natural consequence of having to typeset things on multiple pages of fixed sizes. This issue does not exist in HTML, however, since everything can be placed continuously on one single page (presumably with infinite height), and there is no need to split anything across multiple pages of the same page size. If we assign a figure caption to a code chunk via the chunk option fig.cap, R plots will be put into figure environments, which will be automatically labeled and numbered, and can also be cross-referenced. The label of a figure environment is generated from the label of the code chunk, e.g., if the chunk label is foo, the figure label will be fig:foo (the prefix fig: is added before foo). To reference a figure, use the syntax \\@ref(label),4 where label is the figure label, e.g., fig:foo. To take advantage of Markdown formatting within the figure caption, you will need to use text references (see Section D.2.4). For example, a figure caption that contains _italic text_ will not work when the output format is LaTeX/PDF, since the underscore is a special character in LaTeX, but if you use text references, _italic text_ will be translated to LaTeX code when the output is LaTeX. If you want to cross-reference figures or tables generated from a code chunk, please make sure the chunk label only contains alphanumeric characters (a-z, A-Z, 0-9), slashes (/), or dashes (-). The chunk option fig.asp can be used to set the aspect ratio of plots, i.e., the ratio of figure height/width. If the figure width is 6 inches (fig.width = 6) and fig.asp = 0.7, the figure height will be automatically calculated from fig.width * fig.asp = 6 * 0.7 = 4.2. Figure D.1 is an example using the chunk options fig.asp = 0.7, fig.width = 6, and fig.align = 'center', generated from the code below: par(mar = c(4, 4, .1, .1)) plot(pressure, pch = 19, type = &#39;b&#39;) \\begin{figure} {\\includegraphics[width=90%]{deepin-bible_files/figure-html/pressure-plot-1} } \\end{figure} The actual size of a plot is determined by the chunk options fig.width and fig.height (the size of the plot generated from a graphical device), and we can specify the output size of plots via the chunk options out.width and out.height. The possible value of these two options depends on the output format of the document. For example, out.width = '30%' is a valid value for HTML output, but not for LaTeX/PDF output. However, knitr will automatically convert a percentage value for out.width of the form x% to (x / 100) \\linewidth, e.g., out.width = '70%' will be treated as .7\\linewidth when the output format is LaTeX. This makes it possible to specify a relative width of a plot in a consistent manner. Figure D.2 is an example of out.width = 70%. par(mar = c(4, 4, .1, .1)) plot(cars, pch = 19) \\begin{figure} \\includegraphics[width=70%]{deepin-bible_files/figure-html/cars-plot-1} \\end{figure} If you want to put multiple plots in one figure environment, you must use the chunk option fig.show = 'hold' to hold multiple plots from a code chunk and include them in one environment. You can also place plots side by side if the sum of the width of all plots is smaller than or equal to the current line width. For example, if two plots have the same width 50%, they will be placed side by side. Similarly, you can specify out.width = '33%' to arrange three plots on one line. Figure D.3 is an example of two plots, each with a width of 50%. par(mar = c(4, 4, .1, .1)) plot(pressure, pch = 19, type = &#39;b&#39;) plot(cars, pch = 19) \\begin{figure} \\includegraphics[width=50%]{deepin-bible_files/figure-html/multi-plots-1} \\includegraphics[width=50%]{deepin-bible_files/figure-html/multi-plots-2} \\end{figure} Sometimes you may have certain images that are not generated from R code, and you can include them in R Markdown via the function knitr::include_graphics(). Figure D.4 is an example of three knitr logos included in a figure environment. You may pass one or multiple image paths to the include_graphics() function, and all chunk options that apply to normal R plots also apply to these images, e.g., you can use out.width = '33%' to set the widths of these images in the output document. knitr::include_graphics(rep(&#39;images/bookdown/knit-logo.png&#39;, 3)) \\begin{figure} \\includegraphics[width=32.8%]{images/bookdown/knit-logo} \\includegraphics[width=32.8%]{images/bookdown/knit-logo} \\includegraphics[width=32.8%]{images/bookdown/knit-logo} \\end{figure} There are a few advantages of using include_graphics(): You do not need to worry about the document output format, e.g., when the output format is LaTeX, you may have to use the LaTeX command \\includegraphics{} to include an image, and when the output format is Markdown, you have to use ![](). The function include_graphics() in knitr takes care of these details automatically. The syntax for controlling the image attributes is the same as when images are generated from R code, e.g., chunk options fig.cap, out.width, and fig.show still have the same meanings. include_graphics() can be smart enough to use PDF graphics automatically when the output format is LaTeX and the PDF graphics files exist, e.g., an image path foo/bar.png can be automatically replaced with foo/bar.pdf if the latter exists. PDF images often have better qualities than raster images in LaTeX/PDF output. To make use of this feature, set the argument auto_pdf = TRUE, or set the global option options(knitr.graphics.auto_pdf = TRUE) to enable this feature globally in an R session. You can easily scale these images proportionally using the same ratio. This can be done via the dpi argument (dots per inch), which takes the value from the chunk option dpi by default. If it is a numeric value and the chunk option out.width is not set, the output width of an image will be its actual width (in pixels) divided by dpi, and the unit will be inches. For example, for an image with the size 672 x 480, its output width will be 7 inches (7in) when dpi = 96. This feature requires the package png and/or jpeg to be installed. You can always override the automatic calculation of width in inches by providing a non-NULL value to the chunk option out.width, or use include_graphics(dpi = NA). D.5 Tables For now, the most convenient way to generate a table is the function knitr::kable(), because there are some internal tricks in knitr to make it work with bookdown and users do not have to know anything about these implementation details. We will explain how to use other packages and functions later in this section. Like figures, tables with captions will also be numbered and can be referenced. The kable() function will automatically generate a label for a table environment, which is the prefix tab: plus the chunk label. For example, the table label for a code chunk with the label foo will be tab:foo, and we can still use the syntax \\@ref(label) to reference the table. Table D.2 is a simple example. knitr::kable( head(mtcars[, 1:8], 10), booktabs = TRUE, caption = &#39;A table of the first 10 rows of the mtcars data.&#39; ) Table D.2: A table of the first 10 rows of the mtcars data. mpg cyl disp hp drat wt qsec vs Mazda RX4 21.0 6 160.0 110 3.90 2.620 16.46 0 Mazda RX4 Wag 21.0 6 160.0 110 3.90 2.875 17.02 0 Datsun 710 22.8 4 108.0 93 3.85 2.320 18.61 1 Hornet 4 Drive 21.4 6 258.0 110 3.08 3.215 19.44 1 Hornet Sportabout 18.7 8 360.0 175 3.15 3.440 17.02 0 Valiant 18.1 6 225.0 105 2.76 3.460 20.22 1 Duster 360 14.3 8 360.0 245 3.21 3.570 15.84 0 Merc 240D 24.4 4 146.7 62 3.69 3.190 20.00 1 Merc 230 22.8 4 140.8 95 3.92 3.150 22.90 1 Merc 280 19.2 6 167.6 123 3.92 3.440 18.30 1 If you want to put multiple tables in a single table environment, wrap the data objects (usually data frames in R) into a list. See Table D.3 for an example. Please note that this feature is only available in HTML and PDF output. knitr::kable( list( head(iris[, 1:2], 3), head(mtcars[, 1:3], 5) ), caption = &#39;A Tale of Two Tables.&#39;, booktabs = TRUE ) Table D.3: A Tale of Two Tables. Sepal.Length Sepal.Width 5.1 3.5 4.9 3.0 4.7 3.2 mpg cyl disp Mazda RX4 21.0 6 160 Mazda RX4 Wag 21.0 6 160 Datsun 710 22.8 4 108 Hornet 4 Drive 21.4 6 258 Hornet Sportabout 18.7 8 360 When you do not want a table to float in PDF, you may use the LaTeX package longtable, which can break a table across multiple pages. To use longtable, pass longtable = TRUE to kable(), and make sure to include \\usepackage{longtable} in the LaTeX preamble (see Section ?? for how to customize the LaTeX preamble). Of course, this is irrelevant to HTML output, since tables in HTML do not need to float. knitr::kable( iris[1:55, ], longtable = TRUE, booktabs = TRUE, caption = &#39;A table generated by the longtable package.&#39; ) Table D.4: A table generated by the longtable package. Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa 5.4 3.4 1.7 0.2 setosa 5.1 3.7 1.5 0.4 setosa 4.6 3.6 1.0 0.2 setosa 5.1 3.3 1.7 0.5 setosa 4.8 3.4 1.9 0.2 setosa 5.0 3.0 1.6 0.2 setosa 5.0 3.4 1.6 0.4 setosa 5.2 3.5 1.5 0.2 setosa 5.2 3.4 1.4 0.2 setosa 4.7 3.2 1.6 0.2 setosa 4.8 3.1 1.6 0.2 setosa 5.4 3.4 1.5 0.4 setosa 5.2 4.1 1.5 0.1 setosa 5.5 4.2 1.4 0.2 setosa 4.9 3.1 1.5 0.2 setosa 5.0 3.2 1.2 0.2 setosa 5.5 3.5 1.3 0.2 setosa 4.9 3.6 1.4 0.1 setosa 4.4 3.0 1.3 0.2 setosa 5.1 3.4 1.5 0.2 setosa 5.0 3.5 1.3 0.3 setosa 4.5 2.3 1.3 0.3 setosa 4.4 3.2 1.3 0.2 setosa 5.0 3.5 1.6 0.6 setosa 5.1 3.8 1.9 0.4 setosa 4.8 3.0 1.4 0.3 setosa 5.1 3.8 1.6 0.2 setosa 4.6 3.2 1.4 0.2 setosa 5.3 3.7 1.5 0.2 setosa 5.0 3.3 1.4 0.2 setosa 7.0 3.2 4.7 1.4 versicolor 6.4 3.2 4.5 1.5 versicolor 6.9 3.1 4.9 1.5 versicolor 5.5 2.3 4.0 1.3 versicolor 6.5 2.8 4.6 1.5 versicolor Pandoc supports several types of Markdown tables, such as simple tables, multiline tables, grid tables, and pipe tables. What knitr::kable() generates is a simple table like this: Table: A simple table in Markdown. Sepal.Length Sepal.Width Petal.Length Petal.Width ------------- ------------ ------------- ------------ 5.1 3.5 1.4 0.2 4.9 3.0 1.4 0.2 4.7 3.2 1.3 0.2 4.6 3.1 1.5 0.2 5.0 3.6 1.4 0.2 5.4 3.9 1.7 0.4 You can use any types of Markdown tables in your document. To be able to cross-reference a Markdown table, it must have a labeled caption of the form Table: (\\#label) Caption here, where label must have the prefix tab:, e.g., tab:simple-table. If you decide to use other R packages to generate tables, you have to make sure the label for the table environment appears in the beginning of the table caption in the form (\\#label) (again, label must have the prefix tab:). You have to be very careful about the portability of the table generating function: it should work for both HTML and LaTeX output automatically, so it must consider the output format internally (check knitr::opts_knit$get('rmarkdown.pandoc.to')). When writing out an HTML table, the caption must be written in the &lt;caption&gt;&lt;/caption&gt; tag. For simple tables, kable() should suffice. If you have to create complicated tables (e.g., with certain cells spanning across multiple columns/rows), you will have to take the aforementioned issues into consideration. D.6 Cross-references We have explained how cross-references work for equations (Section D.2.1), theorems (Section D.2.2), figures (Section D.4), and tables (Section D.5). In fact, you can also reference sections using the same syntax \\@ref(label), where label is the section ID. By default, Pandoc will generate an ID for all section headers, e.g., a section # Hello World will have an ID hello-world. We recommend you to manually assign an ID to a section header to make sure you do not forget to update the reference label after you change the section header. To assign an ID to a section header, simply add {#id} to the end of the section header. Further attributes of section headers can be set using standard Pandoc syntax. When a referenced label cannot be found, you will see two question marks like ??, as well as a warning message in the R console when rendering the book. You can also create text-based links using explicit or automatic section IDs or even the actual section header text. If you are happy with the section header as the link text, use it inside a single set of square brackets: [Section header text]: example “[A single document]” via [A single document] There are two ways to specify custom link text: [link text][Section header text], e.g., “[non-English books][Internationalization]” via [non-English books][Internationalization] [link text](#ID), e.g., “Table stuff” via [Table stuff](#tables) The Pandoc documentation provides more details on automatic section IDs and implicit header references. Cross-references still work even when we refer to an item that is not on the current page of the PDF or HTML output. For example, see Equation (D.1) and Figure D.4. D.7 Custom blocks You can generate custom blocks using the block engine in knitr, i.e., the chunk option engine = 'block', or the more compact syntax ```{block}. This engine should be used in conjunction with the chunk option type, which takes a character string. When the block engine is used, it generates a &lt;div&gt; to wrap the chunk content if the output format is HTML, and a LaTeX environment if the output is LaTeX. The type option specifies the class of the &lt;div&gt; and the name of the LaTeX environment. For example, the HTML output of this chunk {block, type='FOO'} Some text for this block. will be this: &lt;div class=&quot;FOO&quot;&gt; Some text for this block. &lt;/div&gt; and the LaTeX output will be this: \\begin{FOO} Some text for this block. \\end{FOO} It is up to the book author how to define the style of the block. You can define the style of the &lt;div&gt; in CSS and include it in the output via the includes option in the YAML metadata. Similarly, you may define the LaTeX environment via \\newenvironment and include the definition in the LaTeX output via the includes option. For example, we may save the following style in a CSS file, say, style.css: div.FOO { font-weight: bold; color: red; } And the YAML metadata of the R Markdown document can be: --- output: bookdown::html_book: includes: in_header: style.css --- We have defined a few types of blocks for this book to show notes, tips, and warnings, etc. Below are some examples: R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under the terms of the GNU General Public License versions 2 or 3. For more information about these matters see http://www.gnu.org/licenses/. R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under the terms of the GNU General Public License versions 2 or 3. For more information about these matters see http://www.gnu.org/licenses/. R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under the terms of the GNU General Public License versions 2 or 3. For more information about these matters see http://www.gnu.org/licenses/. R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under the terms of the GNU General Public License versions 2 or 3. For more information about these matters see http://www.gnu.org/licenses/. R is free software and comes with ABSOLUTELY NO WARRANTY. You are welcome to redistribute it under the terms of the GNU General Public License versions 2 or 3. For more information about these matters see http://www.gnu.org/licenses/. The knitr block engine was designed to display simple content (typically a paragraph of plain text). You can use simple formatting syntax such as making certain words bold or italic, but more advanced syntax such as citations and cross-references will not work. However, there is an alternative engine named block2 that supports arbitrary Markdown syntax, e.g., ```{block2, type=&#39;FOO&#39;} Some text for this block [@citation-key]. - a list item - another item More text. ``` The block2 engine should also be faster than the block engine if you have a lot of custom blocks in the document, but its implementation was based on a hack, so we are not 100% sure if it is always going to work in the future. We have not seen problems with Pandoc v1.17.2 yet. One more caveat for the block2 engine: if the last element in the block is not an ordinary paragraph, you must leave a blank line at the end, e.g., ```{block2, type=&#39;FOO&#39;} Some text for this block [@citation-key]. - a list item - another item - end the list with a blank line ``` The theorem and proof environments in Section D.2.2 are actually implemented through the block2 engine. For all custom blocks based on the block or block2 engine, there is one chunk option echo that you can use to show (echo = TRUE) or hide (echo = FALSE) the blocks. D.8 Citations Although Pandoc supports multiple ways of writing citations, we recommend you to use BibTeX databases because they work best with LaTeX/PDF output. Pandoc can process other types of bibliography databases with the utility pandoc-citeproc (https://github.com/jgm/pandoc-citeproc), but it may not render certain bibliography items correctly (especially in case of multiple authors per item), and BibTeX can do a better job when the output format is LaTeX. With BibTeX databases, you will be able to define the bibliography style if it is required by a certain publisher or journal. A BibTeX database is a plain-text file (with the conventional filename extension .bib) that consists of bibliography entries like this: @Manual{R-base, title = {R: A Language and Environment for Statistical Computing}, author = {{R Core Team}}, organization = {R Foundation for Statistical Computing}, address = {Vienna, Austria}, year = {2016}, url = {https://www.R-project.org/}, } A bibliography entry starts with @type{, where type may be article, book, manual, and so on.5 Then there is a citation key, like R-base in the above example. To cite an entry, use @key or [@key] (the latter puts the citation in braces), e.g., @R-base is rendered as @R-base, and [@R-base] generates “[@R-base]”. If you are familiar with the natbib package in LaTeX, @key is basically \\citet{key}, and [@key] is equivalent to \\citep{key}. There are a number of fields in a bibliography entry, such as title, author, and year, etc. You may see https://en.wikipedia.org/wiki/BibTeX for possible types of entries and fields in BibTeX. There is a helper function write_bib() in knitr to generate BibTeX entries automatically for R packages. Note that it only generates one BibTeX entry for the package itself at the moment, whereas a package may contain multiple entries in the CITATION file, and some entries are about the publications related to the package. These entries are ignored by write_bib(). # the second argument can be a .bib file knitr::write_bib(c(&#39;knitr&#39;, &#39;stringr&#39;), &#39;&#39;, width = 60) @Manual{R-knitr, title = {knitr: A General-Purpose Package for Dynamic Report Generation in R}, author = {Yihui Xie}, year = {2018}, note = {R package version 1.20}, url = {https://CRAN.R-project.org/package=knitr}, } @Manual{R-stringr, title = {stringr: Simple, Consistent Wrappers for Common String Operations}, author = {Hadley Wickham}, year = {2018}, note = {R package version 1.3.1}, url = {https://CRAN.R-project.org/package=stringr}, } Once you have one or multiple .bib files, you may use the field bibliography in the YAML metadata of your first R Markdown document (which is typically index.Rmd), and you can also specify the bibliography style via biblio-style (this only applies to PDF output), e.g., --- bibliography: [&quot;one.bib&quot;, &quot;another.bib&quot;, &quot;yet-another.bib&quot;] biblio-style: &quot;apalike&quot; link-citations: true --- The field link-citations can be used to add internal links from the citation text of the author-year style to the bibliography entry in the HTML output. When the output format is LaTeX, citations will be automatically put in a chapter or section. For non-LaTeX output, you can add an empty chapter as the last chapter of your book. For example, if your last chapter is the Rmd file 06-references.Rmd, its content can be an inline R expression: `r if (knitr::is_html_output()) &#39;# References {-}&#39;` D.9 Index Currently the index is only supported for LaTeX/PDF output. To print an index after the book, you can use the LaTeX package makeidx in the preamble (see Section ??): \\usepackage{makeidx} \\makeindex Then insert \\printindex at the end of your book through the YAML option includes -&gt; after_body. An index entry can be created via the \\index{} command in the book body, e.g., \\index{GIT}. D.10 HTML widgets Although one of R’s greatest strengths is data visualization, there are a large number of JavaScript libraries for much richer data visualization. These libraries can be used to build interactive applications that can easily render in web browsers, so users do not need to install any additional software packages to view the visualizations. One way to bring these JavaScript libraries into R is through the htmlwidgets package [@R-htmlwidgets]. HTML widgets can be rendered as a standalone web page (like an R plot), or embedded in R Markdown documents and Shiny applications. They were originally designed for HTML output only, and they require the availability of JavaScript, so they will not work in non-HTML output formats, such as LaTeX/PDF. Before knitr v1.13, you will get an error when you render HTML widgets to an output format that is not HTML. Since knitr v1.13, HTML widgets will be rendered automatically as screenshots taken via the webshot package [@R-webshot]. Of course, you need to install the webshot package. Additionally, you have to install PhantomJS (http://phantomjs.org), since it is what webshot uses to capture screenshots. Both webshot and PhantomJS can be installed automatically from R: install.packages(&#39;webshot&#39;) webshot::install_phantomjs() The function install_phantomjs() works for Windows, OS X, and Linux. You may also choose to download and install PhantomJS by yourself, if you are familiar with modifying the system environment variable PATH. When knitr detects an HTML widget object in a code chunk, it either renders the widget normally when the current output format is HTML, or saves the widget as an HTML page and calls webshot to capture the screen of the HTML page when the output format is not HTML. Here is an example of a table created from the DT package [@R-DT]: DT::datatable(iris) Figure D.5: A table widget rendered via the DT package. If you are reading this book as web pages now, you should see an interactive table generated from the above code chunk, e.g., you may sort the columns and search in the table. If you are reading a non-HTML version of this book, you should see a screenshot of the table. The screenshot may look a little different with the actual widget rendered in the web browser, due to the difference between a real web browser and PhantomJS’s virtual browser. There are a number of knitr chunk options related to screen-capturing. First, if you are not satisfied with the quality of the automatic screenshots, or want a screenshot of the widget of a particular state (e.g., after you click and sort a certain column of a table), you may capture the screen manually, and provide your own screenshot via the chunk option screenshot.alt (alternative screenshots). This option takes the paths of images. If you have multiple widgets in a chunk, you can provide a vector of image paths. When this option is present, knitr will no longer call webshot to take automatic screenshots. Second, sometimes you may want to force knitr to use static screenshots instead of rendering the actual widgets even on HTML pages. In this case, you can set the chunk option screenshot.force = TRUE, and widgets will always be rendered as static images. Note that you can still choose to use automatic or custom screenshots. Third, webshot has some options to control the automatic screenshots, and you may specify these options via the chunk option screenshot.opts, which takes a list like list(delay = 2, cliprect = 'viewport'). See the help page ?webshot::webshot for the full list of possible options, and the package vignette vignette('intro', package = 'webshot') illustrates the effect of these options. Here the delay option can be important for widgets that take long time to render: delay specifies the number of seconds to wait before PhantomJS takes the screenshot. If you see an incomplete screenshot, you may want to specify a longer delay (the default is 0.2 seconds). Fourth, if you feel it is slow to capture the screenshots, or do not want to do it every time the code chunk is executed, you may use the chunk option cache = TRUE to cache the chunk. Caching works for both HTML and non-HTML output formats. Screenshots behave like normal R plots in the sense that many chunk options related to figures also apply to screenshots, including fig.width, fig.height, out.width, fig.cap, and so on. So you can specify the size of screenshots in the output document, and assign figure captions to them as well. The image format of the automatic screenshots can be specified via the chunk option dev, and possible values are pdf, png, and jpeg. The default for PDF output is pdf, and it is png for other types of output. Note that pdf may not work as faithfully as png: sometimes there are certain elements on an HTML page that fail to render to the PDF screenshot, so you may want to use dev = 'png' even for PDF output. It depends on specific cases of HTML widgets, and you can try both pdf and png (or jpeg) before deciding which format is more desirable. To include literal backticks, use more backticks outside, e.g., you can use two backticks to preserve one backtick inside: `` `code` ``.↩ Some examples are adapted from the Wikipedia page https://en.wikipedia.org/wiki/Characteristic_function_(probability_theory)↩ You may consider using the code chunk labels.↩ Do not forget the leading backslash! And also note the parentheses () after ref; they are not curly braces {}.↩ The type name is case-insensitive, so it does not matter if it is manual, Manual, or MANUAL.↩ "],
["chap-faqs.html", "E 常见问题", " E 常见问题 如何修改rm命令，让删除的文件去回收站？ 文件被删且难以恢复，想必很多人都曾经遇到过。参考这里。具体做法如下。 $ sudo apt install trash-cli $ gedit ~/.bashrc 打开文件，在末尾加上，alias rm='trash-put'，保存退出。运行如下命令。 $ source .bashrc 重启终端即可。想用原生的 rm，则为 \\rm。当然这样也有弊端，详细说明见这里。 文章标题索引时不可以放在标题末尾 索引有个坑，见这里。另外，如果一些\\ref \\cite 的编号出错了，也容易导致在目录里无索引无参考文献。 为什么中文双引号要用 \\cqh和\\cqt表示？ 因为没能很好的解决中文双引号问题，使用 \\cqh（Chinese Quote Head）,\\cqt（Chinese Quote Tail），折衷解决。见 https://stackoverflow.com/questions/52052231/how-to-write-chinese-quotes-in-bookdown 代码框里下划线#怎么处置？ 直接使用 `#`，单个#会变成两个#。待完成本书，去pandoc提意见，再改。对于代码中出现，作为注释符号时，没有问题，但是出现在字符串中时，可能需要把整段代码改为\\lstset{mathescape=true}，改完后，再改回\\lstset{mathescape=false}。作为特殊字符处理，不然报错。例子见第12章相关代码。 deepin/win10双系统deepin下其他盘带锁问题。 Windows10进入后，按Super键（也就是Windows图案的键，或者直接点击左下角的微软标志），弹出如图??所示操作栏，点击设置。 打开Windows10设置 点击系统大按钮，如图??所示。 选择系统设置 选择电源和睡眠选项-&gt;其他电源设置。如图??所示。 选择其他电源设置 选择电源和按钮的功能选项。如图??所示。 选择电源和按钮的功能 取消快速启动，并确定。如图??所示。 取消快速启动 "],
["install-further-read.html", "F 操作系统安装延伸阅读 F.1 计算机引导过程 F.2 常见 BIOS 设置 F.3 LINUX 启动过程", " F 操作系统安装延伸阅读 F.1 计算机引导过程 F.1.1 传统 BIOS 引导 所谓 BIOS 或 Basic Input-Output System, 就是开机时第一个被执行的程序，又名固件。一般来说它储存在主板上的一块闪存中，与硬盘彼此独立。 BIOS 被启动后，会按启动顺序加载磁盘的前 512 字节，即主引导记录，前 440 字节包含某个启动引导器，像 GRUB、Syslinux 和 LILO 之类的第一启动阶段代码。因为空间太小了，后续的启动代码保存在磁盘上，最后启动引导器又通过「链式引导」，或是直接加载内核，以加载一个操作系统。 整个过程如下： 开机时加电自检。 加电自检后，BIOS 初始化一些必要的硬件以准备引导，比如硬盘和键盘等。 BIOS 执行在「BIOS 硬盘顺序」中的第一块硬盘上的前 440 字节代码，即主引导记录。 MBR 接管后，执行它之后的第二阶段代码，如果后者存在的话，它一般就是启动引导器。 第二阶段代码会读取它的支持文件和配置文件。 F.1.2 UEFI 引导 UEFI 不仅能读取分区表，还能自动支持文件系统。所以它不像 BIOS，已经没有仅仅 440 字节可执行代码即 MBR 的限制了，它完全用不到 MBR。 UEFI 主流都支持 MBR 和 GPT 分区表。Apple-Intel Macs 上的 EFI 还支持 Apple 专用分区表。绝大部分 UEFI 固件支持软盘上的 FAT12，硬盘上的 FAT16、FAT32 文件系统，以及 CD/DVDs 的 IS09660 和 UDF。Intel Macs 的 EFI 还额外支持 HFS/HFS+ 文件系统。 不管第一块上有没有 MBR，UEFI 都不会执行它。相反，它依赖分区表上的一个特殊分区，叫 EFI 系统分区，里面有 UEFI 所要用到的一些文件。计算机供应商可以在 /EFI//文件夹里放官方指定的文件，还能用固件或它的 shell，即 UEFI shell，来启动引导程序。EFI 系统分区一般被格式化成 FAT32，或比较非主流的 FAT16。 F.1.3 UEFI 的多重引导 因为每个操作系统或者提供者都可以维护自己的 EFI 系统分区中的文件，同时不影响其他系统，所以 UEFI 的多重启动只是简单的运行不同的UEFI 程序，对应于特定操作系统的引导程序。这避免了依赖 chainloading 机制（通过一个启动引导程序加载另一个引导程序，来切换操作系统）。 UEFI 引导的过程如下： 系统开机 - 上电自检（Power On Self Test 或 POST）。 UEFI 固件被加载，并由它初始化启动要用的硬件。 固件读取其引导管理器以确定从何处（比如，从哪个硬盘及分区）加载哪个 UEFI 应用。 固件按照引导管理器中的启动项目，加载UEFI 应用。 已启动的 UEFI 应用还可以启动其他应用（对应于 UEFI shell 或 rEFInd 之类的引导管理器的情况）或者启动内核及initramfs（对应于GRUB之类引导器的情况），这取决于 UEFI 应用的配置。 F.2 常见 BIOS 设置 F.2.1 常见启动引导器 BIOS 或 UEFI 加载并初始化硬件完成后，会启动的一个启动引导器来接管硬件设备，引导操作系统启动的工作将有启动引导器来完成。 引导程序引导方式及程序视应用机型种类而不同。例如在普通的个人电脑上，引导程序通常分为两部分：第一阶段引导程序位于主引导记录（MBR），用以引导位于某个分区上的第二阶段引导程序，如 NTLDR、BOOTMGR 和 GNU GRUB 等。 F.2.2 NTLDR/BOOTMGR NTLDR（NT loader 的缩写）是微软的Windows NT系列操作系统（包括Windows XP和Windows Server 2003）的引导程序。 NTLDR 可以从硬盘以及 CD-ROM、优盘等移动存储器运行并引 Windows NT 系统的启动。如果要用 NTLDR 启动其他操作系统，则需要将该操作系统所使用的启动扇区代码保存为一个文件，NTLDR 可以从这个文件加载其它引导程序。 NTLDR 主要由两个文件组成，这两个文件必须放在系统分区（大多数情况下都是C盘）： NTLDR，这是引导程序本身 boot.ini，这是引导程序的配置文件 当 boot.ini 丢失时，NTLDR 会启动第一块硬盘第一个分区上的 /Windows 目录中的系统。 bootmgr (Windows Boot Manager) 是从 Windows Vista 开始引进的新一代开机管理程序，用以替换 NTLDR 。 当电脑运行完 POST (Power On Self Test) 后，传统型 BIOS 会根据引导扇区查找开机硬盘中标记引导分区下的 bootmgr 文件；若是 UEFI 则是 bootmgr.efi 文件，接着管理程序会读取开机配置数据库 BCD (Boot Configuration Database) 内的引导数据，接着根据其中的数据加载与默认或用户所选择的操作系统。 F.2.3 GNU GRUB 及其使用 GNU GRUB（简称“GRUB”）是一个来自 GNU 项目的启动引导程序。GRUB 是多启动规范的实现，它允许用户可以在计算机内同时拥有多个操作系统，并在计算机启动时选择希望运行的操作系统。GRUB 可用于选择操作系统分区上的不同内核，也可用于向这些内核传递启动参数。 GRUB Legacy / GURB2 新的GRUB2（GRUB第二版）為GRUB的重写版本，它是GRUB的大革新。GRUB2对Linux系統做了更多的优化，支持更多的功能，如动态的载入模块（而在之前的GRUB中，新增或刪除模块要重新编译GRUB）等。GRUB2的版本号为0.98或更高；旧的GRUB的版本号则为0.97或更低，也被称为“GRUB Legacy”或“GRUB1”等。GRUB2的配置、命令等较GRUB Legacy有一定的不同。 GRUB2 的配置文件 GRUB2 配置文件的文件名和位置随系统的不同而不同；常见为/boot/grub/grub.conf。 修改GRUB的配置文件后，不必把GRUB重新安装到MBR或者某个分区中。在Linux中，“grub-install”命令是用来把GRUB的步骤1安装到MBR或者分区中的。GRUB的配置文件、步骤2以及其它文件必须安装到某个可用的分区中。如果这些文件或者分区不可用，步骤1将把用户留在命令行界面。 除了硬盘外，GRUB也可安装到光盘、软盘和优盘等移动介质中，这样就可以带起一台无法从硬盘启动的系统。 使用 GRUB Shell F.3 LINUX 启动过程 F.3.1 VMLINUZ vmlinux：一个非压缩的，静态链接的，可执行的，不能bootable的Linux kernel文件。是用来生成vmlinuz的中间步骤。 vmlinuz：一个压缩的，能bootable的Linux kernel文件。vmlinuz是Linux kernel文件的历史名字，它实际上就是zImage或bzImage。 zImage： 仅适用于640k内存的Linux kernel文件。 bzImage： Big zImage，适用于更大内存的Linux kernel文件。 对于目前的 Linux 桌面系统，vmlinuz 实际上即 bzImage kernel 文件。 F.3.2 INITRD initrd 的英文含义是 initialized RAM disk，就是由 bootloader 初始化的内存盘。在 linux内核启动前， bootloader 会将存储介质中的 initrd 文件加载到内存，内核启动时会在访问真正的根文件系统前先访问该内存中的 initrd 文件系统。 initrd 分 image-initrd 及 cpio-initrd 两种。 2.4 及以前的内核只支持 image-initrd，其核心文件是/linuxrc。 2.6 及以后的内核两种格式的 initrd 都支持，并且目前的 Linux 发行版使用的几乎都是 cpio-initrd，其核心文件是/init。 在 bootloader 配置了 initrd 的情况下，内核启动被分成了两个阶段，第一阶段先执行 initrd 文件系统中的/init(或早期的/linuxrc)，完成加载驱动模块等任务，第二阶段才会挂载真正的根文件系统中，并且 chroot 到真正的根文件系统 （例如硬盘上的某个分区）来完成系统的启动。 转载网页： http://wiki.deepin.org/wiki/DEEPIN_%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%A6%82%E8%BF%B0 "],
["history.html", "G 大事记", " G 大事记 2017-08-26 开工找模板。 2017-09-28 买到《Linux Bible》实体书中文版，可以带徒弟一起写本文了。 2017-10-26 第一次开课，给俩兄弟讲 Linux 下 C 语言基础。 2017-10-29 R 语言更新，貌似旧的安装方法已经无法在 deepin 下安装，需要调整，暂时没有调整。 2017-10-29 注册了优酷土豆账号，用于上传本书的相关视频。 2018-05-29 模板转移SJTU模板中 2018-07-02 第一版草稿成功出炉 2018-07-10 成功转移到新模板 2018-08-28 定个一百天计划，一周一章，直至元旦，从这周开始。 2018-11-22 完成第二部分，现实太残酷，一月一章吧。 2018-12-04 家庭事务繁多，今年到此为止，明年开春后再更新。 "]
]
